"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[19033],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var r=n(96540);const a={},i=r.createContext(a);function s(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:t},e.children)}},76408:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Task_flow/Tasks/Import_tasks_rejecting_tables","title":"Import tasks: rejecting tables","description":"Instead of having jobs produce import status files, you can use the database for import error handling. Several strategies exist:","source":"@site/docs/Task_flow/Tasks/Import_tasks_rejecting_tables.md","sourceDirName":"Task_flow/Tasks","slug":"/Task_flow/Tasks/Import_tasks_rejecting_tables","permalink":"/udocs/Task_flow/Tasks/Import_tasks_rejecting_tables","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Import_tasks_rejecting_tables"},"sidebar":"sidebar","previous":{"title":"Import task status files","permalink":"/udocs/Task_flow/Tasks/Import_task_status_files"},"next":{"title":"Import tasks: Recognising external file layout","permalink":"/udocs/Task_flow/Tasks/Import_tasks_Recognising_external_file_layout"}}');var a=n(74848),i=n(28453);const s={id:"Import_tasks_rejecting_tables"},o="Import tasks: rejecting tables",l={},c=[{value:"Defining a Reject table",id:"defining-a-reject-table",level:2},{value:"Transferring error status data into a Reject table",id:"transferring-error-status-data-into-a-reject-table",level:2},{value:"Importing all records via a Reject table",id:"importing-all-records-via-a-reject-table",level:2},{value:"Detecting and repairing expected import errors before bulk import",id:"detecting-and-repairing-expected-import-errors-before-bulk-import",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"import-tasks-rejecting-tables",children:"Import tasks: rejecting tables"})}),"\n",(0,a.jsx)(t.p,{children:"Instead of having jobs produce import status files, you can use the database for import error handling. Several strategies exist:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:'Have a default error file made, then import the error file into a "reject table". A reject table corresponds to one application table. Its purpose is to accept records that for some reason could not be imported into the application table.'}),"\n",(0,a.jsx)(t.li,{children:"Import all records into a reject table, then have USoft Batch transfer records from this table into the actual application table where possible. After this operation, the contents of the reject table can be read as an error report."}),"\n",(0,a.jsx)(t.li,{children:"Import expected error data into a reject table, deal with this data separately, then import all data into the application table."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Depending on the strategy chosen, general advantages of storing import errors are:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"You do not need to maintain import status files. If you disable their creation, performance is improved."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Error reports that are stored in the database (as opposed to files) can be:"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Made more readable"}),"\n",(0,a.jsx)(t.li,{children:"Queried using any desired ad-hoc query"}),"\n",(0,a.jsx)(t.li,{children:"Made to contain any desired additional information"}),"\n",(0,a.jsx)(t.li,{children:"Easily processed further, using SQL."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"defining-a-reject-table",children:"Defining a Reject table"}),"\n",(0,a.jsx)(t.p,{children:"If you want to use a reject table, you need to define it in USoft Definer. A reject table is a duplication of an application table."}),"\n",(0,a.jsx)(t.p,{children:"However, some duplicated columns might be based on different domains from those used by the application table, because domain constraints and other implicit rules defined at domain level must not apply to the reject table."}),"\n",(0,a.jsx)(t.p,{children:'It is suggested that you define a number of dummy string domains ("description" domains) of different lengths. Reserve these domains for reject columns.'}),"\n",(0,a.jsx)(t.p,{children:"To define a reject table:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Determine what dummy string domains you need, and define them."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Define a new domain that will generate unique numerical values for the primary key of the reject table."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Determine if you want any additional information in the reject table, such as a timestamp. Define new domains where necessary."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Define the reject table and its columns. Columns should include:"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Numerical primary key column based on the newly defined domain."}),"\n",(0,a.jsx)(t.li,{children:"One duplicated column for each application column. Each duplicated column must be based on a dummy (string) domain without domain constraints."}),"\n",(0,a.jsx)(t.li,{children:"Any additional columns such as a timestamp."}),"\n"]}),"\n",(0,a.jsxs)(t.ol,{start:"5",children:["\n",(0,a.jsx)(t.li,{children:"Have the reject table implemented by choosing Tools, Create Physical Tables (option New or Updated) from the Definer menu bar."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"transferring-error-status-data-into-a-reject-table",children:"Transferring error status data into a Reject table"}),"\n",(0,a.jsx)(t.p,{children:"To transfer error status data into a reject table:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Define and create a reject table if necessary."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:'Define an import task importing records into the application table from a "<file name>.<file extension>" file.'}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:'Define an error import task importing all records into the reject table from the "<file name>.ERR" file.'}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Append the error import task to the main import task. For instance, define an overall job that contains first the main import task and then the error import task."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Run the overall job. Rejected records will be imported into the reject table."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"importing-all-records-via-a-reject-table",children:"Importing all records via a Reject table"}),"\n",(0,a.jsx)(t.p,{children:'Perhaps "Reject Table" in this strategy would be more appropriately termed "import table". It is a reject table in the sense that rejected records remain in it.'}),"\n",(0,a.jsx)(t.p,{children:"The advantage of this strategy is that you import all data in one go. You do not need to rely on an external file halfway into the import task. You can also use constraints and status fields to process import records from the reject table in a controlled manner."}),"\n",(0,a.jsx)(t.p,{children:"One drawback of this strategy is that you require more database space. You are also likely to need more processing time."}),"\n",(0,a.jsx)(t.p,{children:"To import all records from an external file via a reject table:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Define and create a reject table if necessary."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Define an import task importing all records into the reject table."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Define a SQL task transferring records from the reject table to the application table."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The basic idea is to write these SQL statements:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"INSERT INTO \xa0 ( application table>[(columns)] )\nSELECT \xa0 \xa0 \xa0 \xa0( all records )\nFROM \xa0 \xa0 \xa0 \xa0  ( reject table )\nDELETE \xa0 \xa0 \xa0 \xa0( all records )\nFROM \xa0 \xa0 \xa0 \xa0 \xa0( reject table )\nWHERE EXISTS \xa0( condition to check whether records are inserted in application table )\n\n"})}),"\n",(0,a.jsx)(t.p,{children:"You have a lot of flexibility here. Instead of using a SQL task you could use productive constraints or status fields. Import data could be written to more than one application table, etc."}),"\n",(0,a.jsxs)(t.ol,{start:"4",children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Append the SQL task to the import task (following it). For instance, define an overall job that contains the import task and then the SQL task."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Run the overall job. Rejected records will remain in the reject table."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"detecting-and-repairing-expected-import-errors-before-bulk-import",children:"Detecting and repairing expected import errors before bulk import"}),"\n",(0,a.jsx)(t.p,{children:"This is a good strategy if there are clearly defined expected errors in external data, and if they are likely to affect only a small subset of the data."}),"\n",(0,a.jsx)(t.p,{children:"To detect and repair expected import errors before bulk import:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Define and create a reject table if necessary."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Define an error import task importing records that have expected errors into the reject table (use a WHERE clause to test for the error)."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Define the main import task. This job can be based on the assumption that the expected error(s) no longer exist(s) in the data."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Alternatively, you can append the main import task to the error import task, and make it conditional upon the error import no longer affecting any data."}),"\n",(0,a.jsxs)(t.ol,{start:"4",children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Run the error import task."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Inspect the reject table. On the basis of this information, fix the errors in the external file."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"If necessary, run the error import task again to test that the error no longer occurs."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Run the main import task."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);