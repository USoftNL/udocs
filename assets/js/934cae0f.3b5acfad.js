"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[55328],{28453:(e,t,i)=>{i.d(t,{R:()=>c,x:()=>o});var r=i(96540);const n={},s=r.createContext(n);function c(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:c(e.components),r.createElement(s.Provider,{value:t},e.children)}},96133:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Repositories/Blend_directives/pcZipExtractFiles","title":"pc:ZipExtractFiles","description":"This article is about the pc:ZipExtractFiles Blend directive.","source":"@site/docs/Repositories/Blend_directives/pcZipExtractFiles.md","sourceDirName":"Repositories/Blend_directives","slug":"/Repositories/Blend_directives/pcZipExtractFiles","permalink":"/udocs/Repositories/Blend_directives/pcZipExtractFiles","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"pcZipExtractFiles"},"sidebar":"sidebar","previous":{"title":"pc:XmlImportApply","permalink":"/udocs/Repositories/Blend_directives/pcXmlImportApply"},"next":{"title":"pc:ZipFile","permalink":"/udocs/Repositories/Blend_directives/pcZipFile"}}');var n=i(74848),s=i(28453);const c={id:"pcZipExtractFiles"},o="pc",a={},l=[{value:"<strong>pc</strong>",id:"pc-1",level:2}];function p(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsxs)(t.h1,{id:"pc",children:["pc",":ZipExtractFiles"]})}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["This article is about the ",(0,n.jsxs)(t.strong,{children:["pc",":ZipExtractFiles"]}),(0,n.jsx)(t.a,{href:"/Repositories/Blend_directives",children:" Blend directive"}),"."]})}),"\n",(0,n.jsx)(t.h2,{id:"pc-1",children:(0,n.jsxs)(t.strong,{children:["pc",":ZipExtractFiles"]})}),"\n",(0,n.jsx)(t.p,{children:"Unzips a set of files from a ZIP file."}),"\n",(0,n.jsx)(t.p,{children:"There is no result value."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Syntax"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:'<pc:ZipExtractFiles\n  filepath="*file-path*"\n  pattern="*pattern*"\n  destinationpath="*folder-path*"\n  overwrite="*overwrite*"\n/>\n\n*overwrite*  ::=  { yes | no }\n'})}),"\n",(0,n.jsxs)(t.p,{children:["The required ",(0,n.jsx)(t.strong,{children:"filepath"})," is a file path leading to the ZIP file that you want to extract files from."]}),"\n",(0,n.jsxs)(t.p,{children:["The required ",(0,n.jsx)(t.strong,{children:"pattern"})," is a directory name pattern identifying the subset of files and directories to be extracted. In such a pattern, one or more asterisks (\xa0*\xa0) act as a wildcard character. To extract the entire content of the file, specify:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:'pattern="*"\n'})}),"\n",(0,n.jsx)(t.p,{children:"The required destinationpath is a folder path leading to the directory where you want the output to be unzipped to."}),"\n",(0,n.jsx)(t.p,{children:'If you set overwrite="yes", result directories and files that already exist by the same name are silently overwritten. Otherwise, if any result directory or file already exists, the entire operation is cancelled and an error message is returned.'}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Example"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-xml",children:'<root xmlns:pc="Processing.Command">\n  <pc:ZipExtractFiles filepath="c:\\temp\\Installation.zip" pattern="asset*\\asset*" destinationpath="c:\\temp\\output" />\n</root>\n'})}),"\n",(0,n.jsx)(t.p,{children:"\xa0"})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(p,{...e})}):p(e)}}}]);