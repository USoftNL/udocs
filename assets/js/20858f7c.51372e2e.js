"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[81892],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var i=s(96540);const o={},t=i.createContext(o);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(t.Provider,{value:n},e.children)}},67769:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Repositories/Blend_directives/pcassignboolean","title":"pc:assign-boolean","description":"This article is about the pc:assign-booleanBlend directive.","source":"@site/docs/Repositories/Blend_directives/pcassignboolean.md","sourceDirName":"Repositories/Blend_directives","slug":"/Repositories/Blend_directives/pcassignboolean","permalink":"/udocs/Repositories/Blend_directives/pcassignboolean","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"pcassignboolean"},"sidebar":"sidebar","previous":{"title":"pc:apply2file","permalink":"/udocs/Repositories/Blend_directives/pcapply2file"},"next":{"title":"pc:assign-boolean-default","permalink":"/udocs/Repositories/Blend_directives/pcassignbooleandefault"}}');var o=s(74848),t=s(28453);const r={id:"pcassignboolean"},a="pc",l={},c=[{value:"<strong>pc</strong>",id:"pc-1",level:2},{value:"XSLT-style conversion rules",id:"xslt-style-conversion-rules",level:2},{value:"&quot;Flag-based&quot; conversion rules",id:"flag-based-conversion-rules",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsxs)(n.h1,{id:"pc",children:["pc",":assign-boolean"]})}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["This article is about the ",(0,o.jsxs)(n.strong,{children:["pc",":assign-boolean"]}),(0,o.jsx)(n.a,{href:"/Repositories/Blend_directives",children:"Blend directive"}),"."]})}),"\n",(0,o.jsx)(n.h2,{id:"pc-1",children:(0,o.jsxs)(n.strong,{children:["pc",":assign-boolean"]})}),"\n",(0,o.jsxs)(n.p,{children:["Evaluates an expression and converts the resulting value to a ",(0,o.jsx)(n.strong,{children:"boolean"}),' using either XSLT-style string-to-boolean conversion (the default) or "flag-based" string-to-boolean conversion. Stores the resulting boolean in (= assigns the resulting boolean to) a named variable. The variable is global: from any later script section you can refer to its value by writing ',(0,o.jsx)(n.em,{children:"$variable"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["If a variable by the same name is already instantiated, its value is silently overwritten. This is the difference with pc",":assign-boolean-default","."]}),"\n",(0,o.jsxs)(n.p,{children:["You have the option to assign multiple booleans in a single pc",":assign-boolean"," directive."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Syntax"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'<pc:assign-boolean  pc:booleanflags="*booleanflags*"\n*variable = "expr"*\n  [  *variable = "expr"* ... ] />\n\n*booleanflags*  ::=  { yes | no }\n'})}),"\n",(0,o.jsxs)(n.p,{children:["For each variable, ",(0,o.jsx)(n.em,{children:"variable"})," identifies the variable by name and ",(0,o.jsx)(n.em,{children:"expr"})," is the value you provide for the variable. ",(0,o.jsx)(n.em,{children:"Expr"})," may be submitted either as a literal or as an XPath expression presented as an attribute value template, ie., surrounded by curly braces (\xa0","\xa0)."]}),"\n",(0,o.jsxs)(n.p,{children:["If you set ",(0,o.jsx)(n.em,{children:"booleanflags"}),' to "yes", then special "flag-based" conversion rules are applied that are specific to USoft Blend. Otherwise, XSLT-style conversion rules are applied.']}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Example"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<example xmlns:pc="Processing.Command">\n   <pc:assign-nodeset registry="registry.xml"/>\n   <pc:assign-boolean myboolean="{$registry//Computer[@name=\'COMPUTER_1\']/Subtotals/@total}"/>\n   <pc:if-then test="$myboolean">The specified "total" attribute exists in the registry.</pc:if-then>\n</example>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"xslt-style-conversion-rules",children:"XSLT-style conversion rules"}),"\n",(0,o.jsx)(n.p,{children:"According to these rules, which are the string-to-boolean conversion rules of XSLT 1.0,"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["If the incoming value is a string, it converts to boolean ",(0,o.jsx)(n.strong,{children:"false()"})," if the string is empty, to boolean ",(0,o.jsx)(n.strong,{children:"true()"})," otherwise."]}),"\n",(0,o.jsxs)(n.li,{children:["If the incoming value is a number, it converts to boolean ",(0,o.jsx)(n.strong,{children:"false()"})," if the value is 0 (zero) or ",(0,o.jsx)(n.strong,{children:"NaN"})," (not-a-number), to boolean ",(0,o.jsx)(n.strong,{children:"true()"})," otherwise."]}),"\n",(0,o.jsxs)(n.li,{children:["If the incoming value is a node set, as in the Example, it converts to boolean ",(0,o.jsx)(n.strong,{children:"false()"})," if the node set is empty, to boolean ",(0,o.jsx)(n.strong,{children:"true()"})," otherwise."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"flag-based-conversion-rules",children:'"Flag-based" conversion rules'}),"\n",(0,o.jsx)(n.p,{children:"These rules use a mapping between string values and boolean truth values. This allows you to have the string false interpreted as boolean false() even though it is not an empty string."}),"\n",(0,o.jsxs)(n.p,{children:["These rules are the rules applied by the booleanflags",":ToBoolean"," function."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);