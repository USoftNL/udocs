"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[36626],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(96540);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}},92047:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Modeller_and_Rules_Engine/Supertypes_and_subtypes/Designing_subtypes_successfully","title":"Designing subtypes successfully","description":"This help topic contains tips for good design of subtypes.","source":"@site/docs/Modeller_and_Rules_Engine/Supertypes_and_subtypes/Designing_subtypes_successfully.md","sourceDirName":"Modeller_and_Rules_Engine/Supertypes_and_subtypes","slug":"/Modeller_and_Rules_Engine/Supertypes_and_subtypes/Designing_subtypes_successfully","permalink":"/udocs/Modeller_and_Rules_Engine/Supertypes_and_subtypes/Designing_subtypes_successfully","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Designing_subtypes_successfully"},"sidebar":"sidebar","previous":{"title":"GUI implementation of subtypes","permalink":"/udocs/Modeller_and_Rules_Engine/Supertypes_and_subtypes/GUI_implementation_of_subtypes"},"next":{"title":"Subtype definitions","permalink":"/udocs/Modeller_and_Rules_Engine/Supertypes_and_subtypes/Subtype_definitions"}}');var i=n(74848),a=n(28453);const o={id:"Designing_subtypes_successfully"},r="Designing subtypes successfully",l={},d=[{value:"Avoiding mandatory subtype columns without default values",id:"avoiding-mandatory-subtype-columns-without-default-values",level:2},{value:"Keeping subtype indicators at their default",id:"keeping-subtype-indicators-at-their-default",level:2},{value:"Setting Delete Super on Delete",id:"setting-delete-super-on-delete",level:2},{value:"Setting Update Supertype on Insert",id:"setting-update-supertype-on-insert",level:2}];function u(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"designing-subtypes-successfully",children:"Designing subtypes successfully"})}),"\n",(0,i.jsx)(t.p,{children:"This help topic contains tips for good design of subtypes."}),"\n",(0,i.jsx)(t.h2,{id:"avoiding-mandatory-subtype-columns-without-default-values",children:"Avoiding mandatory subtype columns without default values"}),"\n",(0,i.jsx)(t.p,{children:"The USoft implementation of subtypes has drawbacks when dealing with mandatory subtype columns that have no default value defined for them:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Do not define Mandatory = Yes for a subtype column unless this is really necessary from a functional point of view."}),"\n",(0,i.jsx)(t.li,{children:"Make sure that each subtype column that has Mandatory = Yes also has a default value, if this is at all possible. You can define a default value for a column by setting Default Value at domain level or at column level."}),"\n",(0,i.jsx)(t.li,{children:"If you plan to have mandatory subtype columns in multiple subtypes that share the same supertype, be aware that such a construct is relatively difficult to transfer to a different repository when using XML formats (XML.Export, XML.Import, XML.MultiExportTables, as also used by the USoft Delivery Manager XML routines). Special arrangements are necessary. See the Delivery Manager Help for details."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"keeping-subtype-indicators-at-their-default",children:"Keeping subtype indicators at their default"}),"\n",(0,i.jsx)(t.p,{children:"USoft creates a subtype indicator column when you define a subtype. By default, such a subtype indicator is based on the BOOLEAN template domain, this BOOLEAN domain has Default Value = N, and each subtype indicator has Default Value = (null) at column level."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Avoid subtype indicators with a default value of Y, if at all possible."}),"\n",(0,i.jsx)(t.li,{children:"Do not interfere with the BOOLEAN domain and its settings, nor with any other USoft-shipped domain. Use your own domains for columns you define yourself."}),"\n",(0,i.jsx)(t.li,{children:"Keep all subtype indicators based on the BOOLEAN domain, if at all possible."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"setting-delete-super-on-delete",children:"Setting Delete Super on Delete"}),"\n",(0,i.jsx)(t.p,{children:"For subtype tables, you can set the Delete Super on Delete table attribute."}),"\n",(0,i.jsx)(t.p,{children:"When the user deletes subtype data, Delete Super on Delete determines what happens to the remainder of the record constellation (supertype data and possibly other subtype data)."}),"\n",(0,i.jsx)(t.p,{children:"If Delete Super on Delete is set (the default), deleting subtype data automatically results in deleting corresponding supertype data and all other subtype data (the entire record constellation). Transition constraints defined on the constellation are evaluated if the Fire On Delete flag is set."}),"\n",(0,i.jsx)(t.p,{children:"If Delete Super on Delete is NOT set, deleting subtype data from a subtype window is handled as an UPDATE to the constellation. The corresponding subtype indicator is set from 'Y(es)' to 'N(o)'. Transition constraints defined on the constellation are evaluated if the Fire On Update flag is set."}),"\n",(0,i.jsx)(t.p,{children:"The following operations are handled differently depending on the Delete Super on Delete attribute:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsx)(t.tr,{children:(0,i.jsx)(t.th,{})})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsx)(t.tr,{children:(0,i.jsx)(t.td,{children:"The user deletes a subtype record from a subtype window opened from a supertype info window."})}),(0,i.jsx)(t.tr,{children:(0,i.jsx)(t.td,{children:"The user deletes a subtype record from a subtype window opened from a supertype info window."})}),(0,i.jsx)(t.tr,{children:(0,i.jsx)(t.td,{children:"The user deletes a record from an info window based on the subtype (which, by default, also shows the supertype columns)."})}),(0,i.jsx)(t.tr,{children:(0,i.jsxs)(t.td,{children:["A productive constraint performs a correction and executes a statement of the following type",":DELETE"," FROM ",(0,i.jsx)(t.em,{children:"subtype"})," ..."]})})]})]}),"\n",(0,i.jsx)(t.p,{children:"The following operations are always handled as a DELETE of the entire record constellation. In these cases the Delete Super on Delete attribute is not relevant:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsx)(t.tr,{children:(0,i.jsx)(t.th,{})})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsx)(t.tr,{children:(0,i.jsx)(t.td,{children:"The user removes a record from an info window based on the supertype."})}),(0,i.jsx)(t.tr,{children:(0,i.jsxs)(t.td,{children:["A productive constraint performs a correction and executes a statement of the following type",":DELETE"," FROM ",(0,i.jsx)(t.em,{children:"supertype"})," ..."]})})]})]}),"\n",(0,i.jsx)(t.h2,{id:"setting-update-supertype-on-insert",children:"Setting Update Supertype on Insert"}),"\n",(0,i.jsx)(t.p,{children:"For the application, you can set the Update Supertype on Insert Deployment Configuration parameter in the Authorizer."}),"\n",(0,i.jsx)(t.p,{children:"This parameter determines what happens to an existing record constellation when the user adds new subtype data to it:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"By entering this data in a subtype window."}),"\n",(0,i.jsx)(t.li,{children:"Indirectly, when a productive constraint is evaluated containing a statement of the following type:"}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"**INSERT INTO** *subtype*** ...**\n"})}),"\n",(0,i.jsx)(t.p,{children:"If Update Supertype on Insert is set to No (the default), inserting new subtype data as described above is handled internally as an INSERT even if a record constellation already existed."}),"\n",(0,i.jsx)(t.p,{children:"If Update Supertype on Insert is set to Yes, the manipulation is handled internally as an UPDATE to the existing record constellation."}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsx)(t.p,{children:"If the user adds new subtype data to an existing record constellation by selecting the corresponding subtype indicator in an info window and then filling out the fields in the subtype window, this is always handled as an UPDATE to the record constellation. Update Supertype on Insert has no relevance in this case."})}),"\n",(0,i.jsx)(t.p,{children:"The Update Supertype on Insert Deployment Configuration parameter has no relevance to the application user."}),"\n",(0,i.jsx)(t.p,{children:"For the application developer, the only relevant aspects of this parameter are:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"If the type of subtype insert described above is traced in BenchMark or in a native database monitoring tool:"}),"\n",(0,i.jsx)(t.li,{children:"If Update Supertype on Insert is set to No, it will show up as an INSERT command."}),"\n",(0,i.jsx)(t.li,{children:"If Update Supertype on Insert is set to Yes, it will show up as an UPDATE command."}),"\n",(0,i.jsx)(t.li,{children:"If the type of subtype insert described above occurs and transitional constraints are defined on the record constellation,"}),"\n",(0,i.jsx)(t.li,{children:"If Update Supertype on Insert is set to No, they are evaluated depending on the Fire on Insert flag."}),"\n",(0,i.jsx)(t.li,{children:"If Update Supertype on Insert is set to Yes, they are evaluated depending on the Fire on Update flag."}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);