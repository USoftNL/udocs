"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[70032],{28453:(e,t,d)=>{d.d(t,{R:()=>l,x:()=>i});var s=d(96540);const r={},n=s.createContext(r);function l(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(n.Provider,{value:t},e.children)}},98969:(e,t,d)=>{d.r(t),d.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>x,frontMatter:()=>l,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"Modeller_and_Rules_Engine/SQL_for_ODBC/ODBC_scalar_data_types","title":"ODBC scalar data types","description":"ODBC scalar data types","source":"@site/docs/Modeller_and_Rules_Engine/SQL_for_ODBC/ODBC_scalar_data_types.md","sourceDirName":"Modeller_and_Rules_Engine/SQL_for_ODBC","slug":"/Modeller_and_Rules_Engine/SQL_for_ODBC/ODBC_scalar_data_types","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_for_ODBC/ODBC_scalar_data_types","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"ODBC_scalar_data_types"},"sidebar":"sidebar","previous":{"title":"ODBC functions used by USoft applications","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_for_ODBC/ODBC_functions_used_by_USoft_applications"},"next":{"title":"Task flow","permalink":"/udocs/Task_flow"}}');var r=d(74848),n=d(28453);const l={id:"ODBC_scalar_data_types"},i="ODBC scalar data types",c={},h=[{value:"ODBC scalar data types",id:"odbc-scalar-data-types-1",level:2},{value:"ODBC Default datatypes",id:"odbc-default-datatypes",level:2},{value:"ODBC substitute data types",id:"odbc-substitute-data-types",level:2}];function a(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"odbc-scalar-data-types",children:"ODBC scalar data types"})}),"\n",(0,r.jsx)(t.h2,{id:"odbc-scalar-data-types-1",children:"ODBC scalar data types"}),"\n",(0,r.jsx)(t.p,{children:"Mapping of USoft Developer data types to ODBC\xa0 data types is as follows:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:(0,r.jsx)(t.strong,{children:"USoft data type"})}),(0,r.jsx)(t.th,{children:(0,r.jsx)(t.strong,{children:"ODBC data type"})})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"BINARY"}),(0,r.jsx)(t.td,{children:"SQL_BINARY"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"BIT"}),(0,r.jsx)(t.td,{children:"SQL_BIT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"CHAR"}),(0,r.jsx)(t.td,{children:"SQL_CHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"CLOB"}),(0,r.jsx)(t.td,{children:"SQL_LONGVARCHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"DATE"}),(0,r.jsx)(t.td,{children:"SQL_TIMESTAMP"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"DATETIME"}),(0,r.jsx)(t.td,{children:"SQL_TIMESTAMP"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"DECIMAL"}),(0,r.jsx)(t.td,{children:"SQL_DECIMAL"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"DOUBLE PRECISION"}),(0,r.jsx)(t.td,{children:"SQL_FLOAT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"FLOAT"}),(0,r.jsx)(t.td,{children:"SQL_FLOAT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"FLOAT4"}),(0,r.jsx)(t.td,{children:"SQL_FLOAT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"IMAGE"}),(0,r.jsx)(t.td,{children:"SQL_LONGVARBINARY"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"INT"}),(0,r.jsx)(t.td,{children:"SQL_INTEGER"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"INTEGER"}),(0,r.jsx)(t.td,{children:"SQL_INTEGER"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"INTEGER1"}),(0,r.jsx)(t.td,{children:"SQL_TINYINT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"LONG"}),(0,r.jsx)(t.td,{children:"SQL_LONGVARCHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"LONG VARBINARY"}),(0,r.jsx)(t.td,{children:"SQL_LONGVARBINARY"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"LONG VARCHAR"}),(0,r.jsx)(t.td,{children:"SQL_LONGVARCHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"LONGRAW"}),(0,r.jsx)(t.td,{children:"SQL_LONGVARBINARY"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"MONEY"}),(0,r.jsx)(t.td,{children:"SQL_FLOAT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"NCHAR"}),(0,r.jsx)(t.td,{children:"SQL_CHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"NUMBER"}),(0,r.jsx)(t.td,{children:"SQL_NUMERIC"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"NUMERIC"}),(0,r.jsx)(t.td,{children:"SQL_NUMERIC"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"NVARCHAR"}),(0,r.jsx)(t.td,{children:"SQL_VARCHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"RAW"}),(0,r.jsx)(t.td,{children:"SQL_VARBINARY"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"REAL"}),(0,r.jsx)(t.td,{children:"SQL_REAL"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SMALLDATETIME"}),(0,r.jsx)(t.td,{children:"SQL_TIMESTAMP"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SMALLINT"}),(0,r.jsx)(t.td,{children:"SQL_SMALLINT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SMALLMONEY"}),(0,r.jsx)(t.td,{children:"SQL_REAL"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"TEXT"}),(0,r.jsx)(t.td,{children:"SQL_LONGVARCHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"TIME"}),(0,r.jsx)(t.td,{children:"SQL_TIMESTAMP"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"TIMESTAMP"}),(0,r.jsx)(t.td,{children:"SQL_TIMESTAMP"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"TINYINT"}),(0,r.jsx)(t.td,{children:"SQL_TINYINT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"VARBINARY"}),(0,r.jsx)(t.td,{children:"SQL_VARBINARY"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"VARCHAR"}),(0,r.jsx)(t.td,{children:"SQL_VARCHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"VARCHAR2"}),(0,r.jsx)(t.td,{children:"SQL_VARCHAR"})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"odbc-default-datatypes",children:"ODBC Default datatypes"}),"\n",(0,r.jsx)(t.p,{children:"When application tables are generated directly on ODBC, USoft Developer retrieves the ODBC DBMS specific data type names from the connected ODBC driver, using the function: SQLGetTypeInfo. If the ODBC-driver does not support this level-1 function or when generating SQL script files (containing CREATE TABLE and INDEX statements), then the following default data type names are used:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:(0,r.jsx)(t.strong,{children:"Required data type"})}),(0,r.jsx)(t.th,{children:(0,r.jsx)(t.strong,{children:"Default name"})})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_CHAR"}),(0,r.jsx)(t.td,{children:"CHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_VARCHAR"}),(0,r.jsx)(t.td,{children:"VARCHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_LONGVARCHAR"}),(0,r.jsx)(t.td,{children:"LONG VARCHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_DECIMAL"}),(0,r.jsx)(t.td,{children:"DECIMAL"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_NUMERIC"}),(0,r.jsx)(t.td,{children:"NUMERIC"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_INTEGER"}),(0,r.jsx)(t.td,{children:"INTEGER"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_SMALLINT"}),(0,r.jsx)(t.td,{children:"SMALLINT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_TINYINT"}),(0,r.jsx)(t.td,{children:"TINYINT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_REAL"}),(0,r.jsx)(t.td,{children:"REAL"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_FLOAT"}),(0,r.jsx)(t.td,{children:"FLOAT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_BIT"}),(0,r.jsx)(t.td,{children:"BIT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_BINARY"}),(0,r.jsx)(t.td,{children:"BINARY"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_VARBINARY"}),(0,r.jsx)(t.td,{children:"VARBINARY"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_LONGVARBINARY"}),(0,r.jsx)(t.td,{children:"LONG VARBINARY"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_DATE"}),(0,r.jsx)(t.td,{children:"DATE"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_TIME"}),(0,r.jsx)(t.td,{children:"TIME"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_TIMESTAMP"}),(0,r.jsx)(t.td,{children:"TIMESTAMP"})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"odbc-substitute-data-types",children:"ODBC substitute data types"}),"\n",(0,r.jsx)(t.p,{children:"When application tables are generated directly on ODBC and the ODBC driver does support the level 1 function SQLGetTypeInfo, but the ODBC-driver does not support a particular ODBC SQL data type, then the following table shows the data type that will be substituted. If that data type is also not supported, then the substitute for that will be used, and so on, down the table."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:(0,r.jsx)(t.strong,{children:"Required data type"})}),(0,r.jsx)(t.th,{children:(0,r.jsx)(t.strong,{children:"Substitute"})})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_CHAR"}),(0,r.jsx)(t.td,{children:"SQL_VARCHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_VARCHAR"}),(0,r.jsx)(t.td,{children:"SQL_CHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_DECIMAL"}),(0,r.jsx)(t.td,{children:"SQL_NUMERIC"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_NUMERIC"}),(0,r.jsx)(t.td,{children:"SQL_DECIMAL"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_SMALLINT"}),(0,r.jsx)(t.td,{children:"SQL_INTEGER"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_INTEGER"}),(0,r.jsx)(t.td,{children:"SQL_SMALLINT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_TINYINT"}),(0,r.jsx)(t.td,{children:"SQL_SMALLINT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_REAL"}),(0,r.jsx)(t.td,{children:"SQL_FLOAT"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_FLOAT"}),(0,r.jsx)(t.td,{children:"SQL_REAL"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_BINARY"}),(0,r.jsx)(t.td,{children:"SQL_VARBINARY"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_VARBINARY"}),(0,r.jsx)(t.td,{children:"SQL_BINARY"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_BIT"}),(0,r.jsx)(t.td,{children:"SQL_BINARY"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_BIT"}),(0,r.jsx)(t.td,{children:"SQL_CHAR"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"SQL_TIMESTAMP"}),(0,r.jsx)(t.td,{children:"SQL_DATE"})]})]})]}),"\n",(0,r.jsx)(t.p,{children:'When application tables are generated, USoft Developer will rename existing tables before creating the new application tables. Because "RENAME TABLE" is not defined in the ODBC SQL syntax specification, USoft Developer will generate the following standard syntax when generating SQL-script files:'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-sql",children:"ALTER TABLE *table-old-name* RENAME TABLE *table-new-name*\n"})}),"\n",(0,r.jsx)(t.p,{children:"This may result in errors when running the SQL-script file for the specific ODBC DBMS because the rename syntax is not correct. If this is the case, you must change this syntax into the ODBC DBMS-specific syntax. To avoid problems with non-executable SQL script files for ODBC databases, always try to generate application tables by connecting directly to the ODBC DBMS via an ODBC driver (preferably one with ODBC-API level-1 conformance)."}),"\n",(0,r.jsx)(t.p,{children:"Universal date_to_char and char_to_date functions are available for ODBC. The syntax is:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-sql",children:"SELECT date_to_char( *expression, format* ) FROM table\nSELECT char_to_date( expression, format ) FROM table\n"})}),"\n",(0,r.jsx)(t.p,{children:"\xa0"})]})}function x(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);