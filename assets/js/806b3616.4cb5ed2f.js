"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[33069],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var s=n(96540);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}},53899:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Task_flow/Jobs/Job_error_handling_Commit_Type_and_Abort_Mode","title":"Job error handling, Commit Type, and Abort Mode","description":"Error handling in jobs","source":"@site/docs/Task_flow/Jobs/Job_error_handling_Commit_Type_and_Abort_Mode.md","sourceDirName":"Task_flow/Jobs","slug":"/Task_flow/Jobs/Job_error_handling_Commit_Type_and_Abort_Mode","permalink":"/udocs/Task_flow/Jobs/Job_error_handling_Commit_Type_and_Abort_Mode","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Job_error_handling_Commit_Type_and_Abort_Mode"},"sidebar":"sidebar","previous":{"title":"Job logging","permalink":"/udocs/Task_flow/Jobs/Job_logging"},"next":{"title":"Task-Level Commit vs. Record-Level Commit","permalink":"/udocs/Task_flow/Jobs/TaskLevel_Commit_vs_RecordLevel_Commit"}}');var r=n(74848),o=n(28453);const i={id:"Job_error_handling_Commit_Type_and_Abort_Mode"},a="Job error handling, Commit Type, and Abort Mode",l={},d=[{value:"Error handling in jobs",id:"error-handling-in-jobs",level:2},{value:"Some typical scenarios",id:"some-typical-scenarios",level:3},{value:"Commit Type settings",id:"commit-type-settings",level:2},{value:"Abort Mode settings",id:"abort-mode-settings",level:2},{value:"Fatal and non-fatal errors",id:"fatal-and-non-fatal-errors",level:2},{value:"Reading success status from a log file",id:"reading-success-status-from-a-log-file",level:2},{value:"Catching success status with -returnstatus",id:"catching-success-status-with--returnstatus",level:2}];function c(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"job-error-handling-commit-type-and-abort-mode",children:"Job error handling, Commit Type, and Abort Mode"})}),"\n",(0,r.jsx)(t.h2,{id:"error-handling-in-jobs",children:"Error handling in jobs"}),"\n",(0,r.jsxs)(t.p,{children:["Jobs run against a Rules Engine. As such, they participate in default Rules Engine error handling. In particular, if a restrictive constraint is violated, the Rules Engine interrupts processing flow. To continue, the user must either manage to ",(0,r.jsx)(t.strong,{children:"undo"})," the manipulation that caused the violation, or else she must ",(0,r.jsx)(t.strong,{children:"rollback"}),". In the case of undo, remaining manipulations in the transaction can still be committed. In the case of rollback, all the manipulations in the current transaction are lost."]}),"\n",(0,r.jsx)(t.p,{children:"If a constraint is violated during job execution, the user usually does not interact directly with individual records. Often, there are no opportunities for undo, but much depends on context: the interface through which the job call is offered, the overall purpose and the design of the job."}),"\n",(0,r.jsxs)(t.p,{children:["But jobs offer a special form of control, because they are made up of ",(0,r.jsx)(t.strong,{children:"tasks."})," By setting****Commit Type properties, you can determine whether a job commits after each record, or after each task, or only once at the end of the job. By Setting Abort Mode, you can determine what happens if an error is raised during job execution."]}),"\n",(0,r.jsx)(t.p,{children:"Commit Type and Abort Mode are discussed in more detail later in this article."}),"\n",(0,r.jsx)(t.h3,{id:"some-typical-scenarios",children:"Some typical scenarios"}),"\n",(0,r.jsx)(t.p,{children:"To give you a flavour, here are some typical scenarios of organising error handling in jobs. The first is the USoft default."}),"\n",(0,r.jsxs)(t.p,{children:["|",(0,r.jsx)(t.strong,{children:"Scenario"}),"|",(0,r.jsx)(t.strong,{children:"Error handling"}),"|",(0,r.jsx)(t.strong,{children:"Commit Type"}),"|**Abort Mode"]}),"\n",(0,r.jsx)(t.p,{children:"(Task level)"}),"\n",(0,r.jsxs)(t.p,{children:["**|\n|--------|--------|--------|--------|\n|Default, general use|",(0,r.jsx)("p",{children:"Commit after each task in the job"}),(0,r.jsx)("p",{children:"Stop when error occurs"}),(0,r.jsx)("p",{children:"Rollback the task that raised the error"}),"|",(0,r.jsx)("p",{children:"Job level: Task"}),(0,r.jsx)("p",{children:"Task level: Task"}),"|Abort Job on Error|\n|",(0,r.jsx)("p",{children:"Large, scheduled batches"}),(0,r.jsx)("p",{children:"Nightly consolidation"}),"|",(0,r.jsx)("p",{children:"If error occurs, write to log"}),(0,r.jsx)("p",{children:"Do not abort: continue with next"}),"|",(0,r.jsx)("p",{children:"Job level: Task"}),(0,r.jsx)("p",{children:"Task level: Record"}),"|None    |\n|Short job embedded in an interactive GUI|If no error, end without committing|",(0,r.jsx)("p",{children:"Job level: None"}),(0,r.jsx)("p",{children:"Task level: None"}),"|Abort Job on Error|\n|Job is a functional unit of tightly related SQL manipulations|All-or-nothing: everything succeeds or everything fails|",(0,r.jsx)("p",{children:"Job level: Job"}),(0,r.jsx)("p",{children:"Task level: None"}),"|Abort Job on Error|"]}),"\n",(0,r.jsx)(t.h2,{id:"commit-type-settings",children:"Commit Type settings"}),"\n",(0,r.jsxs)(t.p,{children:["Commit Type is a setting at ",(0,r.jsx)(t.strong,{children:"Job"})," level and at ",(0,r.jsx)(t.strong,{children:"Task"})," level."]}),"\n",(0,r.jsxs)(t.p,{children:["At ",(0,r.jsx)(t.strong,{children:"Job"})," level, Commit Type has one of the following settings. The default is Task."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:(0,r.jsx)(t.strong,{children:"Setting"})}),(0,r.jsx)(t.th,{children:(0,r.jsx)(t.strong,{children:"Means"})})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Task"}),(0,r.jsx)(t.td,{children:"The commit behavior depends on the Commit Type setting for each individual task."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Job"}),(0,r.jsx)(t.td,{children:"Only a single commit is performed. This happens at the end of the job. If the job aborts, it is rolled back."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"None"}),(0,r.jsx)(t.td,{children:"No commit is performed."})]})]})]}),"\n",(0,r.jsx)(t.p,{children:"The Commit Type setting 'Task' is usually appropriate for jobs."}),"\n",(0,r.jsx)(t.p,{children:'If you choose None, all the tasks in the job will automatically get Commit Type = None. One use case is a short job that is embedded in an interactive GUI. The user can wait for the job to finish and is present to decide to commit or rollback after the job. Another use case is a job incorporated in a larger structure of embedding jobs that do commit. With Commit Type = None at Job level, if the job was called using runbatch.exe, all manipulations are rolled back at the end of the job. If the job was called from within an application using the ActionStartJob() method or "INVOKE BatchRunner", the transaction stays open. A subsequent commit may or may not follow.'}),"\n",(0,r.jsx)(t.p,{children:"If you want a single commit at the end of the job, set Commit Type = Job at job level. Do not attempt to achieve this effect by choosing 'None' at task level for all but the last task, with the idea that you only want the final task to commit. Using 'None' at task level does not cause the job to be properly rolled back if it aborts."}),"\n",(0,r.jsxs)(t.p,{children:["At ",(0,r.jsx)(t.strong,{children:"Task"})," level, Commit Type has one of the following settings. The default is Task."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:(0,r.jsx)(t.strong,{children:"Setting"})}),(0,r.jsx)(t.th,{children:(0,r.jsx)(t.strong,{children:"Means"})})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Task"}),(0,r.jsx)(t.td,{children:"The transaction is committed once at the end of this Task."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Record"}),(0,r.jsx)(t.td,{children:"The transaction is committed after each individual processed record. This option is only available for Import Tasks and SQL Tasks."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"None"}),(0,r.jsx)(t.td,{children:"No commit is performed."})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"abort-mode-settings",children:"Abort Mode settings"}),"\n",(0,r.jsxs)(t.p,{children:["At ",(0,r.jsx)(t.strong,{children:"Task"})," level, the Abort Mode setting determines what happens if an error occurs during the task. The default is Abort Job on Error."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:(0,r.jsx)(t.strong,{children:"Setting"})}),(0,r.jsx)(t.th,{children:(0,r.jsx)(t.strong,{children:"Means"})})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Abort Job on Error"}),(0,r.jsx)(t.td,{children:"The error is reported. The current task is aborted. Subsequent tasks are not started. If Commit Type = Job at job level, the entire job is rolled back."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Abort Task on Error"}),(0,r.jsx)(t.td,{children:"The error is reported. The current task is aborted. The job continues with subsequent tasks (if any)."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"None"}),(0,r.jsx)(t.td,{children:"The error is reported, then the task continues."})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"fatal-and-non-fatal-errors",children:"Fatal and non-fatal errors"}),"\n",(0,r.jsxs)(t.p,{children:["Error handling as discussed so far in this article applies only to ",(0,r.jsx)(t.em,{children:"non-fatal errors."})," For non-fatal errors, error handling depends on Abort On Error settings."]}),"\n",(0,r.jsxs)(t.p,{children:["There are also ",(0,r.jsx)(t.em,{children:"fatal errors."})," If a fatal error occurs, the job is always aborted."]}),"\n",(0,r.jsx)(t.p,{children:"Fatal errors are related to the batch mechanism itself. As an example, consider Import Tasks. They work like this: one row is read from the external file and inserted into the import task set, then all job statements are executed, then the row is deleted from the import task set, and then the process starts over for the next row in the external file."}),"\n",(0,r.jsx)(t.p,{children:"In this process, a number of batch-specific errors could occur:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Cannot open or close the import file."}),"\n",(0,r.jsx)(t.li,{children:"The import task set table cannot be found in the repository."}),"\n",(0,r.jsx)(t.li,{children:"Cannot delete from the import task set."}),"\n",(0,r.jsx)(t.li,{children:"Cannot close .suc, .err, .mes, .tim files."}),"\n",(0,r.jsx)(t.li,{children:"Cannot write to .mes, .tim, .suc, .err, files."}),"\n",(0,r.jsx)(t.li,{children:"The preparation of statements is unsuccessful, for example: input variables cannot be replaced, components cannot be initialized."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"reading-success-status-from-a-log-file",children:"Reading success status from a log file"}),"\n",(0,r.jsx)(t.p,{children:"if you use a log file, the log file report will either end with 'Batch finished normally', or 'Batch stopped with errors'."}),"\n",(0,r.jsx)(t.p,{children:"This last message applies both to fatal errors (fatal error occurred so job was broken off) and to non-fatal errors (non-fatal error occurred and Abort Mode setting caused the execution to abort)."}),"\n",(0,r.jsx)(t.h2,{id:"catching-success-status-with--returnstatus",children:"Catching success status with -returnstatus"}),"\n",(0,r.jsxs)(t.p,{children:["You can catch the success status of a job execution by setting the ",(0,r.jsx)(t.strong,{children:"-returnstatus"})," parameter of the Batchrunner call. This way you catch both fatal and non-fatal errors."]}),"\n",(0,r.jsxs)(t.p,{children:["If an error occurs and you have set ",(0,r.jsx)(t.strong,{children:"-returnstatus"}),", the return value of the call is:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:"<Result>Error</Result>\n"})}),"\n",(0,r.jsx)(t.p,{children:"You can use this if you want to act on the success status of a job execution. For example, you may want to start a following job if the previous job was successful, but do something else if that previous job failed."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Example"})}),"\n",(0,r.jsx)(t.p,{children:"You can use this statement in a decision SQL. Specify in the Yes Action what must happen if the execution of job J1 was successful. Specify in the No Action what must happen if it failed:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-sql",children:"SELECT   'Success'\nWHERE    '<Result>Error</Result>' != \n         BatchRunner.RunJob(\n           'J1' as jobname\n         , 'true' \"-quiet\"\n         , 'true' \"-returnstatus\"\n         )\n\n"})}),"\n",(0,r.jsx)(t.p,{children:"\xa0"})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);