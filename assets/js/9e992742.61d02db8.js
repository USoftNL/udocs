"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[9860],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(96540);const l={},i=s.createContext(l);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},79314:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>x,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Repositories/Blend_functions/variableSet","title":"variable:Set","description":"This article is about the variable:Set Blend function.","source":"@site/docs/Repositories/Blend_functions/variableSet.md","sourceDirName":"Repositories/Blend_functions","slug":"/Repositories/Blend_functions/variableSet","permalink":"/udocs/Repositories/Blend_functions/variableSet","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"variableSet"},"sidebar":"sidebar","previous":{"title":"variable:IsDefined","permalink":"/udocs/Repositories/Blend_functions/variableIsDefined"},"next":{"title":"variable:TypeOf","permalink":"/udocs/Repositories/Blend_functions/variableTypeOf"}}');var l=t(74848),i=t(28453);const a={id:"variableSet"},r="variable",o={},c=[{value:"<strong>variable</strong>",id:"variable-1",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsxs)(n.h1,{id:"variable",children:["variable",":Set"]})}),"\n",(0,l.jsx)(n.admonition,{type:"note",children:(0,l.jsxs)(n.p,{children:["This article is about the ",(0,l.jsxs)(n.strong,{children:["variable",":Set"]}),(0,l.jsx)(n.a,{href:"/Repositories/Blend_functions",children:" Blend function"}),"."]})}),"\n",(0,l.jsx)(n.h2,{id:"variable-1",children:(0,l.jsxs)(n.strong,{children:["variable",":Set"]})}),"\n",(0,l.jsx)(n.p,{children:"Evaluates an expression, initialises a named variable if it does not exist, then assigns the result of the evaluation to the variable."}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.em,{children:"Syntax"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.em,{children:"Namespace declaration"})}),"\n",(0,l.jsx)(n.p,{children:"You need to declare this namespace only if you call the function directly from the USCSXSL component but outside Blend. In a Blend context (ublendit.exe, uscsxsl.blend()) the namespace is already declared in the Blend transformation, which is in xsl\\Util\\Batch.1.0.xsl in your USoft installation folder."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:'xmlns:variable="USoft:Variable"\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.em,{children:"Function call"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"variable:Set( *name*, *expression* )\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Both ",(0,l.jsx)(n.em,{children:"name"})," and ",(0,l.jsx)(n.em,{children:"expression"})," are required. ",(0,l.jsx)(n.em,{children:"Expression"})," may be a constant, a function (Example 1), or an XPath expression (Example 2)."]}),"\n",(0,l.jsxs)(n.p,{children:["A variable is created with name ",(0,l.jsx)(n.em,{children:"name"})," if such a variable does not exist. The result of evaluating expression is assigned to the variable, overwriting any existing value of the variable."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.em,{children:"Example 1"})}),"\n",(0,l.jsx)(n.p,{children:'This example creates the variable "envxml" and sets it to the contents of the "env.xml" file.'}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:"<pc:evaluate select=\"variable:Set('envxml', files:XmlFile('env.xml'))\"/>\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.em,{children:"Example 2"})}),"\n",(0,l.jsxs)(n.p,{children:['This example creates the variable "mytableregexp" and sets it to the text contents of the <result> element in the outcome of an XSLT transformation executed by a <pc',":apply","> child node instruction. This outcome is a regular expression representing a list of tables, of the format"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"(TABLE1|TABLE2|...)\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-sql",children:'select uscsxsl.blend(\n   \'<example xmlns:pc="Processing.Command" pc:hideme="true">\n   <pc:assign sql = "SELECT TO_CLOB(( INVOKE XML.EXPORT WITH SELECT * FROM T_TABLE ))" />\n    <pc:assign xml = "{sql:SqlStmnt(\'\'\'\', $sql)}" />\n    <pc:evaluate select="variable:Set(\'\'mytableregexp\'\', ./result/text())">\n\n      <pc:apply   xml="{$xml}" xsl="{xsl:stylesheet}" >\n        <xsl:stylesheet  version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">\n\n         <xsl:output method="xml" encoding="UTF-8"/>\n\n          <xsl:template match="/">\n            <result>\n              <xsl:text>(</xsl:text>\n              <xsl:for-each select ="*/T_TABLE">\n                <xsl:value-of select="@TABLE_NAME"/>\n                <xsl:if test="position()<last()">\n                  <xsl:text>|</xsl:text>\n                </xsl:if>\n              </xsl:for-each>\n              <xsl:text>)</xsl:text>\n            </result>\n          </xsl:template>\n\n        </xsl:stylesheet>\n      </pc:apply>\n\n    </pc:evaluate>\n    <pc:comment-of><pc:copy-of select="$mytableregexp"/></pc:comment-of>  \n  </example>\'\n)\n'})}),"\n",(0,l.jsx)(n.p,{children:"\xa0"})]})}function x(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}}}]);