"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[65014],{6477:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"Modeller_and_Rules_Engine/SQL_functions/RDBMS_functions","title":"RDBMS functions","description":"In USoft SQL, in the place of a USoft-supported SQL function, you can call a user-defined RDBMS function by using the RDBMS prefix.","source":"@site/docs/Modeller_and_Rules_Engine/SQL_functions/RDBMS_functions.md","sourceDirName":"Modeller_and_Rules_Engine/SQL_functions","slug":"/Modeller_and_Rules_Engine/SQL_functions/RDBMS_functions","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_functions/RDBMS_functions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"RDBMS_functions"},"sidebar":"sidebar","previous":{"title":"USERGROUP","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_functions/USERGROUP"},"next":{"title":"SQL for ODBC","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_for_ODBC"}}');var i=t(74848),r=t(28453);const o={id:"RDBMS_functions"},a="RDBMS functions",c={},l=[{value:"The LITERAL keyword",id:"the-literal-keyword",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"rdbms-functions",children:"RDBMS functions"})}),"\n",(0,i.jsx)(n.p,{children:"In USoft SQL, in the place of a USoft-supported SQL function, you can call a user-defined RDBMS function by using the RDBMS prefix."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Syntax"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"RDBMS. { $$RDBMSUSER$$. | $$RDBMSOWNER$$. | } *rdbms-function*( *argument*, ... )\n\n*argument*  ::=  { *expression* | LITERAL *literal-string* }\n"})}),"\n",(0,i.jsx)(n.p,{children:"The spelling is case-insensitive, except for literal-string arguments where case matters to the rdbms-function."}),"\n",(0,i.jsx)(n.p,{children:'By either specifying "$$RDBMSUSER$$.", or by omitting "$$RDBMSUSER$$." and "$$RDBMSOWNER$$." altogether, you call the RDBMS function with name rdbms-function as it is accessible at RDBMS level by the database user with the same name as the USoft application user currently logged on.'}),"\n",(0,i.jsx)(n.p,{children:"By specifying $$RDBMSOWNER$$., you call the RDBMS function with name rdbms-function that is owned by the database user with the same name as the USoft application user currently logged on."}),"\n",(0,i.jsx)(n.p,{children:"The required rdbms-function must be the name of a function defined in the RDBMS."}),"\n",(0,i.jsx)(n.p,{children:"Depending on the signature of the function, one or more arguments may or must be specified. If the argument value is passed as a literal string you can prefix it by the LITERAL keyword; see the section below."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"UPDATE   schedtour s\nSET     s.weighting =\n(\n    SELECT    RDBMS.LTP( s.price, p.category )\n    FROM      person p\n    WHERE     p.person_id = s.made_by\n)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"the-literal-keyword",children:"The LITERAL keyword"}),"\n",(0,i.jsx)(n.p,{children:"If an argument is a literal string preceded by the LITERAL keyword, USoft will pass the contents of the string through to the RDBMS. The following statement:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"rdbms.EXTEND(SYSDATE, LITERAL 'hour to minute')\n"})}),"\n",(0,i.jsx)(n.p,{children:"is represented to the RDBMS as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"EXTEND(SYSDATE, hour to minute)\n"})}),"\n",(0,i.jsx)(n.p,{children:"LITERAL can only be used in the arguments of a user-defined RDBMS function, not in other types of function or in standard SQL expressions."}),"\n",(0,i.jsx)(n.p,{children:"The string following the LITERAL keyword is not analysed by the rules engine. So, if you use column names in the string, the rules engine will not be aware of that. In constraint SQL, a column name preceded by LITERAL will not trigger evaluation of the constraint when a value in the column is manipulated."}),"\n",(0,i.jsx)(n.p,{children:"If you want to specify a string within the LITERAL syntax you can use sequences of 2 single quotes as escape characters:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"LITERAL 'keyword ''my string'''\n"})}),"\n",(0,i.jsx)(n.p,{children:"will be passed to the RDBMS as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sql",children:"keyword 'my string'\n"})}),"\n",(0,i.jsx)(n.p,{children:"\xa0"})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(96540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);