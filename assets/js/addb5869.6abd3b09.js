"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[77578],{28453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>i});var r=s(96540);const o={},n=r.createContext(o);function a(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(n.Provider,{value:t},e.children)}},49948:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Task_flow/Jobs/Import_Task_Set_Virtuals_in_RecordbyRecord_Computations","title":"Import Task Set Virtuals in Record-by-Record Computations","description":"Suppose a table has a number of columns with computed values, and records in it are processed by an import task. (Computed values can theoretically be extracted from other tables, but because this takes time and the computed values are often re-used, they are stored in a separate field for performance reasons.)","source":"@site/docs/Task_flow/Jobs/Import_Task_Set_Virtuals_in_RecordbyRecord_Computations.md","sourceDirName":"Task_flow/Jobs","slug":"/Task_flow/Jobs/Import_Task_Set_Virtuals_in_RecordbyRecord_Computations","permalink":"/udocs/Task_flow/Jobs/Import_Task_Set_Virtuals_in_RecordbyRecord_Computations","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Import_Task_Set_Virtuals_in_RecordbyRecord_Computations"},"sidebar":"sidebar","previous":{"title":"Import Task Set Virtuals Managing Decision Trees","permalink":"/udocs/Task_flow/Jobs/Import_Task_Set_Virtuals_Managing_Decision_Trees"},"next":{"title":"Job logging","permalink":"/udocs/Task_flow/Jobs/Job_logging"}}');var o=s(74848),n=s(28453);const a={id:"Import_Task_Set_Virtuals_in_RecordbyRecord_Computations"},i="Import Task Set Virtuals in Record-by-Record Computations",c={},l=[];function d(e){const t={code:"code",h1:"h1",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"import-task-set-virtuals-in-record-by-record-computations",children:"Import Task Set Virtuals in Record-by-Record Computations"})}),"\n",(0,o.jsx)(t.p,{children:"Suppose a table has a number of columns with computed values, and records in it are processed by an import task. (Computed values can theoretically be extracted from other tables, but because this takes time and the computed values are often re-used, they are stored in a separate field for performance reasons.)"}),"\n",(0,o.jsx)(t.p,{children:"You can use import task set virtuals to hold computed values for the currently imported record."}),"\n",(0,o.jsx)(t.p,{children:"The standard in USoft technology is to compute values using productive constraints. In batch jobs, however, you can also use virtuals to compute the eventual values."}),"\n",(0,o.jsx)(t.p,{children:"Another aspect of these computed values is that in many instances, these values are always produced by batch processing and never during online processing. If you implement the computations in constraints, these are checked unnecessarily during online processing."}),"\n",(0,o.jsx)(t.p,{children:"You can get record-by-record commit and default error reports even if you want to compute values in EXISTING data. Export the data, then import them (export-for-import strategy). During import, compute the values."}),"\n",(0,o.jsx)(t.p,{children:"To use import task set virtuals for record-by-record computations:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Define an external set describing the structure of the external file. This external set does not include the computed values."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Define the import task based on the external set. Use the external set as driving import task set. For this set, define as many import task set virtuals as you have computed columns."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Define import SQL statements that compute the import task set virtuals on the basis of database values and values in the current import record (and possibly values in non-driving import sets)."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"These import SQL statements typically have the form:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sql",children:"UPDATE \xa0 \xa0driving-import-task-set\nSET \xa0 \xa0 \xa0 import-task-set-virtual =\n(\n \xa0 \xa0SELECT \xa0 \xa0...\n \xa0 \xa0FROM \xa0 \xa0 database-table [, database-table ...]\n \xa0 \xa0WHERE \xa0 \xa0(join with current import record)\n)\n\n"})}),"\n",(0,o.jsxs)(t.ol,{start:"4",children:["\n",(0,o.jsx)(t.li,{children:"Define an import SQL statement transferring the current import record, including computed values, to the database table. This import SQL statement typically has the form:"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sql",children:"INSERT INTO database-table\nSELECT \xa0 \xa0 \xa0all-columns\nFROM \xa0 \xa0 \xa0 \xa0driving-import-task-set\n\n"})}),"\n",(0,o.jsxs)(t.ol,{start:"5",children:["\n",(0,o.jsx)(t.li,{children:"At job level, specify RECORD level commit for this import task."}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);