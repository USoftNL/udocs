"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[71101],{27962:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Modeller_and_Rules_Engine/SQL_syntax/Column_expressions","title":"Column expressions","description":"This article is about Column expressions as part of the SQL syntax that USoft supports.","source":"@site/docs/Modeller_and_Rules_Engine/SQL_syntax/Column_expressions.md","sourceDirName":"Modeller_and_Rules_Engine/SQL_syntax","slug":"/Modeller_and_Rules_Engine/SQL_syntax/Column_expressions","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_syntax/Column_expressions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Column_expressions"},"sidebar":"sidebar","previous":{"title":"Literals","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_syntax/Literals"},"next":{"title":"Pseudo-columns","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_syntax/Pseudocolumns"}}');var a=s(74848),o=s(28453);const l={id:"Column_expressions"},i="Column expressions",r={},c=[{value:"<strong>Column expressions</strong>",id:"column-expressions-1",level:2},{value:"Column names",id:"column-names",level:2},{value:"Column wildcards",id:"column-wildcards",level:2},{value:"Column aliases",id:"column-aliases",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"column-expressions",children:"Column expressions"})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsxs)(n.p,{children:["This article is about ",(0,a.jsx)(n.strong,{children:"Column expressions"})," as part of the ",(0,a.jsx)(n.a,{href:"/Modeller_and_Rules_Engine/SQL_syntax",children:"SQL syntax"})," that USoft supports."]})}),"\n",(0,a.jsx)(n.h2,{id:"column-expressions-1",children:(0,a.jsx)(n.strong,{children:"Column expressions"})}),"\n",(0,a.jsx)(n.p,{children:"In SQL, column expressions are used :"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"In the select-list of a SELECT statement."}),"\n",(0,a.jsx)(n.li,{children:"In the VALUES clause of an INSERT statement."}),"\n",(0,a.jsx)(n.li,{children:"To the right of the = symbol in a SET clause of an UPDATE statement."}),"\n",(0,a.jsx)(n.li,{children:"To the left and to the right of a comparison operator in a condition."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Syntax"})}),"\n",(0,a.jsx)(n.p,{children:"A column expression is a column name, or a literal value, or a composition of columns names and literals connected by function calls or computations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"*column-expression* ::=  {\n                         {  *column*         | \n*literal*        |  \n*pseudo-column*  |  \n*column-expr*    |\n*function-call*  |\n*computation*\n                         }  [*column-alias*]   |   \n*column-wildcard*\n                      }\n\n*function-call*     ::=  *function*( *column-expr*, *column-expr*... )\n\n*computation*       ::=  *column-expr  math-operator  column-expr*\n\n*column*            ::=  {*table-name*|*table-alias*}.*column-name*\n\n*column-wildcard*   ::=  {*table-name*|*table-alias*}.*\n"})}),"\n",(0,a.jsx)(n.p,{children:'In its simple form, a column expression is a column name, a literal, or a pseudo-column. A special form is the asterisk (*) as column wildcard. This is a shorthand for "all the columns of the table".'}),"\n",(0,a.jsx)(n.p,{children:"A column expression optionally ends with a column alias."}),"\n",(0,a.jsx)(n.p,{children:"There are two ways to produce composite column expressions: function calls and computations. These productions may be nested to any level deep, and may also be mixed."}),"\n",(0,a.jsx)(n.p,{children:"A function call consists of the name of an inline function immediately followed by parentheses surrounding zero or more comma-separated column expressions. The parenthesised expressions are passed as input parameters to the function. An inline function (or scalar function) is any supported SQL function other than a group function. Here is an example with nested function calls. This example returns the first word of each title:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SUBSTR( title, 1, INSTR( title, ' ' ) )\n"})}),"\n",(0,a.jsx)(n.p,{children:"In a computation, a mathematical operator is applied to 2 input values. The input values are written as 2 column expressions to the left and to the right of the operator. This example returns the percentage that each sample (from a table s) is of a total population (from a related\xa0 table p):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"( s.sample / p.total) * 100\n"})}),"\n",(0,a.jsx)(n.h2,{id:"column-names",children:"Column names"}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.em,{children:"column name"})," may appear independently. It may be prefixed with the name or alias of the table instance that the column belongs to. A dot separates the prefix from the column name. The prefix is optional, but it is necessary for disambiguisation if the column name occurs in more than 1 table instance referenced by the SQL statement."]}),"\n",(0,a.jsx)(n.p,{children:"A column name must refer to an existing column in the data model. It must identify that column uniquely:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"If the SQL statement refers to different tables that each have a column with the column name, prefixes are necessary to identify the column."}),"\n",(0,a.jsx)(n.li,{children:"If the SQL statement refers to multiple table instances of the column's table, you must give each table instance a unique table alias and prefix the column names with the aliases."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The prefixes are also legal if they are not essential for unique identification of the column. USoft recommends you ALWAYS use table aliases in column expressions, except perhaps in single-table SQL statements."}),"\n",(0,a.jsx)(n.h2,{id:"column-wildcards",children:"Column wildcards"}),"\n",(0,a.jsxs)(n.p,{children:["The asterisk (*) as a ",(0,a.jsx)(n.em,{children:"column wildcard"})," is a shorthand for enumerating all the column names in the table. When the statement executes, the processor substitutes the column names. The equivalent is a comma-separated list of all the column names of all the table instances in the statement."]}),"\n",(0,a.jsx)(n.p,{children:"This shorthand is practical in an ad-hoc query if you do not want to spend time lookup up column names or if you want to prevent typing effort, but has drawbacks in other contexts. A notable drawback is that the same SQL statement returns different results if columns are added, renamed or dropped later."}),"\n",(0,a.jsx)(n.p,{children:"Prefixing is possible in the same way as with regular column names. In statements with multiple table instances, this restricts the scope of the wildcard to just the columns in the prefixed table instance."}),"\n",(0,a.jsx)(n.p,{children:"For logical reasons you cannot apply functions and calculations to the column wildcard, with the exception of the COUNT group function."}),"\n",(0,a.jsx)(n.h2,{id:"column-aliases",children:"Column aliases"}),"\n",(0,a.jsx)(n.p,{children:"You can optionally provide a column alias as the last element of a column expression, separated by whitespace from the remainder of the column expression. A column alias must not contain whitespace. A column alias may optionally be surrounded by double quotes."}),"\n",(0,a.jsx)(n.p,{children:"The only real use case in USoft for column aliases are Logical View statements. In a Logical View, you can only have a compound output expression if you label it with a column alias. When the Logical View is checked, the column alias becomes a column name. A Logical View with the following SQL will have a column named FULL_NAME:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT     person_id\n,          UPPER( SUBSTRING( first_name, 1, 1 ) ) ||\n           LOWER( SUBSTRING( first_name, 2 ) || ' ' ||\n           UPPER( initials ) || ' ' ||\n           UPPER( family_name ) \"Full_name\"\nFROM       person\n"})}),"\n",(0,a.jsx)(n.p,{children:"Do not confuse with table aliases."}),"\n",(0,a.jsx)(n.p,{children:"\xa0"})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>i});var t=s(96540);const a={},o=t.createContext(a);function l(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);