"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[7965],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(96540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}},74296:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"Modeller_and_Rules_Engine/Constraints/Recursive_constraints","title":"Recursive constraints","description":"Recursive constraints are productive constraints that cause themselves to be evaluated again, thereby creating a \\"loop\\". Recursive constraints are sometimes, but not always, an indication of poor conceptual definition.","source":"@site/docs/Modeller_and_Rules_Engine/Constraints/Recursive_constraints.md","sourceDirName":"Modeller_and_Rules_Engine/Constraints","slug":"/Modeller_and_Rules_Engine/Constraints/Recursive_constraints","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints/Recursive_constraints","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Recursive_constraints"},"sidebar":"sidebar","previous":{"title":"Deferred table constraints","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints/Deferred_table_constraints"},"next":{"title":"Constraint comments","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints/Constraint_comments"}}');var r=t(74848),i=t(28453);const o={id:"Recursive_constraints"},a="Recursive constraints",c={},l=[{value:"Example",id:"example",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"recursive-constraints",children:"Recursive constraints"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Recursive constraints"}),' are productive constraints that cause themselves to be evaluated again, thereby creating a "loop". Recursive constraints are sometimes, but not always, an indication of poor conceptual definition.']}),"\n",(0,r.jsx)(n.p,{children:"For example, the following constraint will call itself as many times as the Max Constraint Depth deployment configuration setting in the Authorizer (default 50) allows and will then result in an error message:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"UPDATE \xa0 \xa0TableA\nSET \xa0 \xa0 \xa0 ColumnA = ColumnA + 1\nWHERE \xa0 \xa0 ColumnB = 'ABC'\n"})}),"\n",(0,r.jsx)(n.p,{children:'A successful recursive constraint must therefore contain some WHERE clause acting as a "stop condition". This stop condition restricts further recursion of the constraint:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"UPDATE \xa0 \xa0TableA\nSET \xa0 \xa0 \xa0 ColumnA = ColumnA + 1\nWHERE \xa0 \xa0 ColumnB = 'ABC'\nAND \xa0 \xa0 \xa0 Column A <= 80\n"})}),"\n",(0,r.jsx)(n.p,{children:"Of course, if this rule has no further consequences it is much better to write:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"UPDATE \xa0 \xa0TableA\nSET \xa0 \xa0 \xa0 ColumnA = 80\nWHERE \xa0 \xa0 ColumnB = 'ABC'\n"})}),"\n",(0,r.jsx)(n.p,{children:"Constraint recursivity not only occurs when a single constraint causes the evaluation of itself, but also when two or more constraints cause the evaluation of each other."}),"\n",(0,r.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.p,{children:"One way to control a recursive constraint is to use transition properties."}),"\n",(0,r.jsx)(n.p,{children:"In the Travel Agency, suppose that whenever a tour is scheduled, a record should be inserted in the DAY table for each of the dates within the scheduled tour."}),"\n",(0,r.jsx)(n.p,{children:"The DAY table is a child table of the scheduled tour table and allows you to record program details of each day (agenda, activities, etc.) for the scheduled tour."}),"\n",(0,r.jsx)(n.p,{children:"When the user inserts a new scheduled tour record, a non-recursive constraint inserts the first day record for that scheduled tour in the DAY table:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"INSERT INTO day(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0schedtour_id\n, \xa0 \xa0 \xa0 \xa0 \xa0 day\n)\nSELECT \xa0 \xa0 \xa0s.schedtour_id\n, \xa0 \xa0 \xa0 \xa0 \xa0 s.start_date\nFROM \xa0 \xa0 \xa0 \xa0schedtour s\n\nTransition Table: \xa0 \xa0SCHEDTOUR\nFire On Insert: \xa0 \xa0 \xa0Always\nFire On Delete: \xa0 \xa0 \xa0Never\nFire on Update: \xa0 \xa0 \xa0Never\n"})}),"\n",(0,r.jsx)(n.p,{children:"This is a productive constraint resulting in a manipulation (another INSERT) on the DAY table. The constraint is made transitional and performs a correction only once on an insert in the SCHEDTOUR table."}),"\n",(0,r.jsx)(n.p,{children:"There is a second, recursive constraint on the DAY table, which inserts the next day within the same scheduled tour, and loops until the return date of the scheduled tour. The last line is the stop condition:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"INSERT INTO \xa0 day(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0schedtour_id\n, \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 day\n)\nSELECT \xa0 \xa0 \xa0 \xa0d1.schedtour_id\n, \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 d1.day + 1\nFROM \xa0 \xa0 \xa0 \xa0 \xa0schedtour s\n, \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 day d1\nWHERE \xa0 \xa0 \xa0 \xa0 s.schedtour_id = d1.schedtour_id\nAND \xa0 \xa0 \xa0 \xa0 \xa0 d1.day < s.return_date\n"})}),"\n",(0,r.jsx)(n.p,{children:"This second, recursive constraint is set in motion by the first, non-recursive constraint."}),"\n",(0,r.jsx)(n.p,{children:"Here is an example of a typical event:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The user INSERTs a new scheduled tour with start date: 1-MAY-2000, and return date: 4-MAY-2000."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The first, transitional constraint INSERTs a record (1-MAY-2000) in the DAY table."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Because of this manipulation, the recursive constraint is evaluated and INSERTs a second record (2-MAY-2000) in the DAY table."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Because of this manipulation, the recursive constraint is evaluated again and INSERTs a third record (3-MAY-2000) in the DAY table."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"This latest inserted day (3-MAY-2000) is still before the return date, so the recursive constraint is evaluated still one more time, and INSERTs a fourth record (4-MAY-2000) in the DAY table."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The stop condition now restricts further recursion of the constraint."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The advantage of this mechanism is that you can control recursivity by making it independent of unpredictable user actions. In the example, you can control the effect of the second constraint by making sure that only the first constraint can cause the evaluation of the second constraint. For instance, suppose user groups have SELECT and UPDATE but no foreground INSERT rights on the DAY table. Then the only way the system can create new DAY records is through the two constraints in the example."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);