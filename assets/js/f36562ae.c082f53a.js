"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[95419],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(96540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}},77805:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"Modeller_and_Rules_Engine/Constraints/Transitional_constraint_troubleshooting","title":"Transitional constraint troubleshooting","description":"OLD() value during constraint processing","source":"@site/docs/Modeller_and_Rules_Engine/Constraints/Transitional_constraint_troubleshooting.md","sourceDirName":"Modeller_and_Rules_Engine/Constraints","slug":"/Modeller_and_Rules_Engine/Constraints/Transitional_constraint_troubleshooting","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints/Transitional_constraint_troubleshooting","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Transitional_constraint_troubleshooting"},"sidebar":"sidebar","previous":{"title":"Transitional constraints","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints/Transitional_constraints"},"next":{"title":"Deferred table constraints","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints/Deferred_table_constraints"}}');var s=t(74848),i=t(28453);const o={id:"Transitional_constraint_troubleshooting"},a="Transitional constraint troubleshooting",l={},d=[{value:"OLD() value during constraint processing",id:"old-value-during-constraint-processing",level:3},{value:"Current row counting",id:"current-row-counting",level:3},{value:"Unwanted new-value substitution",id:"unwanted-new-value-substitution",level:3},{value:"",id:"",level:3}];function c(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"transitional-constraint-troubleshooting",children:"Transitional constraint troubleshooting"})}),"\n",(0,s.jsx)(n.h3,{id:"old-value-during-constraint-processing",children:"OLD() value during constraint processing"}),"\n",(0,s.jsx)(n.p,{children:"Each row event has its own OLD and NEW values for each of the columns in the record."}),"\n",(0,s.jsx)(n.p,{children:"When column values are changed by constraints, the NEW value is obviously changed but the OLD value remains the same until the record is stored. This is true even if several productive rules change NEW values within the record."}),"\n",(0,s.jsx)(n.p,{children:"You therefore need to consider whether a constraint is handled before or after the record is stored. In general, the following constraint types are evaluated before the record is stored, as part of the current row event:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Row Checks:"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Restrictive constraints that only involve values within the current row, like for example restrictive single-record constraints."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Update on Self constraints:"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Productive constraints that UPDATE values of the current row (other than subtype indicators), if the constraint is not Deferred."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Example 1"})}),"\n",(0,s.jsx)(n.p,{children:"Consider the following three constraints:"}),"\n",(0,s.jsx)(n.p,{children:"Constraint 1, non-transitional:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"UPDATE \xa0 table\nSET \xa0 \xa0 \xa0column = 2\nWHERE \xa0 \xa0column = 1\n"})}),"\n",(0,s.jsx)(n.p,{children:"Constraint 2, non-transitional:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"UPDATE \xa0 table\nSET \xa0 \xa0 \xa0column = 3\nWHERE \xa0 \xa0column = 2\n"})}),"\n",(0,s.jsx)(n.p,{children:"Constraint 3, transitional:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"UPDATE \xa0 table\nSET \xa0 \xa0 \xa0column = 10\nWHERE \xa0 \xa0OLD( column ) = 2\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The following table shows what happens if the user changes the column value from 0 to 1. Only Constraint 1 and Constraint 2 are evaluated. The result, the column value ",(0,s.jsx)(n.strong,{children:"3,"})," is stored. Constraint 3 will never be evaluated because the outcode of ",(0,s.jsx)(n.strong,{children:"OLD(column)"})," never evaluates to ",(0,s.jsx)(n.strong,{children:"2"})," at any stage in the process."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"**\xa0**"}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"column"})})}),(0,s.jsx)(n.th,{children:"**\xa0**"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"User change"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"Old Value"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"New Value"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Constraint 1"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"Old Value"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"New Value"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Constraint 2"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"Old Value"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"New Value"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Example 2"})}),"\n",(0,s.jsx)(n.p,{children:"Consider the following constraint:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"UPDATE \xa0 \xa0table\nSET \xa0 \xa0 \xa0 column = column + 1\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Transition Table: \xa0<table>\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire On Insert: \xa0 \xa0Always\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire On Delete: \xa0 \xa0Never\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire On Update: \xa0 \xa0Never\n"})}),"\n",(0,s.jsx)(n.p,{children:"Because this is a transitional constraint, the Rules Engine translates this constraint into:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"UPDATE \xa0 \xa0table\nSET \xa0 \xa0 \xa0 column = column + 1\nWHERE \xa0 \xa0 primary-key-column IS NOT NULL\nAND \xa0 \xa0 \xa0 OLD( primary-key-column ) IS NULL\n"})}),"\n",(0,s.jsx)(n.p,{children:"If the user inserts a record and enters column value 1, the OLD primary key column value is NULL. This causes evaluation of the constraint and changes the column value to 2."}),"\n",(0,s.jsx)(n.p,{children:"After the column value has changed to 2, the OLD column value is still NULL and the manipulation is still considered as an INSERT. Therefore the constraint is evaluated again, despite the Fire On Update setting."}),"\n",(0,s.jsx)(n.p,{children:"The constraint will be evaluated as many times as the Max Constraint Depth deployment configuration setting in the Authorizer (default 50) allows and will then result in an error message."}),"\n",(0,s.jsx)(n.p,{children:"To prevent this problem:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If you WANT to make the constraint recursive, add a stop condition like:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"WHERE <column> < 10\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If you want to set the column to a default value when the user inserts a record, simply define a default value."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"As soon as the record is stored, further productive rules lead to new row events with their own series of OLD values. Such row events can be in different tables, but also in the same table as the initial row event. They may even involve records that were also manipulated as part of the initial row event. In this case, the OLD column values for the cascading row event may be different from the OLD values for the initial row event."}),"\n",(0,s.jsx)(n.p,{children:"Changing the value of a subtype indicator leads to the creation of a new row event."}),"\n",(0,s.jsx)(n.h3,{id:"current-row-counting",children:"Current row counting"}),"\n",(0,s.jsx)(n.p,{children:"Transitional constraints are bound to the current record when they are handled:"}),"\n",(0,s.jsx)(n.p,{children:"In the constraint SQL statements of transitional constraints, for all occurrences of the transition table, only the current row event is considered."}),"\n",(0,s.jsx)(n.p,{children:"Do not make a constraint transitional if a group function such as COUNT() is used in the SQL statement of the constraint. In that case, only the current row event would be counted."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Example"})}),"\n",(0,s.jsx)(n.p,{children:"In the Travel Agency application, suppose you wanted to add an amount column to the TOUR table, in which is stored the current total number of scheduled tours for that tour. The correct amount must be calculated by a productive constraint whenever a scheduled tour is added or removed. The constraint reads:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"UPDATE \xa0 \xa0tour t\nSET \xa0 \xa0 \xa0 t.amount =\n(\n \xa0 \xa0 \xa0 \xa0 \xa0SELECT \xa0 \xa0COUNT (st.schedtour_id )\n \xa0 \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 \xa0schedtour st\n \xa0 \xa0 \xa0 \xa0 \xa0WHERE \xa0 \xa0 st.destination = t.destination\n \xa0 \xa0 \xa0 \xa0 \xa0AND \xa0 \xa0 \xa0 st.tour_type=t.tour_type\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Suppose this constraint is made transitional by setting transition properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Transition Table: \xa0SCHEDTOUR\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire on Insert: \xa0 \xa0Always\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire on Delete: \xa0 \xa0Always\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire on Update: \xa0 \xa0Never\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this case, the result would be the same as if the constraint read:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"UPDATE \xa0 \xa0tour t\nSET \xa0 \xa0 \xa0 t.amount =\n(\n \xa0 \xa0 \xa0 \xa0 \xa0SELECT \xa0 \xa0COUNT( st.schedtour_id )\n \xa0 \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 \xa0schedtour st\n \xa0 \xa0 \xa0 \xa0 \xa0WHERE \xa0 \xa0 st.destination = t.destination\n \xa0 \xa0 \xa0 \xa0 \xa0AND \xa0 \xa0 \xa0 st.tour_type = t.tour_type)\n \xa0 \xa0 \xa0 \xa0 \xa0AND \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0 \xa0( \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0OLD( st.schedtour_id ) IS NULL\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0OR \xa0 \xa0st.schedtour_id IS NULL\n \xa0 \xa0 \xa0 \xa0 \xa0)\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now, only the scheduled tour records within the current row event are counted, which will always lead to a value for amount of 0 or 1."}),"\n",(0,s.jsx)(n.p,{children:"To prevent this problem, simply do not make the constraint transitional."}),"\n",(0,s.jsx)(n.p,{children:"If, for whatever reason, you still want to write a transitional constraint, you may change the constraint into:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"UPDATE \xa0 \xa0tour t\nSET \xa0 \xa0 \xa0 t.amount =\n(\n \xa0 \xa0 \xa0 \xa0 \xa0SELECT \xa0 \xa0 \xa0COUNT( st.schedtour_id )\n \xa0 \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 \xa0 \xa0schedtour st\n \xa0 \xa0 \xa0 \xa0 \xa0WHERE \xa0 \xa0 \xa0 st.destination = t.destination\n \xa0 \xa0 \xa0 \xa0 \xa0AND \xa0 \xa0 \xa0 \xa0 st.tour_type = t.tour_type\n)\nWHERE EXISTS\n(\n \xa0 \xa0 \xa0 \xa0 \xa0SELECT \xa0 \xa0 'added or removed scheduled tour'\n \xa0 \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 \xa0 schedtour st2\n \xa0 \xa0 \xa0 \xa0 \xa0WHERE \xa0 \xa0 \xa0/* added scheduled tour */\n \xa0 \xa0 \xa0 \xa0 \xa0(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 st2.destination = t.destination\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0AND \xa0 \xa0st2.tour_type = t.tour_type\n \xa0 \xa0 \xa0 \xa0 \xa0)\n \xa0 \xa0 \xa0 \xa0 \xa0OR \xa0 \xa0 \xa0 \xa0 /* removed scheduled tour */\n \xa0 \xa0 \xa0 \xa0 \xa0(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 OLD( st2.destination ) = t.destination\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0AND \xa0 \xa0OLD(st2.tour_type) = t.tour_type\n \xa0 \xa0 \xa0 \xa0 \xa0)\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Set the transition properties to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Transition Table: SCHEDTOUR\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Alias: \xa0 \xa0 \xa0 \xa0 \xa0 \xa0st2\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire On Insert: \xa0 Always\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire On Delete: \xa0 Always\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire On Update: \xa0 Never\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"In the Alias value here,you only want the constraint to be evaluated if the SCHEDTOUR table with alias st2 is manipulated."})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"If you change the Fire On Update attribute to Used Columns, this constraint is also evaluated when the foreign key of a scheduled tour is changed from one tour to another."})}),"\n",(0,s.jsx)(n.h3,{id:"unwanted-new-value-substitution",children:"Unwanted new-value substitution"}),"\n",(0,s.jsx)(n.p,{children:"Within transitional constraints, all SQL occurrences of transition table columns are substituted by the current OLD and NEW column values of the current row event."}),"\n",(0,s.jsx)(n.p,{children:"This is important whenever there are multiple occurrences of the transition table in a constraint SQL statement."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Example"})}),"\n",(0,s.jsx)(n.p,{children:"Suppose you want to delete a parent record if the last child record is deleted. The constraint you have written reads:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"DELETE FROM \xa0 \xa0parent p\nWHERE NOT EXISTS\n(\n \xa0 \xa0 \xa0 SELECT \xa0 \xa0'child record'\n \xa0 \xa0 \xa0 FROM \xa0 \xa0 \xa0child c\n \xa0 \xa0 \xa0 WHERE \xa0 \xa0 c.foreignkey = p.primarykey\n)\nAND EXISTS\n(\n \xa0 \xa0 \xa0 SELECT \xa0 \xa0'old child record'\n \xa0 \xa0 \xa0 FROM \xa0 \xa0 \xa0child c\n \xa0 \xa0 \xa0 WHERE \xa0 \xa0 OLD( c.foreignkey ) = p.primarykey\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"and has transition properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Transition Table: \xa0CHILD\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Alias: \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 C\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire on Insert: \xa0 \xa0Never\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire on Delete: \xa0 \xa0Always\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire on Update: \xa0 \xa0Never\n"})}),"\n",(0,s.jsx)(n.p,{children:"This is a productive, transitional constraint on a child table. If the last record of the child table is deleted, this constraint should make sure the parent record is automatically deleted as well. Because of the OLD() function in the last clause, the child table is automatically the Transition Table. The constraint is only evaluated when a child record is deleted, because of the transition properties."}),"\n",(0,s.jsx)(n.p,{children:"Whenever a child record is deleted, the c.foreignkey column name becomes NULL, because that is the NEW value in a Delete. This makes the outcome of this subquery uncertain and dependent on your database conventions regarding treatment of NULL values. This is not what you want."}),"\n",(0,s.jsx)(n.p,{children:"The only place where you want to bind a current value to the statement is in the second mention of the transition table (the OLD(c.foreignkey) value)."}),"\n",(0,s.jsx)(n.p,{children:"The solution is to use different table aliases so you can specify this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"DELETE FROM \xa0 \xa0parent p\nWHERE NOT EXISTS\n(\n \xa0 \xa0 \xa0 \xa0SELECT \xa0 \xa0'child record'\n \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 \xa0child c1\n \xa0 \xa0 \xa0 \xa0WHERE \xa0 \xa0 c1.foreignkey = p.primarykey\n)\nAND EXISTS\n(\n \xa0 \xa0 \xa0 \xa0SELECT \xa0 'old child record'\n \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 child c2\n \xa0 \xa0 \xa0 \xa0WHERE \xa0 \xa0OLD( c2.foreignkey ) = p.primarykey\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"and set transition properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Transition Table: \xa0CHILD\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Alias: \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 C2\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire on Insert: \xa0 \xa0Never\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire on Delete: \xa0 \xa0Always\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Fire on Update: \xa0 \xa0Never\n"})}),"\n",(0,s.jsx)(n.h3,{id:"",children:"\xa0"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);