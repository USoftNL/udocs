"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[56478],{28453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>o});var r=i(96540);const n={},l=r.createContext(n);function s(e){const t=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),r.createElement(l.Provider,{value:t},e.children)}},98724:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Repositories/Blend_directives/pcDirectory","title":"pc:Directory","description":"This article is about the pc:Directory Blend directive.","source":"@site/docs/Repositories/Blend_directives/pcDirectory.md","sourceDirName":"Repositories/Blend_directives","slug":"/Repositories/Blend_directives/pcDirectory","permalink":"/udocs/Repositories/Blend_directives/pcDirectory","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"pcDirectory"},"sidebar":"sidebar","previous":{"title":"pc:Dialog","permalink":"/udocs/Repositories/Blend_directives/pcDialog"},"next":{"title":"pc:DropDatabase","permalink":"/udocs/Repositories/Blend_directives/pcDropDatabase"}}');var n=i(74848),l=i(28453);const s={id:"pcDirectory"},o="pc",a={},c=[{value:"<strong>pc</strong>",id:"pc-1",level:2},{value:"Before and after",id:"before-and-after",level:2},{value:"Looping over a set of files or directories",id:"looping-over-a-set-of-files-or-directories",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsxs)(t.h1,{id:"pc",children:["pc",":Directory"]})}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["This article is about the ",(0,n.jsxs)(t.strong,{children:["pc",":Directory"]}),(0,n.jsx)(t.a,{href:"/Repositories/Blend_directives",children:" Blend directive"}),"."]})}),"\n",(0,n.jsx)(t.h2,{id:"pc-1",children:(0,n.jsxs)(t.strong,{children:["pc",":Directory"]})}),"\n",(0,n.jsx)(t.p,{children:"Returns a directory-and-file description of the contents of a directory node in the file system, allowing you to loop over a set of files. This description contains, for each directory and each file:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The local name of the directory or file."}),"\n",(0,n.jsx)(t.li,{children:"The full path leading to the directory or file."}),"\n",(0,n.jsx)(t.li,{children:"A timestamp indicating the time and date when the directory or file was last modified."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Returns an XML fragment."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Syntax"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:'<pc:Directory\n     filepath="*file-path*"\n     select="*xpath*"\n     filter="*path-pattern*"\n     subdirlevel="*integer*"\n     before="*date*"\n     after="*date*"\n/>\n'})}),"\n",(0,n.jsxs)(t.p,{children:["The required ",(0,n.jsx)(t.strong,{children:"filepath"})," points to the directory that you want a description of."]}),"\n",(0,n.jsxs)(t.p,{children:["The optional ",(0,n.jsx)(t.strong,{children:"select"})," attribute is a filter that selects specific nodes from the returned XML document, as shown in Examples 2 and 3. The ",(0,n.jsx)(t.em,{children:"xpath"})," location path is evaluated relative to the root node of this XML document, regardless of whether it is a relative or absolute location path."]}),"\n",(0,n.jsxs)(t.p,{children:["The optional ",(0,n.jsx)(t.strong,{children:"filter"}),' attribute is a file name pattern applied to the result, as shown in Example 3. For an explanation, search "file name patterns" on USoft Community. If the result lists files (at any level of the directory tree), then']}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:'filter="*.xml"\n'})}),"\n",(0,n.jsx)(t.p,{children:'causes the result to list only files that have the "*.xml" extension.'}),"\n",(0,n.jsxs)(t.p,{children:["The optional ",(0,n.jsx)(t.strong,{children:"subdirlevel"})," is a filter that restricts to a maximum level of subdirectories. Its value must be a positive integer or 0 (zero). If its value is 1, only the contents of the directory itself and its first-level subdirectories are returned. If its value is 0, no information on subdirectories is returned."]}),"\n",(0,n.jsxs)(t.p,{children:["The optional ",(0,n.jsx)(t.strong,{children:"before"})," and ",(0,n.jsx)(t.strong,{children:"after"}),' allow you to specify that you only want information on files before, or after, or between, the specified date value(s). See the "Before and after" section below. ',(0,n.jsx)(t.em,{children:"Date"})," must be in a date format that can be interpreted in USoft Blend."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Example 1"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-xml",children:'<pc:Directory filepath="c:\\temp" />\n'})}),"\n",(0,n.jsx)(t.p,{children:"An example result is:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-xml",children:'<Directory dirpath="c:\\temp\\" dirname="temp" lastwrite="2019/0109100614">\n  <Directory dirpath="c:\\temp\\mydir2" dirname="mydir2" lastwrite="2019/0109100620">\n    <File filepath="c:\\temp\\mydir2\\myfile4.txt" filename="myfile4.txt" lastwrite="2019/0109100021" />\n  </Directory>\n    <File filepath="c:\\temp\\myfile1.xml" filename="myfile1.xml" lastwrite="2019/0109093257" />\n    <File filepath="c:\\temp\\myfile2.xml" filename="myfile2.xml" lastwrite="2019/0109083456" />\n    <File filepath="c:\\temp\\myfile3.txt" filename="myfile3.txt" lastwrite="2019/0108180520" />\n</Directory>\n'})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Example 2"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-xml",children:'<pc:Directory filepath="c:\\temp" select="Directory/File" />\n'})}),"\n",(0,n.jsx)(t.p,{children:"An example result is:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-xml",children:'<File filepath="c:\\temp\\myfile1.xml" filename="myfile1.xml" lastwrite="2019/0109093257" />\n<File filepath="c:\\temp\\myfile2.xml" filename="myfile2.xml" lastwrite="2019/0109083456" />\n<File filepath="c:\\temp\\myfile3.txt" filename="myfile3.txt" lastwrite="2019/0108180520" />\n'})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Example 3"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-xml",children:'<pc:Directory filepath="c:\\temp" select="Directory/File" filter="*.xml" />\n'})}),"\n",(0,n.jsx)(t.p,{children:"An example result is:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-xml",children:'<File filepath="c:\\temp\\myfile1.xml" filename="myfile1.xml" lastwrite="2019/0109093257" />\n<File filepath="c:\\temp\\myfile2.xml" filename="myfile2.xml" lastwrite="2019/0109083456" />\nThis is more efficient than the following, because the result is filtered upfront, as opposed to the whole set being retrieved before it is filtered:\n<pc:Directory filepath="c:\\temp" select="Directory/File[strings:EndsWith(@filename,\'.xml\')]" />\n'})}),"\n",(0,n.jsx)(t.h2,{id:"before-and-after",children:"Before and after"}),"\n",(0,n.jsx)(t.p,{children:"You can optionally specify that you only want to see items that have a timestamp before or after a specified date, or between specified dates."}),"\n",(0,n.jsx)(t.p,{children:"In the following example, the result only contains XML files that have a timestamp between 1 and 15 of January, 2019:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-xml",children:'<pc:Directory\n     filepath="c:\\temp" filter="*.xml"\n     before="01-01-2019"\n     after = "15-01-2019"\n/>\n'})}),"\n",(0,n.jsx)(t.p,{children:"This is true because the following date format is in the list of USoft Blend date formats:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"DD-MM-YYYY\n"})}),"\n",(0,n.jsx)(t.admonition,{type:"warning",children:(0,n.jsx)(t.p,{children:'The use of the before and after attributes yields an uncertain result if applied to a set of files and folders that is not a flat list but, rather, a hierarchical structure in which subfolders or parent folders have a timestamp of their own. In the example, the result is certain, because the filepath and filter attributes together cause the result to be a flat list: all the files with extension .XSL that are in directory "c:\\temp" (but not in subfolders of this directory).'})}),"\n",(0,n.jsx)(t.h2,{id:"looping-over-a-set-of-files-or-directories",children:"Looping over a set of files or directories"}),"\n",(0,n.jsx)(t.p,{children:"To loop over a set or files or directories, you can use the following 2 directives. This particular example simply outputs a list of filenames."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-xml",children:'<pc:assign-nodeset textfiles="{.}">\n   <pc:Directory filepath="c:\\temp" select="Directory/File" filter="*.xml"/>\n</pc:assign-nodeset>\n<pc:each select="$textfiles" assign:result="@filename">\n     <pc:value-of select="$result"/><pc:newline/>\n</pc:each>\n'})}),"\n",(0,n.jsx)(t.p,{children:"\xa0"})]})}function h(e={}){const{wrapper:t}={...(0,l.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);