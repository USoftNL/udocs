"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[49172],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}},34282:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"Services/Event_processing/Handling_events","title":"Handling events","description":"The Rules Engine is responsible for handling received event data by processing business rules that apply to this data. These business rules are defined in USoft Definer.","source":"@site/docs/Services/Event_processing/Handling_events.md","sourceDirName":"Services/Event_processing","slug":"/Services/Event_processing/Handling_events","permalink":"/udocs/Services/Event_processing/Handling_events","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Handling_events"},"sidebar":"sidebar","previous":{"title":"Event processing: Receiving events","permalink":"/udocs/Services/Event_processing/Event_processing_Receiving_events"},"next":{"title":"Event handling Example 1: Job that processes queued input events","permalink":"/udocs/Services/Event_processing/Event_handling_Example_1_Job_that_processes_queued_input_events"}}');var i=t(74848),a=t(28453);const r={id:"Handling_events"},o="Handling events",c={},l=[{value:"Constraint implementations",id:"constraint-implementations",level:3},{value:"Jobs as a means to start processing",id:"jobs-as-a-means-to-start-processing",level:3},{value:"Rules for event processing have special characteristics",id:"rules-for-event-processing-have-special-characteristics",level:3}];function d(e){const n={em:"em",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"handling-events",children:"Handling events"})}),"\n",(0,i.jsxs)(n.p,{children:["The Rules Engine is responsible for handling received event data by processing ",(0,i.jsx)(n.strong,{children:"business rules"})," that apply to this data. These business rules are defined in USoft Definer."]}),"\n",(0,i.jsxs)(n.p,{children:["Business rules are usually implemented in ",(0,i.jsx)(n.strong,{children:"constraints,"})," but when you process input events, it is often attractive to define ",(0,i.jsx)(n.strong,{children:"jobs"})," to start processing and to activate the constraints. Rules for event processing tend to have ",(0,i.jsx)(n.strong,{children:"special characteristics"})," compared to other types of rules."]}),"\n",(0,i.jsx)(n.h3,{id:"constraint-implementations",children:"Constraint implementations"}),"\n",(0,i.jsx)(n.p,{children:"Different types of contraints have different advantages in event processing:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Standard constraints"})," react to data change in any table column that appears (= is mentioned) in the constraint's SQL statement. The evaluation time depends on characteristics of the table(s) that appear in the constraint's SQL statement, as well as on the complexity of the constraint's SQL statement. Standard constraints guarantee an excellent level of data integrity because they are able to guarantee that a business rule is always enforced."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Transitional constraints"})," have a specified ",(0,i.jsx)(n.strong,{children:"transition table."})," They allow you to handle data as soon as an incoming record is stored in this transition table. They only fire when the transition table is manipulated. They do not fire if other tables mentioned in the constraint's SQL statement (if any) are manipulated. Transitional constraints can refer, in their logic, to both ",(0,i.jsx)(n.strong,{children:"old"})," and ",(0,i.jsx)(n.strong,{children:"new"})," column values of records being manipulated in the transition table. Transitional constraints are merely triggers that respond to data manipulation. They do not guarantee data integrity in the same way as standard constraints."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Post-commit constraints"})," allow you to control transaction behaviour. A post-commit constraint will fire after a transaction is successfully finished. It will start a new transaction. This mechanism is useful for controlling the flow of event processing."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"See USoft Definer Help for details on how to define constraints."}),"\n",(0,i.jsx)(n.h3,{id:"jobs-as-a-means-to-start-processing",children:"Jobs as a means to start processing"}),"\n",(0,i.jsx)(n.p,{children:"You can implement most every kind of rules-based event processing just by modelling data and writing constraints."}),"\n",(0,i.jsxs)(n.p,{children:["However, to ",(0,i.jsx)(n.em,{children:"start"})," an event processing task, it is attractive (in addition) to define a USoft ",(0,i.jsx)(n.strong,{children:"job"})," in USoft Definer. When the runtime application calls the job, processing starts and the underlying constraints network is activated."]}),"\n",(0,i.jsx)(n.p,{children:"This technique gives you better control of error handling, better traceability, and improved atomicity. With a job, you can:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Control what happens to errors."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Influence transaction behaviour (commit, rollback)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add useful trace and log information, such as the date-time when the incoming event was received, the date-time when the event was processed, and the date-time when an output message was sent. This data may be used, among other things, when interpreting the result of performance tests."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"See USoft Definer Help for details on how to define jobs."}),"\n",(0,i.jsx)(n.h3,{id:"rules-for-event-processing-have-special-characteristics",children:"Rules for event processing have special characteristics"}),"\n",(0,i.jsx)(n.p,{children:"An event-driven application takes a different view on data integrity than an application built for request-response mechanisms."}),"\n",(0,i.jsx)(n.p,{children:"Request-response mechanisms include communication with an end user who manipulates data in an interactive screen. By contrast, in general, event processing requires that data integrity violation does not stop processing. Instead, errors should become output error events that are logged to a database or to a file. Because of this, USoft event-driven applications should use restrictive constraints and restrictive relationships with care. The default should be to avoid restrictions on data where possible, producing traceable error data instead."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);