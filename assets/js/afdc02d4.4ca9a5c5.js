"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[17951],{21645:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/5e35ada5-08cc-4b76-a9de-837a502694d8-1ac205c9f574e6502762a59789b29cdc.png"},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(96540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},68159:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Constraint_evaluation_order","title":"Constraint evaluation order","description":"A Rules Engine in USoft executes, against application data in a data model, a non-ordered collection of constraints: domain constraints and table constraints.","source":"@site/docs/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Constraint_evaluation_order.md","sourceDirName":"Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine","slug":"/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Constraint_evaluation_order","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Constraint_evaluation_order","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Constraint_evaluation_order"},"sidebar":"sidebar","previous":{"title":"Store-record event overview","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Storerecord_event_overview"},"next":{"title":"Chained corrections","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Chained_corrections"}}');var r=t(74848),i=t(28453);const a={id:"Constraint_evaluation_order"},o="Constraint evaluation order",c={},d=[];function l(e){const n={em:"em",h1:"h1",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"constraint-evaluation-order",children:"Constraint evaluation order"})}),"\n",(0,r.jsx)(n.p,{children:"A Rules Engine in USoft executes, against application data in a data model, a non-ordered collection of constraints: domain constraints and table constraints."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Field-validation events"}),", ",(0,r.jsx)(n.strong,{children:"store-record events"})," and ",(0,r.jsx)(n.strong,{children:"commit events"})," cause these constraints to be ",(0,r.jsx)(n.em,{children:"activated"}),". When constraints are activated, they can perform 3 types of action:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Corrections."})," These consist of adding, changing or removing field values under the hood, on behalf of a user, as a knock-on effect of initial data manipulation that the user has performed interactively. While the word 'correction' seems to refer to resetting values that would otherwise be an error, corrections are in fact a much more general concept: ",(0,r.jsx)(n.em,{children:"any"})," data manipulation performed by a constraint rather than directly by the user is considered a correction. While it is possible to warn the user of a correction, the default mode of behaviour is that corrections happen automatically and in the background."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Checks."})," These consist of testing that values supplied or removed (whether directly by the user or indirectly by a correction) meet certain predefined conditions. Unlike corrections, checks are ",(0,r.jsx)(n.em,{children:"restrictive:"})," if the values supplied or produced do not pass the test, ie., if they ",(0,r.jsx)(n.em,{children:"violate"})," a condition, then processing is blocked and an error message is returned to the user."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Signals."})," These consist of adding, at store-record time, new entries to a list of checks, called ",(0,r.jsx)(n.em,{children:"transaction checklist,"})," that will be run through later at commit time. \xa0If and when the transaction is committed, all the checks on the list are performed first. Commit will be successful only if all the checks are passed. Signals are nothing more than a way to make necessary later checks perform faster."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The picture visualises how corrections, checks and signals are activated when constraint activation events occur. Domain constraints are activated by field-validation events. Table constraints are activated by store-record events and commit events."}),"\n",(0,r.jsxs)(n.p,{children:["Each time a field is validated, a ",(0,r.jsx)(n.em,{children:"pre-field"})," phase occurs first. During this phase, all domain constraints in scope for the field are handled. They give rise to field corrections and field checks."]}),"\n",(0,r.jsxs)(n.p,{children:["Each time a record is stored, a ",(0,r.jsx)(n.em,{children:"pre-store"})," phase occurs first. During this phase, update-on-self corrections, row checks, and transaction checklist signals are performed. As the next step, the record is said to be ",(0,r.jsx)(n.em,{children:"stored"})," internally: its changes are registered and consolidated internally, ready to be committed later at commit time. Then, a ",(0,r.jsx)(n.em,{children:"post-store"})," phase occurs. During this phase, cascade-to-other corrections are performed."]}),"\n",(0,r.jsxs)(n.p,{children:["Each time a transaction is committed, a ",(0,r.jsx)(n.em,{children:"pre-commit"})," phase occurs first. During this phase, transaction checks are performed with the help of the transaction checklist compiled earlier. Next, if all transaction checks are passed successfully, the transaction is committed, in the sense of giving the COMMIT command to the RDBMS. Exceptionally, this may be followed by a ",(0,r.jsx)(n.em,{children:"post-commit"})," phase if there are chained corrections defined by table constraints that are deferred until post-commit time."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(21645).A+"",width:"811",height:"604"})}),"\n",(0,r.jsx)(n.p,{children:"\xa0"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);