"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[76490],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(96540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}},74642:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/67e8205e-f30d-4363-ad3e-f66017ed4729-ecb22b01c487e17b4bcc7fa50f5ff393.png"},83054:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Collaboration/USoft_Approach/How_business_rules_fit_into_the_USoft_Approach","title":"How business rules fit into the USoft Approach","description":"Business rules play an important part at many times in the USoft Approach:","source":"@site/docs/Collaboration/USoft_Approach/How_business_rules_fit_into_the_USoft_Approach.md","sourceDirName":"Collaboration/USoft_Approach","slug":"/Collaboration/USoft_Approach/How_business_rules_fit_into_the_USoft_Approach","permalink":"/udocs/Collaboration/USoft_Approach/How_business_rules_fit_into_the_USoft_Approach","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"How_business_rules_fit_into_the_USoft_Approach"},"sidebar":"sidebar","previous":{"title":"Principles of the USoft Approach","permalink":"/udocs/Collaboration/USoft_Approach/Principles_of_the_USoft_Approach"},"next":{"title":"Prerequisites for the USoft Approach","permalink":"/udocs/Collaboration/USoft_Approach/Prerequisites_for_the_USoft_Approach"}}');var a=n(74848),i=n(28453);const r={id:"How_business_rules_fit_into_the_USoft_Approach"},o="How business rules fit into the USoft Approach",l={},c=[{value:"Rule example 1: restrictive SQL constraint",id:"rule-example-1-restrictive-sql-constraint",level:2},{value:"Rule example 2: productive SQL constraint",id:"rule-example-2-productive-sql-constraint",level:2},{value:"Key benefits of rules-based systems",id:"key-benefits-of-rules-based-systems",level:3},{value:"",id:"",level:3}];function d(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"how-business-rules-fit-into-the-usoft-approach",children:"How business rules fit into the USoft Approach"})}),"\n",(0,a.jsx)(t.p,{children:"Business rules play an important part at many times in the USoft Approach:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:n(74642).A+"",width:"831",height:"282"})}),"\n",(0,a.jsx)(t.p,{children:"The purpose of the USoft Approach is to create and maintain USoft applications, which contain a Rules Engine."}),"\n",(0,a.jsx)(t.p,{children:"In practice, USoft applications can implement business rules in many different ways, including custom-built Java or .NET code. The USoft platform has many useful features for making these different types of rule implementation traceable."}),"\n",(0,a.jsxs)(t.p,{children:["However, the most typical format for rule implementation in USoft is ",(0,a.jsx)(t.em,{children:"SQL constraints"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"This article takes SQL constraints as an example to illustrate how business rules contribute to the success of the USoft Approach."}),"\n",(0,a.jsxs)(t.p,{children:["Here are two examples of business rules implemented as USoft SQL constraints. The first is a ",(0,a.jsx)(t.em,{children:"restrictive"})," implementation: it defines something that is not allowed to occur in business data. The second is a ",(0,a.jsx)(t.em,{children:"productive"})," (or: ",(0,a.jsx)(t.em,{children:"corrective"}),") implementation: it defines how the Rules Engine must react when a certain data configuration occurs."]}),"\n",(0,a.jsx)(t.p,{children:"These two implementations have important advantages over conventional coding:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The business rule ",(0,a.jsx)(t.em,{children:"maps directly"})," to the constraint. This contributes to easy communication between stakeholders who formulate and validate the rule, and team members who create the constraint. This is important in the SPECIFY and IMPLEMENT tasks of the DEFINE phase when the rules first appear. It is also important in later cycles, including in the PLAN phase, when it becomes important to ",(0,a.jsx)(t.em,{children:"trace"})," (locate) existing rules and constraints easily."]}),"\n",(0,a.jsxs)(t.li,{children:["The constraint is ",(0,a.jsx)(t.em,{children:"atomic:"})," self-organising, not dependent on neighbouring code. As a result, if the rule is dropped, all you need to do is drop the constraint. If the rule changes, all you need to do is change the constraint. This is important in DEFINE phases after the iteration in which the rule first appeared."]}),"\n",(0,a.jsxs)(t.li,{children:["The constraint defines ",(0,a.jsx)(t.em,{children:"data quality."}),' It does not just implement software behaviour at the time it is "triggered". It guarantees that all the business data in the application satisfies the logic expressed. This general and verifyable mark of quality will help in many phases, especially in building confidence with the customer for new PLAN phases.']}),"\n",(0,a.jsxs)(t.li,{children:["The constraint is ",(0,a.jsx)(t.em,{children:"executable:"}),' the particular fragment of SQL that it contains can be run stand-alone against any database, including "old data" or production data in an environment that you release a new application version to. This has important practical advantages. You can upgrade existing production data elegantly, so that "old data" satisfy "new rules" if that is what you require. In development and test situations, you can readily answer the question whether any set of given data satisfies the rule, or not. The upgrade advantage is important in the Release subphase of the DELIVER phase and can be realised by using the Upgrade Scripts feature of USoft Delivery Manager. The test advantage is important in the TEST tasks of the DEFINE phase and can be realised by using the Violation Reports feature in USoft Benchmark.']}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"rule-example-1-restrictive-sql-constraint",children:"Rule example 1: restrictive SQL constraint"}),"\n",(0,a.jsx)(t.p,{children:"Business rule: The same guide may not be scheduled to accompany 2 tours at the same time."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"SELECT \xa0 ''\nFROM \xa0 \xa0 tour t1\n, \xa0 \xa0 \xa0 \xa0tour t2\nWHERE \xa0 \xa0t1.tour_id <> t2.tour_id\nAND \xa0 \xa0 \xa0t1.start_date between t2.start_date and t2.end_date\nAND \xa0 \xa0 \xa0t1.guide = t2.guide\n\n"})}),"\n",(0,a.jsx)(t.p,{children:"This snippet of SQL code is responsible for guaranteeing, all by itself, that the rule is followed in all circumstances."}),"\n",(0,a.jsx)(t.p,{children:"It actively prevents the data situation described by the SELECT statement, regardless of how a potential violation comes about. It is active when people try to schedule a guide at a time when she is already busy. But it is also active when tours with appointed guides are moved around on the calendar."}),"\n",(0,a.jsx)(t.p,{children:"This business rule can return an error message whenever a violation is attempted. The error message can be the business rule itself."}),"\n",(0,a.jsx)(t.h2,{id:"rule-example-2-productive-sql-constraint",children:"Rule example 2: productive SQL constraint"}),"\n",(0,a.jsx)(t.p,{children:"Business rule: Customers are charged an ATM transaction fee of $1.00, but if a customer generates more than 10 transactions since the last bank statement, ATM transaction fees for that period are waived."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:'UPDATE \xa0 transaction_fee tf\nSET \xa0 \xa0 \xa0tf.txn_fee_amount = 0\nWHERE \xa0 \xa0tf.txn_fee_type = \'ATM\'\nAND \xa0 \xa0 \xa010 <=\n(\n \xa0 \xa0 \xa0 SELECT \xa0 \xa0 COUNT(*)\n \xa0 \xa0 \xa0 FROM \xa0 \xa0 \xa0 transaction t1\n \xa0 \xa0 \xa0 , \xa0 \xa0 \xa0 \xa0 \xa0transaction t2\n \xa0 \xa0 \xa0 RELATE \xa0 \xa0 t1 "HAS" tf\n \xa0 \xa0 \xa0 WHERE \xa0 \xa0 \xa0t2.account_id = tf.account_id\n \xa0 \xa0 \xa0 AND\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 t2.transaction_date >\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 (\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0SELECT \xa0 \xa0MAX( a.last_statement_date )\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 \xa0account a1\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0RELATE \xa0 \xa0a1 "HAS" t1\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0WHERE \xa0 \xa0 a1.last_statement_date < t1.transaction_date\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 )\n \xa0 \xa0 \xa0 AND\n \xa0 \xa0 \xa0 (\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 t2.transaction_date <\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 (\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0SELECT \xa0 \xa0MIN( a.last_statement_date )\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 \xa0account a1\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0RELATE \xa0 \xa0a1 "HAS" t1\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0WHERE \xa0 \xa0 a1.last_statement_date > t1.transaction_date\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 )\n  \xa0 \xa0 \xa0 \xa0 OR NOT EXISTS\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 (\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 SELECT \xa0 \xa0\'\'\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 FROM \xa0 \xa0 \xa0account a3\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 RELATE \xa0 \xa0a3 "HAS" t1\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 WHERE \xa0 \xa0 a3.last_statement_date > t1.transaction_date\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 )\n \xa0 \xa0 \xa0 )\n)\n\n'})}),"\n",(0,a.jsx)(t.p,{children:"This comparitively small snippet of SQL code is responsible for waiving ATM transaction fees whenever more than 10 transactions have been generated since the last statement."}),"\n",(0,a.jsx)(t.p,{children:"This business rule executes every time an ATM transaction occurs. It will check to see if 10 transactions have already been generated since the last statement date. If there are, it sets the ATM transaction fee amount to 0. Else, it does not, in which case the original ATM transaction fee (if any), apparently set by some other rule, must be maintained."}),"\n",(0,a.jsxs)(t.p,{children:["This business rule is much more powerful than just an IF-THEN-ELSE routine. If anything happens to any data involved, such as perhaps an unforeseen correction made to a statement date for an account, then the waiver will ",(0,a.jsx)(t.em,{children:"automatically"}),' be re-calculated. Also, this USoft rule implementation allows you to verify the "waiver" rule against any set of static data, including existing test data sets that must now begin to obey to the rule, and even existing data in Production that must be upgraded. Whether or not it is actually desirable to upgrade all the existing Production data is a separate decision: this must be shaped and presented as a separate business rule.']}),"\n",(0,a.jsx)(t.h3,{id:"key-benefits-of-rules-based-systems",children:"Key benefits of rules-based systems"}),"\n",(0,a.jsx)(t.p,{children:"Key benefits of rules-based systems include:"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{}),(0,a.jsx)(t.th,{})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"SPOD"}),(0,a.jsx)(t.td,{children:"Single Point Of Definition. Business rules and implementations are defined and stored only once in a central repository."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Automatic rules activation"}),(0,a.jsx)(t.td,{children:"A Rules Engine is responsible for determining which rules must be evaluated when, and in what sequence. Lower-level coding of rule activation logic is no longer required."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Declarative tooling"}),(0,a.jsx)(t.td,{children:"The development platform allows you to set trivial aspects of business systems declaratively, to prevent non-trivial rules from being swamped by trivial rules such as a data element being mandatory."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Modularity"}),(0,a.jsx)(t.td,{children:"Rule implementations are independent of database, middleware and GUI specifics of the IT context where they are deployed and also largely independent on the implementation of neighbouring rules."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Support for Agile change"}),(0,a.jsx)(t.td,{children:"Rule change is easier because individual, modular implementations map directly to validated rule specifications."})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Cross-referencing capability"}),(0,a.jsx)(t.td,{children:"Cross-references between rules and the conceptual model make it easy to find and retrieve rules and to assess the impact of any change."})]})]})]}),"\n",(0,a.jsx)(t.h3,{id:"",children:"\xa0"})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);