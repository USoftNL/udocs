"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[59809],{28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var t=i(96540);const s={},a=t.createContext(s);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:n},e.children)}},89295:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Modeller_and_Rules_Engine/Tables_columns_and_relationships/The_RELATE_keyword","title":"The RELATE keyword","description":"The RELATE keyword is a USoft-specific extension to the SQL language. It is used in SQL statements that query multiple table instances to introduce an optional RELATE clause.","source":"@site/docs/Modeller_and_Rules_Engine/Tables_columns_and_relationships/The_RELATE_keyword.md","sourceDirName":"Modeller_and_Rules_Engine/Tables_columns_and_relationships","slug":"/Modeller_and_Rules_Engine/Tables_columns_and_relationships/The_RELATE_keyword","permalink":"/udocs/Modeller_and_Rules_Engine/Tables_columns_and_relationships/The_RELATE_keyword","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"The_RELATE_keyword"},"sidebar":"sidebar","previous":{"title":"How to define a relationship","permalink":"/udocs/Modeller_and_Rules_Engine/Tables_columns_and_relationships/How_to_define_a_relationship"},"next":{"title":"External tables","permalink":"/udocs/Modeller_and_Rules_Engine/Tables_columns_and_relationships/External_tables"}}');var s=i(74848),a=i(28453);const l={id:"The_RELATE_keyword"},o="The RELATE keyword",r={},c=[{value:"RELATE syntax",id:"relate-syntax",level:3},{value:"Comparing RELATE and WHERE",id:"comparing-relate-and-where",level:3},{value:"RELATE in transitional constraints",id:"relate-in-transitional-constraints",level:3},{value:"Notes",id:"notes",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"the-relate-keyword",children:"The RELATE keyword"})}),"\n",(0,s.jsxs)(n.p,{children:["The RELATE keyword is a USoft-specific extension to the SQL language. It is used in SQL statements that query multiple table instances to introduce an optional ",(0,s.jsx)(n.em,{children:"RELATE clause."})]}),"\n",(0,s.jsx)(n.p,{children:"A RELATE clause is a USoft-specific alternative to writing conventional join conditions in the WHERE clause."}),"\n",(0,s.jsx)(n.h3,{id:"relate-syntax",children:"RELATE syntax"}),"\n",(0,s.jsx)(n.p,{children:"A RELATE clause must appear immediately after the FROM clause."}),"\n",(0,s.jsx)(n.p,{children:"The syntax of the RELATE clause is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'RELATE *join-condition [, join-condition ... ]*\n\n*join-condition \xa0::= \xa0parent "role" child*\n'})}),"\n",(0,s.jsxs)(n.p,{children:["where each ",(0,s.jsx)(n.em,{children:"join-condition"})," is based on exactly 1 underlying Relationship definition, and ",(0,s.jsx)(n.em,{children:"parent, role"})," and ",(0,s.jsx)(n.em,{children:"child"})," are taken from that underlying Relationship definition: ",(0,s.jsx)(n.em,{children:"parent"})," is the Parent Object, ",(0,s.jsx)(n.em,{children:"child"})," is the Child Object, and ",(0,s.jsx)(n.em,{children:"role"})," is the Parent Role."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Role"})," is optionally surrounded by double quotes. ",(0,s.jsx)(n.em,{children:"Role"})," may contain spaces, in which case the double quotes are mandatory. ",(0,s.jsx)(n.em,{children:"Parent"})," and ",(0,s.jsx)(n.em,{children:"child"})," must appear in the FROM clause. It is customary to identify ",(0,s.jsx)(n.em,{children:"parent"})," and ",(0,s.jsx)(n.em,{children:"child"})," by using table aliases that also appear in the FROM clause:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT     e.name\n,          c.location\nFROM \xa0 \xa0 \xa0 company c, department d, employee e\nRELATE \xa0 \xa0 c HAS d\n,          d \"EMPLOYS\" e\nWHERE \xa0    e.salary_level = 'A3'\n"})}),"\n",(0,s.jsx)(n.h3,{id:"comparing-relate-and-where",children:"Comparing RELATE and WHERE"}),"\n",(0,s.jsx)(n.p,{children:"It is always possible to replace a RELATE clause by conventional join conditions in the WHERE clause, and get exactly the same query result. The result of:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT \xa0 \xa0 \xa0 e.name\n,            c2.location\nFROM \xa0 \xa0 \xa0 \xa0 company c1\n, \xa0 \xa0 \xa0 \xa0 \xa0 \xa0company c2\n, \xa0 \xa0 \xa0 \xa0 \xa0 \xa0department d\n, \xa0 \xa0 \xa0 \xa0 \xa0 \xa0employee e\nRELATE \xa0 \xa0 \xa0 c1 \"HAS DAUGHTER\" c2\n, \xa0 \xa0 \xa0 \xa0 \xa0 \xa0c2 HAS d\n, \xa0 \xa0 \xa0 \xa0 \xa0 \xa0d \"EMPLOYS\" e\nWHERE \xa0 \xa0 \xa0 \xa0e.salary_level = 'A3'\nAND \xa0 \xa0 \xa0 \xa0 \xa0c1.id = 'USOFT'\n"})}),"\n",(0,s.jsx)(n.p,{children:"is also the result of:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT \xa0 \xa0 \xa0 e.name\n,            c2.location\nFROM \xa0 \xa0 \xa0 \xa0 company c1\n, \xa0 \xa0 \xa0 \xa0 \xa0 \xa0company c2\n, \xa0 \xa0 \xa0 \xa0 \xa0 \xa0department d\n, \xa0 \xa0 \xa0 \xa0 \xa0 \xa0employee e\nWHERE \xa0 \xa0 \xa0 \xa0c1.id = c2.daughter_of\nAND \xa0 \xa0 \xa0 \xa0 \xa0c2.id = d.company_id\nAND \xa0 \xa0 \xa0 \xa0 \xa0d.id = e.dept_id\nAND \xa0 \xa0 \xa0 \xa0 \xa0e.salary_level = 'A3'\nAND \xa0 \xa0 \xa0 \xa0 \xa0c1.id = 'USOFT'\n"})}),"\n",(0,s.jsx)(n.p,{children:"The advantage of using RELATE is that you can change key columns of the Relationship without having to change the SQL statements themselves. More importantly, with RELATE the SQL Objects feature is able to trace the objects that make use of a given Relationship."}),"\n",(0,s.jsx)(n.p,{children:"RELATE is also more readable than WHERE, because it signposts which WHERE conditions are join conditions and which are not, because it uses meaningful role names, and because it requires only a single join condition even if the relationship key spans multiple columns."}),"\n",(0,s.jsx)(n.h3,{id:"relate-in-transitional-constraints",children:"RELATE in transitional constraints"}),"\n",(0,s.jsx)(n.p,{children:"When using the RELATE keyword in transitional constraints, and primary key or foreign key values are changed run time, the Rules Engine substitutes both the OLD and NEW values of the changed record in this constraint. In specific cases, this default behavior may lead to performance problems, or may result in unexpected violations."}),"\n",(0,s.jsx)(n.p,{children:"To make the behavior of RELATE in transitional constraints more explicit, you can specify whether you want to execute the constraint for the old values or the new values only, by explicitly adding OLD or NEW to the RELATE construct. These keywords can be used with the transition table:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If NEW is specified, the join will be over the new values of the key."}),"\n",(0,s.jsx)(n.li,{children:"If OLD is specified, the join will be over the old values of the key."}),"\n",(0,s.jsx)(n.li,{children:"If neither NEW nor OLD is specified, the join will be over the old AND new values. This is similar to the default behavior of RELATE."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Example"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT \xa0 \xa0''\nFROM \xa0 \xa0 \xa0child c\n,         parent p\nRELATE \xa0 \xa0p with NEW c\nWHERE \xa0 \xa0 p.col = 'Y'\n"})}),"\n",(0,s.jsx)(n.p,{children:"This results in only the new foreign key values of CHILD being joined with PARENT. Contrast this with:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT \xa0 \xa0''\nFROM \xa0 \xa0 \xa0child c\n,         parent p\nRELATE \xa0 \xa0p with OLD c\nWHERE \xa0 \xa0 p.col = 'Y'\n"})}),"\n",(0,s.jsx)(n.p,{children:"This results in only the old foreign key values of CHILD being joined with PARENT."}),"\n",(0,s.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,s.jsx)(n.p,{children:"You can only use OLD and NEW on ONE table, the transition table."}),"\n",(0,s.jsx)(n.p,{children:"You cannot use OLD and NEW in the SQL Definer."}),"\n",(0,s.jsx)(n.p,{children:"The OLD keyword has different behavior to the OLD() function."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);