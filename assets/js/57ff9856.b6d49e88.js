"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[54981],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(96540);const l={},i=s.createContext(l);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),s.createElement(i.Provider,{value:t},e.children)}},33127:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Repositories/Blend_functions/xslutilapplyTemplate","title":"xslutil:applyTemplate","description":"This article is about the xslutil:applyTemplate Blend function.","source":"@site/docs/Repositories/Blend_functions/xslutilapplyTemplate.md","sourceDirName":"Repositories/Blend_functions","slug":"/Repositories/Blend_functions/xslutilapplyTemplate","permalink":"/udocs/Repositories/Blend_functions/xslutilapplyTemplate","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"xslutilapplyTemplate"},"sidebar":"sidebar","previous":{"title":"wrights:HasAdminRole","permalink":"/udocs/Repositories/Blend_functions/wrightsHasAdminRole"},"next":{"title":"xslutil:json2xml","permalink":"/udocs/Repositories/Blend_functions/xslutiljson2xml"}}');var l=n(74848),i=n(28453);const a={id:"xslutilapplyTemplate"},o="xslutil",r={},c=[{value:"<strong>xslutil</strong>",id:"xslutil-1",level:2}];function p(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(t.header,{children:(0,l.jsxs)(t.h1,{id:"xslutil",children:["xslutil",":applyTemplate"]})}),"\n",(0,l.jsx)(t.admonition,{type:"note",children:(0,l.jsxs)(t.p,{children:["This article is about the ",(0,l.jsxs)(t.strong,{children:["xslutil",":applyTemplate"]}),(0,l.jsx)(t.a,{href:"/Repositories/Blend_functions",children:" Blend function"}),"."]})}),"\n",(0,l.jsx)(t.h2,{id:"xslutil-1",children:(0,l.jsxs)(t.strong,{children:["xslutil",":applyTemplate"]})}),"\n",(0,l.jsx)(t.p,{children:"Applies the identity transformation to some XML input, taking into account a set of extra XSLT templates. The identity transformation causes the input XML to be returned as output XML. The extra templates cause certain nodes of the XML content to be processed in a special way."}),"\n",(0,l.jsx)(t.p,{children:"Returns XML content."}),"\n",(0,l.jsx)(t.p,{children:(0,l.jsx)(t.em,{children:"Syntax"})}),"\n",(0,l.jsx)(t.p,{children:(0,l.jsx)(t.em,{children:"Namespace declaration"})}),"\n",(0,l.jsx)(t.p,{children:"You need to declare this namespace only if you call the function directly from the USCSXSL component but outside Blend. In a Blend context (ublendit.exe, uscsxsl.blend()) the namespace is already declared in the Blend transformation, which is in xsl\\Util\\Batch.1.0.xsl in your USoft installation folder."}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{children:'xmlns:xslutil="USoft:XslUtil"\n'})}),"\n",(0,l.jsx)(t.p,{children:(0,l.jsx)(t.em,{children:"Function call"})}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{children:'xslutil:applyTemplate( *expression*, *extra-templates* )\n\n*extra-templates*  := <xsl:template match="*match-pattern*"> *content* </xsl:template> \u2026\n'})}),"\n",(0,l.jsxs)(t.p,{children:["The required ",(0,l.jsx)(t.em,{children:"expression"})," must be an XPath expression pointing to an XML node set, or a literal XML fragment, or a path leading to an XML file."]}),"\n",(0,l.jsxs)(t.p,{children:["The optional ",(0,l.jsx)(t.em,{children:"extra-templates"})," is an unordered list containing any number of regular XSLT 1.0 templates in the form of <xsl",":template","> instructions. If you omit ",(0,l.jsx)(t.em,{children:"extra-templates"}),", the return XML content is identical to the input XML content."]}),"\n",(0,l.jsxs)(t.p,{children:["In ",(0,l.jsx)(t.em,{children:"extra-templates"}),", each ",(0,l.jsx)(t.em,{children:"match-pattern"})," must be a relative match pattern, that is, a match pattern that does NOT begin with a forward slash\xa0(\xa0/\xa0)."]}),"\n",(0,l.jsx)(t.p,{children:(0,l.jsx)(t.em,{children:"Example"})}),"\n",(0,l.jsxs)(t.p,{children:["In the last line, xslutil",":applyTemplate","() applies two XSLT templates to an XML document stored in a file."]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-xml",children:'<authdata xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:pc="Processing.Command">\n...\n<pc:defs>\n  <xsl:template match="T_AUTH_USER[@USERNAME=\'adminuser\']"/>\n  <xsl:template match="T_AUTH_OC_PARAMS[@OC_ID=\'LAN\' and @SET_TYPE=\'URE\' and @PARAM_NAME=\'Allow_Disable_Constraint\']"/>\n</pc:defs>\n\n<pc:assign-string\n    usauth_filepath="{path:Combine($workingdir, \'USAUTH.xml\')}"/>\n<pc:assign-nodeset\n    usauth_data = "{xslutil:applyTemplate($usauth_filepath, /*/pc:defs/xsl:template)}"/>\n'})}),"\n",(0,l.jsx)(t.p,{children:"The effect of this is equivalent to applying this regular XSLT 1.0 stylesheet:"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-xml",children:'<?xml version="1.0" encoding="windows-1252"?>\n<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">\n<xsl:output method="xml" encoding="UTF-8" omit-xml-declaration="no"/>\n\n<xsl:template match="*|@*|comment()|processing-instruction()|text()">\n  <xsl:copy>\n    <xsl:apply-templates select="*|@*|text()|comment()|processing-instruction()"/>\n  </xsl:copy>\n</xsl:template>\n\n  <xsl:template match="T_AUTH_USER[@USERNAME=\'adminuser\']"/>\n  <xsl:template match="T_AUTH_OC_PARAMS[@OC_ID=\'LAN\' and @SET_TYPE=\'URE\' and @PARAM_NAME=\'Allow_Disable_Constraint\']"/>\n\n</xsl:stylesheet>\n'})}),"\n",(0,l.jsx)(t.p,{children:"\xa0"})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,l.jsx)(t,{...e,children:(0,l.jsx)(p,{...e})}):p(e)}}}]);