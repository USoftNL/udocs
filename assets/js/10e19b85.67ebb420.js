"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[14474],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var i=n(96540);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}},50300:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Driving_table","title":"Driving table","description":"When constraints are evaluated, the SQL that is sent to the database in most cases is not the literal constraint SQL Statement. The Rules Engine attempts to add WHERE conditions to the SQL statements in which column values for only one record are substituted. This is called row binding.","source":"@site/docs/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Driving_table.md","sourceDirName":"Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine","slug":"/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Driving_table","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Driving_table","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Driving_table"},"sidebar":"sidebar","previous":{"title":"Cascade-to-other corrections","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Cascadetoother_corrections"},"next":{"title":"Constraint key query","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Constraint_key_query"}}');var s=n(74848),r=n(28453);const a={id:"Driving_table"},o="Driving table",l={},d=[{value:"How the driving table is determined",id:"how-the-driving-table-is-determined",level:2}];function h(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"driving-table",children:"Driving table"})}),"\n",(0,s.jsxs)(t.p,{children:["When constraints are evaluated, the SQL that is sent to the database in most cases is not the literal constraint SQL Statement. The Rules Engine attempts to add WHERE conditions to the SQL statements in which column values for only one record are substituted. This is called ",(0,s.jsx)(t.em,{children:"row binding"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"For each constraint, there is only one table for which row binding is attempted. This is called the driving table of the constraint."}),"\n",(0,s.jsx)(t.p,{children:'You cannot influence what the driving table is. The Rules Engine determines a constraint\'s driving table when the constraint is parsed, ie., when the developer presses the Check button for the constraint. The driving table is the table "from which" the constraint is evaluated.'}),"\n",(0,s.jsx)(t.p,{children:"In the Constraints window, the Driving Table field shows the driving table."}),"\n",(0,s.jsx)(t.p,{children:"Some RDBMS vendors or commentators use the term 'driving table' with a different meaning."}),"\n",(0,s.jsx)(t.h2,{id:"how-the-driving-table-is-determined",children:"How the driving table is determined"}),"\n",(0,s.jsx)(t.p,{children:"The driving table never depends on what the user does (the initial store-record event). It only depends on how the constraint SQL statement is formulated. For each constraint, the Rules Engine determines the driving table using the following rules:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"If the constraint is an UPDATE constraint, the driving table is the updated table."}),"\n",(0,s.jsx)(t.li,{children:"If the constraint is a DELETE constraint, the driving table is the table deleted from."}),"\n",(0,s.jsx)(t.li,{children:"If the constraint is an INSERT INTO... VALUES() constraint, the driving table is the table inserted into."}),"\n",(0,s.jsx)(t.li,{children:"If the constraint is an INSERT INTO... SELECT ... constraint, the driving table is identified as if only the SELECT clause was executed (see below)."}),"\n",(0,s.jsx)(t.li,{children:"The following rules apply to restrictive constraints, and are ordered according to their priority:"}),"\n"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"If the constraint is transitional, the driving table is the transition table."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"If the FROM clause contains a table for which all primary key columns appear in the statement, the driving table is the first-mentioned table in the FROM clause for which all primary key columns appear in the statement."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Usually this is the highest parent table that occurs within the constraint."}),"\n",(0,s.jsxs)(t.ol,{start:"3",children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"If no table occurs with all primary key columns mentioned, but the constraint does contain a GROUP BY clause, the driving table is the table that belongs to the first column in the GROUP BY clause."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"In all other cases, the driving table is the first-mentioned table in the FROM clause."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"If the statement contains a RELATE clause, consider this as an equivalent of one or more standard WHERE clauses expressing the same relationship. In other words, the driving table is determined as if the joined primary and foreign key column names appeared explicitly in the statement."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:"Example"})}),"\n",(0,s.jsx)(t.p,{children:'A business rule: "The time between the start date and return date of a scheduled tour must equal the preset number of days for the tour." is implemented by a restrictive constraint:'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"SELECT \xa0 \xa0 '' violation\nFROM \xa0 \xa0 \xa0 schedtour st\n, \xa0 \xa0 \xa0 \xa0 \xa0tour t\nWHERE \xa0 \xa0 \xa0t.destination = st.destination\nAND \xa0 \xa0 \xa0 \xa0t.tour_type = st.tour_type\nAND \xa0 \xa0 \xa0 \xa0t.num_days <> st.return_date - st.start_date + 1\n"})}),"\n",(0,s.jsx)(t.p,{children:"The driving table of this constraint is TOUR, because only the TOUR table has all of its primary key columns mentioned in the statement."}),"\n",(0,s.jsx)(t.p,{children:"Therefore, in the transaction check statement issued at commit time, row binding is applied to the TOUR table, independently of whether the original manipulation was on TOUR or on SCHEDTOUR:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"SELECT \xa0 \xa0 ''\nFROM \xa0 \xa0 \xa0 OPS$CP1.SCHEDTOUR t1\nWHERE \xa0 \n(\n \xa0 \xa0 \xa0 \xa0 \xa0 :1 = t1.DESTINATION\n \xa0 AND \xa0 \xa0 :2 = t1.TOUR_TYPE\n \xa0 AND \xa0 \xa0 TO_NUMBER(:3) <> t1.RETURN_DATE - t1.START_DATE + 1\n)\n(EUROPE,GRAND TOUR,28)\n"})}),"\n",(0,s.jsx)(t.p,{children:"In the SQL statement for the transaction check:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The TOUR table is not mentioned anymore. This is the consequence of applying row binding to the driving table."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"In other words: only one record in the TOUR table matters, so values of this record can be substituted instead of mentioning the whole table."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The number of days for the tour, 28 days, is also substituted in the constraint test. This value has been retrieved just before this constraint test was issued, when the driving table record was locked."}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);