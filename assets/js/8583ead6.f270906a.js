"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[37697],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(96540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},61927:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Services/Organising_services/Pagination_of_custom_REST_services","title":"Pagination of custom REST services","description":"Pagination is a good way of handling large API responses, It helps minimise response time and improves the end-user experience. With pagination, large set of data are returned in the form of a series of pages. Pagination implies a default sort order of records. This sort order may be based on a unique identifier, on a creation date value, or on a combination of both. The sort order must not change between two requests if records are also being manipulated (INSERT/DELETE/UPDATE).","source":"@site/docs/Services/Organising_services/Pagination_of_custom_REST_services.md","sourceDirName":"Services/Organising_services","slug":"/Services/Organising_services/Pagination_of_custom_REST_services","permalink":"/udocs/Services/Organising_services/Pagination_of_custom_REST_services","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Pagination_of_custom_REST_services"},"sidebar":"sidebar","previous":{"title":"Versioning custom REST services","permalink":"/udocs/Services/Organising_services/Versioning_custom_REST_services"},"next":{"title":"Event processing","permalink":"/udocs/Services/Event_processing"}}');var t=i(74848),r=i(28453);const o={id:"Pagination_of_custom_REST_services"},a="Pagination of custom REST services",d={},c=[{value:"Offset pagination",id:"offset-pagination",level:2},{value:"Keyset pagination",id:"keyset-pagination",level:2}];function l(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"pagination-of-custom-rest-services",children:"Pagination of custom REST services"})}),"\n",(0,t.jsx)(n.p,{children:"Pagination is a good way of handling large API responses, It helps minimise response time and improves the end-user experience. With pagination, large set of data are returned in the form of a series of pages. Pagination implies a default sort order of records. This sort order may be based on a unique identifier, on a creation date value, or on a combination of both. The sort order must not change between two requests if records are also being manipulated (INSERT/DELETE/UPDATE)."}),"\n",(0,t.jsx)(n.p,{children:"You can implement pagination in different ways, depending on the type of service you want to provide, on how fast the data set is growing, on the type of data that the service provides, and on the user experience that you want to create."}),"\n",(0,t.jsx)(n.h2,{id:"offset-pagination",children:"Offset pagination"}),"\n",(0,t.jsx)(n.p,{children:"This is the simplest type of pagination. It uses offset and limit settings to divide the result data set into different pages or sections."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Example 1"})}),"\n",(0,t.jsx)(n.p,{children:"This example retrieves the first 50 items of the result set."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"GET /items?limit=50\n\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Example 2"})}),"\n",(0,t.jsx)(n.p,{children:"This example retrieves the 2nd page of a result set divided into pages or sections of 50 items each."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"GET /items?offset=50&limit=50\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Advantages"})," of offset pagination are:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Offset pagination is easy to implement."}),"\n",(0,t.jsx)(n.li,{children:"Offset pagination does not require model change."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Disadvantages"})," of offset pagination are:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The performance decreases for large offset values."}),"\n",(0,t.jsx)(n.li,{children:"The pagination is not consistent when items are inserted or deleted. For example, when a record is deleted from the previous page while a client is paginating, all the records will be shifted forward by one. Then, when the client is asking for the next page, one record will be skipped. Also, when items are sorted in such a way that the last inserted item appears first, when a record is inserted, existing other rows will be shifted backward. Then, when the client asks for the next page, the request will return a record already fetched in the previous page."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In relation to offset pagination, see also Limiting the number of records returned by a REST service."}),"\n",(0,t.jsx)(n.h2,{id:"keyset-pagination",children:"Keyset pagination"}),"\n",(0,t.jsx)(n.p,{children:"Keyset pagination uses an indexed column for pagination. Values in this column determine where the next page starts, or the previous page ends. The indexed column must be unique, orderable, and not updatable."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Example 1"})}),"\n",(0,t.jsx)(n.p,{children:"This example retrieves the first 50 items of the result set."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"GET /items?limit=50\n\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Example 2"})}),"\n",(0,t.jsx)(n.p,{children:"This example retrieves the 2nd page of a result set divided into sections (pages) of 50 items each. The client must be able to extract the 'created' date value from the previous request."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"GET /items?created=2019-01-01T00:00:00&limit=50\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Instead of being set by the client during the request, the ",(0,t.jsx)(n.strong,{children:"limit"})," value may be hard-coded or configurable on the server side. In this case, the client cannot choose the size of the page. The page size is determined on the server side. Requests are as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"GET /items\nGET /items?created=2019-01-01T00:00:00&next\nGET /items?created=2019-05-01T00:00:00&previous\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Advantages"})," of keyset pagination are:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The performance of keyset pagination is consistent."}),"\n",(0,t.jsx)(n.li,{children:"Keyset pagination continues to return consistent results when records are inserted or deleted."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Disadvantages"})," of keyset pagination are:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The client cannot jump to a random page without first visiting all the previous ones to find the maximum value of the indexed column."}),"\n",(0,t.jsx)(n.li,{children:"Documentation is needed to specify the indexed column of the API"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);