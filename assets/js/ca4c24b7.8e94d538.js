"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[94007],{1383:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"Repositories/Modular_development/Modules_as_a_concept","title":"Modules as a concept","description":"USoft allows you to develop modular applications (modules) that you can deploy as part of one or more other USoft applications. These other applications are consumers of the module functionality. The modules themselves are the providers of the functionality.","source":"@site/docs/Repositories/Modular_development/Modules_as_a_concept.md","sourceDirName":"Repositories/Modular_development","slug":"/Repositories/Modular_development/Modules_as_a_concept","permalink":"/udocs/Repositories/Modular_development/Modules_as_a_concept","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Modules_as_a_concept"},"sidebar":"sidebar","previous":{"title":"Modular development","permalink":"/udocs/Repositories/Modular_development"},"next":{"title":"Interface objects","permalink":"/udocs/Repositories/Modular_development/Interface_objects"}}');var a=o(74848),i=o(28453);const s={id:"Modules_as_a_concept"},r="Modules as a concept",l={},c=[{value:"Why modules?",id:"why-modules",level:2},{value:"A word of caution",id:"a-word-of-caution",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Adding a module to an application",id:"adding-a-module-to-an-application",level:2},{value:"Interface objects and synchronisation",id:"interface-objects-and-synchronisation",level:2},{value:"Exposing an interface to an application",id:"exposing-an-interface-to-an-application",level:2}];function d(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"modules-as-a-concept",children:"Modules as a concept"})}),"\n",(0,a.jsxs)(t.p,{children:["USoft allows you to develop modular applications (",(0,a.jsx)(t.strong,{children:"modules"}),") that you can deploy as part of one or more other USoft applications. These other applications are ",(0,a.jsx)(t.em,{children:"consumers"})," of the module functionality. The modules themselves are the ",(0,a.jsx)(t.em,{children:"providers"})," of the functionality."]}),"\n",(0,a.jsx)(t.p,{children:"At runtime, the modules are merged into a single application. End users do not see providers and consumers."}),"\n",(0,a.jsx)(t.h2,{id:"why-modules",children:"Why modules?"}),"\n",(0,a.jsx)(t.p,{children:"If you have clearly delineated functionality that is re-used by multiple consumers, modules solve the problem of having to do double work to maintain duplicates.\nAnother problem that modules may be able to solve, is that when you have a single, large repository, you must always release it as a whole. Small projects may have to wait for larger projects to complete. Modules make you more flexible: you can develop and deploy a module relatively independently of its consumers."}),"\n",(0,a.jsx)(t.h2,{id:"a-word-of-caution",children:"A word of caution"}),"\n",(0,a.jsx)(t.p,{children:"Splitting a USoft application into modules is a big strategic decision that cannot be rolled back easily. It can yield lasting benefits in the long term. But to make modules a success, you also need to put in a great deal more project management and organisation effort than when you have a single USoft application."}),"\n",(0,a.jsx)(t.p,{children:"Every situation is different so it is difficult to give general guidelines. One driver for modularisation is that you already have a module that is used in a different application, and that you want to re-use. Another driver for modularisation is that you already know that you want to separable applications developed by distinct teams, and that it is better to connect the 2 at a later time."}),"\n",(0,a.jsxs)(t.p,{children:["In general, in greenfield situations it is ",(0,a.jsx)(t.strong,{children:"not"})," recommended to split the work in modules straight away because of the unnecessary overhead and because at the start, you are not in the best position to estimate how the material is best broken up into modules. It is much better to start with a single application. You can use object shopping facilities to separate the repositories into modules later, if necessary."]}),"\n",(0,a.jsx)(t.h2,{id:"architecture",children:"Architecture"}),"\n",(0,a.jsx)(t.p,{children:"Here is a picture of a consumer C of 2 modules M1 and M2. The picture shows 3 USoft applications (C, M1, M2). Each is developed in its own repository:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:o(49501).A+"",width:"649",height:"342"})}),"\n",(0,a.jsx)(t.p,{children:"\xa0"}),"\n",(0,a.jsx)(t.p,{children:'In Development, C refers to M1 and M2. To test-run the solution as a whole, module flatfiles must be available in the \\APP subdirectory of the local USoft installation directory. When you run Create Tables for C (for the C/S User Application in Development), you can see that not only C\'s "own" database tables are created, but also the tables described in the "M1.con" and "M2.con" flatfiles.'}),"\n",(0,a.jsx)(t.p,{children:"At release time, typically, flatfiles are also created for C, and the entire collection of flatfiles (for C, M1, M2) is deployed in Production."}),"\n",(0,a.jsx)(t.p,{children:"In Production, the runtime user of C is confronted with a single application. The modules are a separate reality only in Development, not in Production."}),"\n",(0,a.jsx)(t.h2,{id:"adding-a-module-to-an-application",children:"Adding a module to an application"}),"\n",(0,a.jsx)(t.p,{children:"To add an application M1 as a module (as a provider of functionality) to another USoft application C (the consumer):"}),"\n",(0,a.jsx)(t.p,{children:'1.\xa0\xa0 \xa0Develop M1 in its "own" repository.\n2. \xa0\xa0 Generate flat files for M1.\n3.\xa0\xa0 \xa0Copy these files to the \\APP directory of the USoft installation directory in the Development environment for C.\n4.\xa0\xa0 \xa0In USoft Definer for C, choose Tools, Manage Internal Interfaces, Modules from the main menu. The Application Modules window opens.\n5.\xa0\xa0 \xa0In the Module Name column, declare the module name (here: M1). Make sure Load Module = Yes (the default). Save work.\n\xa0\xa0 \xa0\xa0 When you next create application tables for C, the tables declared in "M1.con" are also created within C. They are visible when you choose View, Objects in the runtime C/S application.'}),"\n",(0,a.jsx)(t.h2,{id:"interface-objects-and-synchronisation",children:"Interface objects and synchronisation"}),"\n",(0,a.jsx)(t.p,{children:"It is one thing that C refers to the M1 application as a whole. This makes C a consumer of M1: M1 becomes part of the C application in Production, and also earlier, when C is test-run in Development or in Testing."}),"\n",(0,a.jsx)(t.p,{children:"It is another thing that C may be allowed to refer to specific M1 objects (domains, tables...). The C development team can only refer to M1 objects that have been made interface objects by the M1 development team."}),"\n",(0,a.jsx)(t.p,{children:"Interface objects are the equivalent of public classes in object-oriented programming. Non-interface objects are the equivalent of private classes. In the same way as in programming, interfaces allow developers of modules to expose certain objects whilst at the same time keeping other objects private. This way, dependencies between consumer and provider are minimised. This avoids communication overhead. It also makes the solution more flexible, easier to deploy, and less error-prone. This is particularly true if the number of interface objects can be kept to a minimum."}),"\n",(0,a.jsx)(t.p,{children:"USoft offers a number of synchronisation features to help the C development team refer to interface objects of M1 in a controlled way, and especially, to deal with changes in the interface. The C development team can synchronise the C application with a (new) module.con flatfile. Synchronisation advertises the M1 interface objects in the C repository, so that C developers can reference them, but also removes references to dropped interface objects. It also provides automatic listings of correct and no-longer-correct interfaces."}),"\n",(0,a.jsx)(t.h2,{id:"exposing-an-interface-to-an-application",children:"Exposing an interface to an application"}),"\n",(0,a.jsx)(t.admonition,{type:"warning",children:(0,a.jsx)(t.p,{children:"Consider carefully if you want to expose an interface to a consumer. There is no quick way of getting rid of all the interface objects if you decide you do not want them after all."})}),"\n",(0,a.jsx)(t.p,{children:"To expose an interface (= the entire collection of interface objects) defined in a module M1 to the Development environment of a consumer C:"}),"\n",(0,a.jsx)(t.p,{children:'1.\xa0\xa0 \xa0In the Development environment for M1, identify the objects (domains, tables...) that you want to be interface objects. Do this by setting Interface = Yes for these objects.\n2.\xa0\xa0 \xa0Make sure that M1 is known to C as a module. To do this, follow the earlier "Adding a module..." steps.\n3.\xa0\xa0 \xa0In USoft Definer for C, choose Tools, Manage Interface Interfaces, Consumed Interfaces.\n4.\xa0\xa0 \xa0On the Synchronization tab, type the Module name ("M1" in the example), then in the same record, in the "File to be used..." field, enter the filepath to the "M1.con" file that you want to be used as a basis for synchronisation.'}),"\n",(0,a.jsx)(t.p,{children:"If you do not provide an an absolute path, the Definer will look in the \\APP subfolder of the USoft installation folder. You are also allowed to use environment variables in this field, for example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"%SystemDir%\\app\\%USCurrentVersion%\\MyModule.CON\n"})}),"\n",(0,a.jsx)(t.p,{children:"5.\xa0\xa0 \xa0Read the Dialog text carefully. If you are sure you want to go ahead, click the Synchronize Internal Interfaces button.\n6.\xa0\xa0 \xa0Perform necessary actions to solve Incorrect Interfaces, if any."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>s,x:()=>r});var n=o(96540);const a={},i=n.createContext(a);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(i.Provider,{value:t},e.children)}},49501:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/002b72cd-b61d-4ca7-9471-c7704246560d-11454f175af21a4dc5f611a65efd4194.png"}}]);