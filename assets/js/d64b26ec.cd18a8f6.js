"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[40347],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var a=t(96540);const s={},o=a.createContext(s);function i(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(o.Provider,{value:n},e.children)}},61286:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"Extensions/RDMI_Components/Java_Enterprise_J2EE_components","title":"Java Enterprise (J2EE) components","description":"USoft Developer supports Java (Enterprise) components, referred to as J2EE components. USoft\'s support for components is realized using RDMI technology, in which methods of components can be invoked by rules, allowing USoft applications to interact with other applications.","source":"@site/docs/Extensions/RDMI_Components/Java_Enterprise_J2EE_components.md","sourceDirName":"Extensions/RDMI_Components","slug":"/Extensions/RDMI_Components/Java_Enterprise_J2EE_components","permalink":"/udocs/Extensions/RDMI_Components/Java_Enterprise_J2EE_components","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Java_Enterprise_J2EE_components"},"sidebar":"sidebar","previous":{"title":"What is an RDMI component and how do you create one?","permalink":"/udocs/Extensions/RDMI_Components/What_is_an_RDMI_component_and_how_do_you_create_one"},"next":{"title":"Component parameters","permalink":"/udocs/Extensions/RDMI_Components/Component_parameters"}}');var s=t(74848),o=t(28453);const i={id:"Java_Enterprise_J2EE_components"},r="Java Enterprise (J2EE) components",c={},h=[{value:"Defining a method",id:"defining-a-method",level:2},{value:"Passing arguments to methods",id:"passing-arguments-to-methods",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Debugging J2EE components",id:"debugging-j2ee-components",level:2},{value:"Method lookup wizard",id:"method-lookup-wizard",level:2},{value:"Method invocation syntax",id:"method-invocation-syntax",level:2},{value:"Typecasts",id:"typecasts",level:2}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"java-enterprise-j2ee-components",children:"Java Enterprise (J2EE) components"})}),"\n",(0,s.jsx)(n.p,{children:"USoft Developer supports Java (Enterprise) components, referred to as J2EE components. USoft's support for components is realized using RDMI technology, in which methods of components can be invoked by rules, allowing USoft applications to interact with other applications."}),"\n",(0,s.jsx)(n.p,{children:"The choice to support Java is based upon the ease of use of the Java language, the versatility and completeness of the available class libraries and the possibility of running Java components in a scalable architecture (Enterprise Java Beans, or EJB). Another advantage of Java is that the Java runtime environment is supported on nearly all computer platforms. This is important since the USoft Rules Engine is available on various platforms. In contrast to COM components, J2EE components can be invoked by Rules Engines running on any of the supported platforms."}),"\n",(0,s.jsx)(n.p,{children:"All the definitions for J2EE components that are to be used within an application are defined in the J2EE Components window in the Definer. Choose Define, RDMI, J2EE from the Definer menu bar to access this window."}),"\n",(0,s.jsx)(n.p,{children:"The J2EE Components window contains five tab pages. For help with completing the fields in these tab pages, use the Definer's What's this? help."}),"\n",(0,s.jsx)(n.p,{children:"In general, the first step when defining a RDMI J2EE component is the definition of the constructor, which specifies how the component is created by the Rules Engine at the time that it is needed. A constructor for an RDMI J2EE component is defined by using a method name that matches the name of the component itself."}),"\n",(0,s.jsx)(n.h2,{id:"defining-a-method",children:"Defining a method"}),"\n",(0,s.jsx)(n.p,{children:'\xa0Methods of RDMI J2EE components can have any name except the name of the component itself. The method names are in upper case. The physical methods chosen using the Method Lookup wizard can refer to class methods, instance methods, class fields, or instance fields. Class methods and fields are recognized by the Java package name in front of the method itself whereas instance methods and fields are recognized by the default instance name "this" in front of their method name. Some examples follow.'}),"\n",(0,s.jsx)(n.p,{children:"A physical class method:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"locale=java.util.Locale.getDefault()\n"})}),"\n",(0,s.jsx)(n.p,{children:"A physical instance method:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"this.parse(:0)\n"})}),"\n",(0,s.jsx)(n.p,{children:"A physical class field:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"datestyle=java.text.DateFormat.MEDIUM\n"})}),"\n",(0,s.jsx)(n.p,{children:"A physical instance field:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"max=this.MAX\n"})}),"\n",(0,s.jsx)(n.h2,{id:"passing-arguments-to-methods",children:"Passing arguments to methods"}),"\n",(0,s.jsx)(n.p,{children:'There are various ways to pass arguments from RDMI to J2EE component methods, literal values, placeholders and argument vectors. These are described in the "Method Invocation Syntax" section. The Method Lookup wizard automatically shows the type of argument (placeholder or argument vector) and converts the argument to a Java type.'}),"\n",(0,s.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,s.jsx)(n.p,{children:"The physical method calls use the same syntax as would be used in Java but limited to a single method invocation (e.g. object.toString() is allowed but object.toString().toLower() is not allowed)."}),"\n",(0,s.jsx)(n.p,{children:"The physical method syntax does not support formal declaration of objects. In other words, all variables assigned in the physical method syntax belong to the Java class: Object."}),"\n",(0,s.jsx)(n.h2,{id:"debugging-j2ee-components",children:"Debugging J2EE components"}),"\n",(0,s.jsx)(n.p,{children:"\xa0After defining a Java component in USoft, you may need to debug your component code, using an external debugging tool."}),"\n",(0,s.jsx)(n.p,{children:"When calling a Java component, USoft starts a Java Virtual Machine. The external debugger needs to communicate with this Java Virtual Machine. For debugging purposes, you need to start this JVM with additional startup parameters."}),"\n",(0,s.jsx)(n.p,{children:"The communication between debugger and the Java Virtual Machine uses a port number, for example: 8888. In this case, you need to specify the following resource setting in the usdiw file (for client-server applications), or in the usdi file (if the Rules Service is used):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"*java.vm.extraStartOptions: -Xdebug |\n-Xrunjdwp:transport=dt_socket,address=8888,server=y,suspend=n\n\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"You can also specify other startup parameters for the Java Virtual Machine. Refer to your Java documentation for details."})}),"\n",(0,s.jsx)(n.h2,{id:"method-lookup-wizard",children:"Method lookup wizard"}),"\n",(0,s.jsx)(n.p,{children:"\xa0The definition of method calls at development time is made much easier by the Method Lookup Wizard. This wizard offers:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Lookup of Java archive files and Java packages."}),"\n",(0,s.jsx)(n.li,{children:"Lookup of available classes."}),"\n",(0,s.jsx)(n.li,{children:"Lookup of constructors, fields and method."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To use the Method Lookup Wizard:"}),"\n",(0,s.jsx)(n.p,{children:"1.\xa0From the Definer menu bar, choose Define, RDMI, J2EE Components."}),"\n",(0,s.jsx)(n.p,{children:"2.\xa0Execute a query to retrieve the component that you want to work with."}),"\n",(0,s.jsx)(n.p,{children:"3.\xa0Click the Lookup button next to Physical Method on the Method tab page. The first of the Method Lookup Wizard pages appears."}),"\n",(0,s.jsx)(n.p,{children:"The first page of the wizard allows you to select a Java package name or a Java archive name to limit the number of component classes that will be retrieved. If you supply a Java archive, that archive should be in the class path so that it is visible in the Definer. You can then select this archive name on the first wizard page."}),"\n",(0,s.jsx)(n.p,{children:"4.\xa0Click Next. The second Wizard page appears."}),"\n",(0,s.jsx)(n.p,{children:"The second wizard page displays all the class names that were selected using the first wizard page."}),"\n",(0,s.jsx)(n.p,{children:"5.\xa0From this list, one class can now be selected."}),"\n",(0,s.jsx)(n.p,{children:"6.\xa0Click Next. The third and final wizard page appears, displaying all fields, methods and class methods of the class selected in the previous step:"}),"\n",(0,s.jsx)(n.p,{children:"You can recognize the physical constructors of the Java components by their syntax. Their syntax is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:" this=new java-package-name.method-name(argument, ...)\n"})}),"\n",(0,s.jsx)(n.p,{children:"7.\xa0Select one of the methods and click Finish to insert the selected method into the Physical Method field of the J2EE Components window. This causes the current content (if any) to be overwritten. If this is not what you want, copy and paste the Method from the wizard to the Physical Method field."}),"\n",(0,s.jsx)(n.p,{children:"8.\xa0The method selected from the wizard passes RDMI parameters sequentially via placeholders. For example in:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"this=new com.usoft.connectors.Properties((U):0)\n"})}),"\n",(0,s.jsx)(n.p,{children:'The ":0" will pass the first parameter of the parameter. You can edit the method to pass parameters in a different order or to pass literal values. For example, a literal value (a file name in this example) could be passed as follows:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:' this=new com.usoft.connectors.Properties((U)"c:\\props")\n'})}),"\n",(0,s.jsx)(n.h2,{id:"method-invocation-syntax",children:"Method invocation syntax"}),"\n",(0,s.jsx)(n.p,{children:"\xa0This topic describes what is needed to define the methods of Java components for RDMI. You can use the Method Lookup wizard to retrieve the method definitions from Java classes."}),"\n",(0,s.jsx)(n.p,{children:"An imported Off the Shelf component can be used as an example of how the RDMI tables are populated. Choose Define, RDMI, J2EE from the Definer menu bar and in the resulting window you can see the syntax that physical method entries use to define the mapping for the methods of components."}),"\n",(0,s.jsx)(n.p,{children:"For calls to J2EE, this syntax is a very limited subset of the Java syntax itself."}),"\n",(0,s.jsx)(n.p,{children:"An RDMI method can map onto a single Java physical method in the same way that RDMI works for COM, but Java method calls always include either a class or an object reference. The syntax for the Java physical method is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"{ class | object } . physical-method-name\n"})}),"\n",(0,s.jsx)(n.p,{children:"All RDMI parameters are passed to the actual call without explicitly specifying them in the physical method (classic RDMI style). The mapping of argument types is:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"RDMI String -> Java String Object"}),"\n",(0,s.jsx)(n.li,{children:"RDMI long integer-> Java Integer Object"}),"\n",(0,s.jsx)(n.li,{children:"RDMI double -> Java Double Object"}),"\n",(0,s.jsx)(n.li,{children:"RDMI Date -> Java Util Date Object"}),"\n",(0,s.jsx)(n.li,{children:"RDMI Boolean -> Java Boolean Object"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"java.lang.System.getProperty()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Arguments can be explicitly passed via a placeholder that represents the RDMI variable. The syntax is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"{ class | object } . {physical-method-name} ( :n, :m ... )\n"})}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"java.lang.Integer.parseInt(:0)\n"})}),"\n",(0,s.jsx)(n.p,{children:"parses a string in argument :0 into an integer."}),"\n",(0,s.jsx)(n.p,{children:"Arguments can be casted to non-RDMI compliant Java types. The syntax is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"{ class | object } . physical-method-name ( (cast-specifier):argument, ... )\n"})}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"java.lang.Integer.toHexString((i):0)\n"})}),"\n",(0,s.jsx)(n.p,{children:"creates a hexadecimal representation of the integer in :0."}),"\n",(0,s.jsx)(n.p,{children:"Here the Integer is casted to a Java native integer. Without the cast, the native method would be called with a Java Integer Object as its argument. Java would return an invalid method call"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:'See "Typecasts" for more information on the use of typecasts in method invocation.'})}),"\n",(0,s.jsx)(n.p,{children:"Possible type casts are specified in the typecast appendix."}),"\n",(0,s.jsx)(n.p,{children:"Literal arguments are understood."}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'java.lang.Integer.toHex((i)"15")\n'})}),"\n",(0,s.jsx)(n.p,{children:"Return values of method calls can be assigned to transient objects instead of being returned as an RDMI result. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:' myfile=java.lang.File.createTempFile(:0, ".txt")\n'})}),"\n",(0,s.jsx)(n.p,{children:"The myfile object can be used during the lifetime of the RDMI object, so that, for example, another RDMI call can make the call:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:" myfile.exists()\n"})}),"\n",(0,s.jsx)(n.p,{children:"A single RDMI method can map on multiple physical methods. New lines separate the physical methods. The result passed to RDMI is the result of the last call that returns a result. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'myfile=java.lang.File.createTempFile(:0, ".txt")myfile.exists()\n\n'})}),"\n",(0,s.jsx)(n.p,{children:"All arguments may be passed into an array to a call as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"com.usoft.connectors.JdbcTable.InsertRow(argv)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.strong,{children:"argv"})," is mapped onto a Java Array of String objects ( ",(0,s.jsx)(n.strong,{children:"String[]"})," ).\xa0"]}),"\n",(0,s.jsx)(n.p,{children:"This syntax makes it easy to define generic components that inspect their arguments before processing them. This includes the possibility of using a variable number of arguments. For example, EAI table components can implement their QueryExe method by a physical method:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"somejavacomponent.QueryExe(argv)\n"})}),"\n",(0,s.jsx)(n.p,{children:"The somejavacomponent component, for example, processes its arguments by looping over the argument vector as in:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"for (int i=0; I < argv.length; I++) process(argv[i]);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"typecasts",children:"Typecasts"}),"\n",(0,s.jsx)(n.p,{children:"Arguments passed in RDMI methods often need to be typecast to an appropriate Java type. Typecasts serve to convert method call arguments to the appropriate Java types. They are applied in physical method definitions in RDMI component definitions. For example, one could pass a string containing an integer to a Java method in one of the following ways, in the RDMI physical method definition:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'new java.math.BigDecimal("10.123" )\n'})}),"\n",(0,s.jsx)(n.p,{children:"In the case above, the constructor method of BigDecimal is invoked to accept a string."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'new java.math.BigDecimal( (double)"10.123")\n'})}),"\n",(0,s.jsx)(n.p,{children:'In this case the constructor method of BigDecimal is invoked to accept a double. The typecast (double) converted the string "10.123" to a double and is passed as a double precision floating point number to the BigDecimal constructor.'}),"\n",(0,s.jsx)(n.p,{children:"More complex typecasts are also used. For example, consider a physical constructor that deploys a hashtable:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"my_hashtable=new java.util.Hashtable()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Whenever the hashtable itself is passed as an argument, either in a subsequent call to a Java method in the constructor or in another RDMI physical method definition, the argument has to be typecasted. The reason for this is that the newly created object my_hashtable is known to the RDMI system as a generic object and not as a hashtable. So in a subsequent call to a Java method, the \xa0my_hashtable object would be accessed and passed as in the following example, taken from the physical method of an RDMI component for the invocation of an enterprise Java bean:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"my_hashtable=new java.util.Hashtable()   \nmy_hashtable.put((O)javax.naming.Context.INITIAL_CONTEXT_FACTORY,(O):0)   \nmy_hasttable.put((O)javax.naming.Context.PROVIDER_URL,(O):1)   \nctx = new javax.naming.InitialContext((Hashtable)my_hashtable)\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this case, my_hashtable is created, populated and typecast and passed in the last line. Whether the typecast is needed depends on the argument definition in the invoked Java method, it may accept an Object, it may only accept a specific class. Note that :0 and :1 refer to the first and second RDMI arguments."}),"\n",(0,s.jsx)(n.p,{children:'The RDMI Java Invoker (internally this software package had the name "joker") software has a table with common typecasts and aliases for common typecasts. For example, a typecast (java.lang.Integer) is in this table but also the alias: (Integer) and (I). The basic typecast (int) has alias (i).'}),"\n",(0,s.jsx)(n.p,{children:"The Definer/RDMI/J2EE method lookup wizard automatically inserts the appropriate typecasts."}),"\n",(0,s.jsx)(n.p,{children:"The predefined typecasts can be listed using the following invocation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"com.usoft.joker.Joker.showCasts()\n"})}),"\n",(0,s.jsx)(n.p,{children:"To show the typecast list, this line can be added as a physical method to an RDMI component in the definer and the RDMI component method can be invoked in an application. Alternatively, the JVM Off The Shelf component contains a generic method to invoke methods in an application, Thus, adding JVM to a test application allows application time invocations of Java methods as shown in the following examples that can be run in SQL Command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"SELECT jvm.call( 'com.usoft.joker.Joker.showCasts() U' );\n"})}),"\n",(0,s.jsx)(n.p,{children:'Where the "U" at the end denotes that the result is supposed to be casted to a string, otherwise a Java Object would be returned.'}),"\n",(0,s.jsx)(n.p,{children:"It is possible to add typecasts to the typecast table, typically this would be applicable in a constructor of an RDMI component that uses the user-defined cast in one of its (physical) method definitions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"com.usoft.joker.Joker.addCast( user defined cast specification )\n"})}),"\n",(0,s.jsx)(n.p,{children:"For example, to add a typecast (my_string), type the following statement in SQL Command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"SELECT jvm.call ('com.usoft.joker.Joker.addCast(\"my_string:java.lang.String\")');\nSELECT jvm.call ('com.usoft.joker.Joker.showCast(\"my_string\") U')\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"To look up all casts associated with strings, using a regular expression, type the following in SQL Command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"SELECT jvm.call ('com.usoft.joker.Joker.showCast(\".*ring.*\") U')\n"})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);