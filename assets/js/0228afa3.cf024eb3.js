"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[29774],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(96540);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}},49359:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Lock_and_commit_management","title":"Lock and commit management","description":"To minimize potential lock conflicts, the Rules Engine tries to have records locked for a minimum of time. For restrictive checks where locking is necessary, the main strategy is that records are locked no sooner than at commit time, and that commit follows as soon as possible after the lock. The situations in which the Rules Engine locks records are:","source":"@site/docs/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Lock_and_commit_management.md","sourceDirName":"Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine","slug":"/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Lock_and_commit_management","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Lock_and_commit_management","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Lock_and_commit_management"},"sidebar":"sidebar","previous":{"title":"Preconditions and postconditions","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Preconditions_and_postconditions"},"next":{"title":"Startup constraints","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints_advanced_and_the_Rules_Engine/Startup_constraints"}}');var i=t(74848),s=t(28453);const r={id:"Lock_and_commit_management"},o="Lock and commit management",c={},l=[{value:"Smart locking",id:"smart-locking",level:2},{value:"Lock Parent on Sequence",id:"lock-parent-on-sequence",level:2},{value:"",id:"",level:2},{value:"Commit management",id:"commit-management",level:2}];function d(e){const n={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"lock-and-commit-management",children:"Lock and commit management"})}),"\n",(0,i.jsx)(n.p,{children:"To minimize potential lock conflicts, the Rules Engine tries to have records locked for a minimum of time. For restrictive checks where locking is necessary, the main strategy is that records are locked no sooner than at commit time, and that commit follows as soon as possible after the lock. The situations in which the Rules Engine locks records are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Because of user manipulation:"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"When the user deletes a record or changes a field value in a record, the record is immediately locked."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"At record validation time:"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"When cascading or nullifying update or delete rules take place, the child records are locked just after the parent record has been updated or deleted."}),"\n",(0,i.jsx)(n.p,{children:"When productive multi-record constraints apply, before the constraint manipulates a record, this record will be locked."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"At commit time:"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Just before the final foreign key checks and relationship cardinality checks are executed, the parent records are locked. If the record cannot be locked, then the integrity of the foreign key value is no longer guaranteed."}),"\n",(0,i.jsx)(n.p,{children:'Just before the final constraint tests take place for restrictive multi-record constraints, the driving table records of these constraints are locked. For details, see "Driving Tables".'}),"\n",(0,i.jsx)(n.h2,{id:"smart-locking",children:"Smart locking"}),"\n",(0,i.jsx)(n.p,{children:"Before sending a lock-record request to the database, the Rules Engine checks that the record has not already been locked in the current transaction. If it has, the lock-record request will not be sent to the database."}),"\n",(0,i.jsx)(n.p,{children:"If a lock has been obtained in the database, the locked record is stored in the local cache and is locally available for subsequent checks."}),"\n",(0,i.jsx)(n.h2,{id:"lock-parent-on-sequence",children:"Lock Parent on Sequence"}),"\n",(0,i.jsx)(n.p,{children:"If you have unique values generated for a key column that is itself the key, then USoft makes use of RDBMS sequence. This guarantees that each new generated value is unique.\nBut if values are generated for a column that is part of a key spanning multiple columns, then USoft internally issues a SQL statement with MAX( id ) + 1 to determine each new generated value. This applies notably when you have a child table with a primary key spanning (a) the foreign key referring to the parent, and (b) a generated ID to distinguish the children:"}),"\n",(0,i.jsx)(n.p,{children:"Parent Table: COUNTRY, Primary Key: (COUNTRY)"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsx)(n.tr,{children:(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"COUNTRY"})})})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsx)(n.tr,{children:(0,i.jsx)(n.td,{children:"France"})}),(0,i.jsx)(n.tr,{children:(0,i.jsx)(n.td,{children:"Germany"})})]})]}),"\n",(0,i.jsx)(n.h2,{id:"",children:"\xa0"}),"\n",(0,i.jsx)(n.p,{children:"Child Table: COUNTRY_BRANCH, Primary Key: (COUNTRY, BRANCH_ID)"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"COUNTRY"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"BRANCH_ID"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"LOCATION"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"France"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Paris"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Germany"}),(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"Berlin"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Germany"}),(0,i.jsx)(n.td,{children:"2"}),(0,i.jsx)(n.td,{children:"Frankfurt"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"\xa0"}),"\n",(0,i.jsx)(n.p,{children:"In this situation, 2 concurrent sessions manipulating the child table can run into problems if the same MAX( id ) + 1 value is generated for each session. This leads to a unique key violation.\nYou can prevent this by setting the LOCK_PARENT_ON_SEQUENCE Rules Engine Parameter to True. By default, this parameter is set to False."}),"\n",(0,i.jsx)(n.h2,{id:"commit-management",children:"Commit management"}),"\n",(0,i.jsx)(n.p,{children:"A given sequence of tasks (queries or data manipulations) can be performed as a single long transaction and then committed, or it can be performed with many commits in between."}),"\n",(0,i.jsx)(n.p,{children:"Related data manipulations should be in the same transaction so they can be committed or rolled back as a logical whole. As a developer, you determine for each part of the application whether it is the application design or the user that decides what is a logical whole."}),"\n",(0,i.jsx)(n.p,{children:"The main trade-off when deciding whether to commit often or not is between a few lock conflicts if many commits take place versus the possibility of rollback for longer transactions."}),"\n",(0,i.jsx)(n.p,{children:"In an application where minimization of lock conflicts is crucial and the difference between Store Record and commit is not, you may want to set the application property Auto-commit to Yes (default No). This causes the application to automatically call DataCommit() immediately after each Store Record."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);