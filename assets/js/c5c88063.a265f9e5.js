"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[52491],{16249:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"Task_flow/Decisions/Decision_branching_and_looping","title":"Decision branching and looping","description":"USoft uses SQL as its primary expression language. SQL has WHERE clauses for conditional behavior and functions such as DECODE( ) to select a value based on some output value, but it does not fully support branching and looping in the way that procedural languages do.","source":"@site/docs/Task_flow/Decisions/Decision_branching_and_looping.md","sourceDirName":"Task_flow/Decisions","slug":"/Task_flow/Decisions/Decision_branching_and_looping","permalink":"/udocs/Task_flow/Decisions/Decision_branching_and_looping","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Decision_branching_and_looping"},"sidebar":"sidebar","previous":{"title":"Decision variables and placeholders","permalink":"/udocs/Task_flow/Decisions/Decision_variables_and_placeholders"},"next":{"title":"Tasks","permalink":"/udocs/Task_flow/Tasks"}}');var s=i(74848),t=i(28453);const a={id:"Decision_branching_and_looping"},c="Decision branching and looping",r={},l=[];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"decision-branching-and-looping",children:"Decision branching and looping"})}),"\n",(0,s.jsx)(n.p,{children:"USoft uses SQL as its primary expression language. SQL has WHERE clauses for conditional behavior and functions such as DECODE( ) to select a value based on some output value, but it does not fully support branching and looping in the way that procedural languages do."}),"\n",(0,s.jsx)(n.p,{children:"With Decisions, you can combine SQL expressions with branching. Based on the outcome of a SQL statement, the application branches either into the Yes Action or the No action."}),"\n",(0,s.jsxs)(n.p,{children:["You can easily construct complex decision trees with repeated branching, because in the Yes Action and No Action scripts you can call sub-decisions using ",(0,s.jsx)(n.a,{href:"/udocs/Task_flow/Action_Language_reference_A-C/ActionDecision",children:"ActionDecision()"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"You can also achieve looping, because it is possible to call a decision from its own Yes Action. In addition, you can call a decision that you passed through earlier, which gives you repeated looping through the same sequence of decisions until some value is reached or computed."}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["It\u2019s easy to lapse into procedural programming in this area. Do not forget that you can write a Decision SQL statement that retrieves ",(0,s.jsx)(n.em,{children:"multiple rows"})," and that the Decision Yes Action is automatically executed for each of the retrieved rows, with the correct variable bindings. Prefer this kind of looping if it fulfills your need."]})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Decision Tree"})," and ",(0,s.jsx)(n.strong,{children:"Caller Tree"})," utilities in the Decisions window help you visualise and navigate structures of Decisions that call each other or themselves."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Example"})}),"\n",(0,s.jsx)(n.p,{children:"This example calls itself in the Yes Action until some result (in this case, a unique name) is reached, at which time it branches into the No Action."}),"\n",(0,s.jsx)(n.p,{children:"In the Decision SQL, the :1 and :2 placeholders are input parameters passed when the CP_PASTE_COMPONENT decision is called. In the circular calls made from the last line of the Yes Action script, they correspond to :1 and :2 in that line:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ActionDecision( CP_PASTE_COMPONENT, :1, :2 )\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the Yes Action, the :1 placeholder corresponds to the first value retrieved by SELECT (i.c., the string ",(0,s.jsx)(n.strong,{children:"COPY"}),"), and the :2 placeholder corresponds to the second value retrieved by SELECT. The No Action in this case has no placeholders, but it could use :1 and :2 in the same way as the Yes Action."]}),"\n",(0,s.jsx)(n.p,{children:"(Decision Name:)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"CP_PASTE_COMPONENT\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"(Decision SQL:)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:'/* Loop until we have a unique name */\nSELECT \xa0 \'COPY\'\n,        DECODE( :1, NULL, NULL, NVL(:2, 1) + 1 )\nFROM     T_RDMI_COMPONENT\nWHERE    COMPONENT_NAME = DECODE( \n             :1\n         ,   NULL\n         ,   :"globals.objectName"\n         ,   :"globals.objectNamePrefix" || :"globals.objectName" \n         )\n\n'})}),"\n",(0,s.jsx)(n.p,{children:"(Yes Action:)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ResourceFileUpdate( 'global.objectNamePrefix:' || :1 || :2 || '_' )\nActionDecision( CP_PASTE_COMPONENT, :1, :2 )\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"(No Action:)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ResourceFileUpdate( 'global.keyColumn:COMPONENT_NAME' )\nResourceFileUpdate( 'global.maxLength:100' )\nActionDecision(CP_PASTE_IMPORT)\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var o=i(96540);const s={},t=o.createContext(s);function a(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);