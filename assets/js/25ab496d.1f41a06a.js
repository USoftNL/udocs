"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[68466],{28453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var t=s(96540);const r={},o=t.createContext(r);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:n},e.children)}},38510:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"Modeller_and_Rules_Engine/SQL_syntax/Group_functions","title":"Group functions","description":"This article is about group functions as part of the SQL syntax that USoft supports.","source":"@site/docs/Modeller_and_Rules_Engine/SQL_syntax/Group_functions.md","sourceDirName":"Modeller_and_Rules_Engine/SQL_syntax","slug":"/Modeller_and_Rules_Engine/SQL_syntax/Group_functions","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_syntax/Group_functions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Group_functions"},"sidebar":"sidebar","previous":{"title":"Host variables in SQL","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_syntax/Host_variables_in_SQL"},"next":{"title":"SQL conditions","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_syntax/SQL_conditions"}}');var r=s(74848),o=s(28453);const i={id:"Group_functions"},l="Group functions",a={},u=[{value:"<strong>Group functions</strong>",id:"group-functions-1",level:2},{value:"Group functions and GROUP BY, HAVING",id:"group-functions-and-group-by-having",level:2},{value:"NULL input values",id:"null-input-values",level:2},{value:"NULL output values",id:"null-output-values",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"group-functions",children:"Group functions"})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["This article is about ",(0,r.jsx)(n.strong,{children:"group functions"})," as part of the ",(0,r.jsx)(n.a,{href:"/Modeller_and_Rules_Engine/SQL_syntax",children:"SQL syntax"})," that USoft supports."]})}),"\n",(0,r.jsx)(n.h2,{id:"group-functions-1",children:(0,r.jsx)(n.strong,{children:"Group functions"})}),"\n",(0,r.jsxs)(n.p,{children:["In SQL, a ",(0,r.jsx)(n.strong,{children:"group function"})," is a function that takes a set (or: group) of multiple column values from multiple rows as input, performs an aggregation, and then returns a single value."]}),"\n",(0,r.jsx)(n.p,{children:"This contrasts with inline functions or scalar functions. They operate on single values by modifying the input value and then returning the modified value."}),"\n",(0,r.jsx)(n.p,{children:"In the following query, perhaps 100 rows satisfy the WHERE clause. This causes a group of 100 amount values to be passed to MAX(). MAX( ) returns a single value."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT    MAX( amount )\nFROM      order\nWHERE     month = 'Feb 2020'\n"})}),"\n",(0,r.jsx)(n.p,{children:"The result of this query could be:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"499303900\n"})}),"\n",(0,r.jsx)(n.p,{children:'SQL has 7 group functions listed in the table below. The "empty-set result value\u201d is the value that is the result of applying the group function to an empty row set.'}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Group function"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Returns"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Empty-set result value"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"AVG( )"}),(0,r.jsx)(n.td,{children:"The average of the row values passed."}),(0,r.jsx)(n.td,{children:"The NULL value"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"COUNT( )"}),(0,r.jsx)(n.td,{children:"The number of rows passed (independently of values in those rows)."}),(0,r.jsx)(n.td,{children:"0 (zero)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"MAX( )"}),(0,r.jsx)(n.td,{children:"The greatest of the values passed."}),(0,r.jsx)(n.td,{children:"The NULL value"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"MIN( )"}),(0,r.jsx)(n.td,{children:"The least of the values passed."}),(0,r.jsx)(n.td,{children:"The NULL value"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"STDDEV( )"}),(0,r.jsx)(n.td,{children:"The standard deviation for the set of values passed."}),(0,r.jsx)(n.td,{children:"The NULL value"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SUM( )"}),(0,r.jsx)(n.td,{children:"The sum of the values passed."}),(0,r.jsx)(n.td,{children:"The NULL value"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"VARIANCE( )"}),(0,r.jsx)(n.td,{children:"The statistical variance for the set of values passed."}),(0,r.jsx)(n.td,{children:"The NULL value"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"group-functions-and-group-by-having",children:"Group functions and GROUP BY, HAVING"}),"\n",(0,r.jsx)(n.p,{children:"In the SELECT list of a SQL statement, you are allowed to mix expressions governed by a group function with other expressions, but only if those other expressions also appear in a GROUP BY clause at the end of the statement. Otherwise, it's an error. The following is a valid query:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT    usergroup\n,         COUNT( * ) number_of_members\nFROM      user\nGROUP BY  usergroup\n"})}),"\n",(0,r.jsx)(n.p,{children:"Any restrictive tests applied to the input of the group function must be expressed in the WHERE clause. Any restrictive tests applied to the output of the group function must be expressed in a HAVING clause, which is only legal after a GROUP BY clause."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Example"})}),"\n",(0,r.jsx)(n.p,{children:"This example returns the names and total number of members of those Australian usergroups that have more than 10 members."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT    usergroup\n,         COUNT( * ) number_of_members\nFROM      user\nWHERE     location = 'Australia'\nGROUP BY  usergroup\nHAVING    COUNT( * ) > 10\n"})}),"\n",(0,r.jsx)(n.h2,{id:"null-input-values",children:"NULL input values"}),"\n",(0,r.jsx)(n.p,{children:"Group functions ignore any NULL values passed to them. They operate only on the remaining (non-NULL) values. This may lead to unwanted results. Some RDBMSs (Oracle) warn restrictively against a query such as the following if a NULL value is passed to it:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT    department\n,         AVG( salary )\nGROUP BY  department\n"})}),"\n",(0,r.jsx)(n.h2,{id:"null-output-values",children:"NULL output values"}),"\n",(0,r.jsx)(n.p,{children:"As the table in this help topic shows in the rightmost column, group functions, with the exception of COUNT( ), output the NULL value if the set of rows passed to them is empty. In USoft constraint SQL, this is relevant: it may or may not be what you want. In the subquery of an UPDATE... SET ... constraint:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"WITHOUT the group function, the empty row set causes the constraint to be discarded (skipped): there is no effect on data."}),"\n",(0,r.jsx)(n.li,{children:"WITH the group function, the empty row set is replaced by the NULL value, which may cause the constraint to erase non-NULL values."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);