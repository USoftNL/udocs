"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[62870],{12174:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Modeller_and_Rules_Engine/Constraints/Deferred_table_constraints","title":"Deferred table constraints","description":"By default, a USoft Rules Engine determines internally when a constraint is activated. As a developer, you can concentrate on defining the constraint in terms of functionality. The Rules Engine guarantees that all the constraints you define will be activated at runtime in an optimal way, so that application data meet the quality standards defined by your constraints. This includes the order in time in which your constraints will be considered.","source":"@site/docs/Modeller_and_Rules_Engine/Constraints/Deferred_table_constraints.md","sourceDirName":"Modeller_and_Rules_Engine/Constraints","slug":"/Modeller_and_Rules_Engine/Constraints/Deferred_table_constraints","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints/Deferred_table_constraints","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Deferred_table_constraints"},"sidebar":"sidebar","previous":{"title":"Transitional constraint troubleshooting","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints/Transitional_constraint_troubleshooting"},"next":{"title":"Recursive constraints","permalink":"/udocs/Modeller_and_Rules_Engine/Constraints/Recursive_constraints"}}');var i=n(74848),r=n(28453);const a={id:"Deferred_table_constraints"},o="Deferred table constraints",c={},d=[{value:"Deferring constraints is an advanced feature",id:"deferring-constraints-is-an-advanced-feature",level:2},{value:"Which constraints may be deferred?",id:"which-constraints-may-be-deferred",level:2},{value:"Why defer?",id:"why-defer",level:2}];function l(e){const t={em:"em",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"deferred-table-constraints",children:"Deferred table constraints"})}),"\n",(0,i.jsxs)(t.p,{children:["By default, a USoft Rules Engine determines internally when a constraint is activated. As a developer, you can concentrate on defining the constraint in terms of functionality. The Rules Engine guarantees that all the constraints you define will be activated at runtime in an optimal way, so that application data meet the quality standards defined by your constraints. This includes the ",(0,i.jsx)(t.em,{children:"order in time"})," in which your constraints will be considered."]}),"\n",(0,i.jsx)(t.p,{children:"For details on how the Rules Engine processes constraints, go to Constraint evaluation order."}),"\n",(0,i.jsxs)(t.p,{children:["By way of exception, you can ",(0,i.jsx)(t.em,{children:"defer"})," the action of a table constraint to the time just before or just after the transaction's commit. Do this by setting the Deferred constraint attribute:"]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:(0,i.jsx)(t.strong,{children:"Deferred, options"})}),(0,i.jsx)(t.th,{children:(0,i.jsx)(t.strong,{children:"Description"})})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Do Not Defer (the default)"}),(0,i.jsx)(t.td,{children:"The constraint action is active at the time of data manipulation."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Until Commit"}),(0,i.jsxs)(t.td,{children:["The constraint action is deferred until just ",(0,i.jsx)(t.em,{children:"before"})," the transaction is committed."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Post Commit"}),(0,i.jsxs)(t.td,{children:["The constraint action is deferred until just ",(0,i.jsx)(t.em,{children:"after"})," the transaction is committed, ie., it executes as the first step of the following transaction."]})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"deferring-constraints-is-an-advanced-feature",children:"Deferring constraints is an advanced feature"}),"\n",(0,i.jsx)(t.p,{children:'Deferring constraints is an advanced feature. As a developer, you should not normally be concerned about constraint deferral. Keep the default Deferred = "Do Not Defer" unless you have special reasons.'}),"\n",(0,i.jsx)(t.h2,{id:"which-constraints-may-be-deferred",children:"Which constraints may be deferred?"}),"\n",(0,i.jsxs)(t.p,{children:["You can defer ",(0,i.jsx)(t.strong,{children:"productive, non-transitional"})," table constraints to either ",(0,i.jsx)(t.strong,{children:"Until Commit"})," or ",(0,i.jsx)(t.strong,{children:"Post Commit"}),". This includes INVOKE constraints: for example, you can invoke a constraint that executes a call to the XML.IMPORT method."]}),"\n",(0,i.jsxs)(t.p,{children:["You can defer ",(0,i.jsx)(t.strong,{children:"restrictive, non-transitional, single-record"})," table constraints to ",(0,i.jsx)(t.strong,{children:"Until Commit"}),". You cannot defer restrictive constraints to Post Commit."]}),"\n",(0,i.jsx)(t.p,{children:"You cannot defer any transitional constraints."}),"\n",(0,i.jsx)(t.h2,{id:"why-defer",children:"Why defer?"}),"\n",(0,i.jsxs)(t.p,{children:["You may want to defer a ",(0,i.jsx)(t.strong,{children:"productive"})," constraint for ",(0,i.jsx)(t.strong,{children:"performance reasons."})," If your constraint (re)calculates a total and you only need this total to be available at the ",(0,i.jsx)(t.em,{children:"end"})," of a transaction, deferring the constraint Until Commit will cause it to execute only once instead of being recalculated multiple times as a knock-on effect of each individual change in subtotals."]}),"\n",(0,i.jsxs)(t.p,{children:["You may want to defer a ",(0,i.jsx)(t.strong,{children:"restrictive"})," constraint for ",(0,i.jsx)(t.strong,{children:"functional reasons."})," If you want to check that data satisfies some restrictive check AFTER all cascade-to-other corrections have been executed, but the check itself involves only looking at data in the record being processed, then by default USoft will evaluate the check as a row check (ie., at record-store time). What you want is evaluation as a transaction check (ie., at commit-time). You can force USoft to evaluate at commit-time by setting Deferred = Until Commit."]}),"\n",(0,i.jsxs)(t.p,{children:["A reason to set Deferred = Post Commit is to achieve ",(0,i.jsx)(t.em,{children:"transaction chaining."})," For a discussion, go to the Chained corrections help topic."]}),"\n",(0,i.jsx)(t.p,{children:"\xa0"})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(96540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);