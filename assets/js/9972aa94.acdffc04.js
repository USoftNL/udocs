"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[28979],{28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(96540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},31166:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"Modeller_and_Rules_Engine/Tuning_your_application/General_SQL_tuning_tips","title":"General SQL tuning tips","description":"Minimise the number of subqueries in SQL statements","source":"@site/docs/Modeller_and_Rules_Engine/Tuning_your_application/General_SQL_tuning_tips.md","sourceDirName":"Modeller_and_Rules_Engine/Tuning_your_application","slug":"/Modeller_and_Rules_Engine/Tuning_your_application/General_SQL_tuning_tips","permalink":"/udocs/Modeller_and_Rules_Engine/Tuning_your_application/General_SQL_tuning_tips","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"General_SQL_tuning_tips"},"sidebar":"sidebar","previous":{"title":"Rules Engine optimisation techniques","permalink":"/udocs/Modeller_and_Rules_Engine/Tuning_your_application/Rules_Engine_optimisation_techniques"},"next":{"title":"RDBMS and data connectivity","permalink":"/udocs/Modeller_and_Rules_Engine/RDBMS_and_data_connectivity"}}');var i=s(74848),r=s(28453);const a={id:"General_SQL_tuning_tips"},o="General SQL tuning tips",l={},d=[{value:"Minimise the number of subqueries in SQL statements",id:"minimise-the-number-of-subqueries-in-sql-statements",level:2},{value:"Compare join constructs and EXISTS constructs",id:"compare-join-constructs-and-exists-constructs",level:2},{value:"Avoid HAVING if you can use WHERE",id:"avoid-having-if-you-can-use-where",level:2},{value:"Avoid IN if you can use EXISTS",id:"avoid-in-if-you-can-use-exists",level:2},{value:"Avoid grouping (DISTINCT / GROUP BY)",id:"avoid-grouping-distinct--group-by",level:2},{value:"Group by parent columns",id:"group-by-parent-columns",level:2},{value:"Use table aliases",id:"use-table-aliases",level:2},{value:"Write SQL that uses indexes",id:"write-sql-that-uses-indexes",level:2}];function c(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"general-sql-tuning-tips",children:"General SQL tuning tips"})}),"\n",(0,i.jsx)(n.h2,{id:"minimise-the-number-of-subqueries-in-sql-statements",children:"Minimise the number of subqueries in SQL statements"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example"})}),"\n",(0,i.jsx)(n.p,{children:"Rewrite an SQL statement like the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"SELECT \xa0 \xa0...\nFROM \xa0 \xa0 \xa0Table1\nWHERE \xa0 \xa0 ColA =\n(\n \xa0 \xa0 \xa0 \xa0 \xa0SELECT \xa0 T2.ColA \xa0 \xa0 \n \xa0 \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 Table2 T2\n \xa0 \xa0 \xa0 \xa0 \xa0WHERE ...\n)\nAND \xa0 \xa0 \xa0 ColB =\n(\n \xa0 \xa0 \xa0 \xa0 \xa0SELECT \xa0 T2.ColB \n \xa0 \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 Table2 T2\n \xa0 \xa0 \xa0 \xa0 \xa0WHERE ...\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"SELECT \xa0 \xa0...\nFROM \xa0 \xa0 \xa0Table1\nWHERE \xa0 \xa0 (ColA, ColB) =\n(\n \xa0 \xa0 \xa0 \xa0 \xa0SELECT \xa0 \xa0T2.ColA\n \xa0 \xa0 \xa0 \xa0 \xa0, \xa0 \xa0 \xa0 \xa0 T2.ColB\n \xa0 \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 \xa0Table2 T2\n \xa0 \xa0 \xa0 \xa0 \xa0WHERE ...\n)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"compare-join-constructs-and-exists-constructs",children:"Compare join constructs and EXISTS constructs"}),"\n",(0,i.jsx)(n.p,{children:"At RDBMS level, joins are often faster than EXISTS constructs because, if there are no records in the joined table that satisfy the query, with joins this is detected at an early stage. However, EXISTS submitted to the Rules Engine supplies a number of optimization strategies."}),"\n",(0,i.jsx)(n.p,{children:"If a subquery can be executed separately of the main query (that is, the main table(s) queried are not referenced in the subquery) then use EXISTS rather than a join, because the Rules Engine will then be able to perform the subquery separately and be able to optimize."}),"\n",(0,i.jsx)(n.p,{children:"If a subquery cannot be executed separately to the main query (that is, the main table(s) queried are referenced in the subquery), then write a join if the tables are not too small and if the statement is processed on the server. Databases can almost always handle join statements faster than subqueries if the number of records is rather large."}),"\n",(0,i.jsx)(n.h2,{id:"avoid-having-if-you-can-use-where",children:"Avoid HAVING if you can use WHERE"}),"\n",(0,i.jsx)(n.p,{children:"If you can, avoid HAVING clauses. With HAVING, all records are fetched and sorted before a selection is made of the records that are really required."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example"})}),"\n",(0,i.jsx)(n.p,{children:"Rewrite an SQL statement like the following:"}),"\n",(0,i.jsx)(n.p,{children:"For all persons who have made reservations except the person with id 1, select the total price the person has paid."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"SELECT \xa0 \xa0made_by\n, \xa0 \xa0 \xa0 \xa0 SUM( price )\nFROM \xa0 \xa0 \xa0reservation r\nGROUP BY \xa0made_by\nHAVING \xa0 \xa0made_by != 1\n"})}),"\n",(0,i.jsx)(n.p,{children:"to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"SELECT \xa0 \xa0made_by\n, \xa0 \xa0 \xa0 \xa0 SUM( price )\nFROM \xa0 \xa0 \xa0reservation r\nWHERE \xa0 \xa0 made_by != 1\nGROUP BY \xa0made_by\n"})}),"\n",(0,i.jsx)(n.h2,{id:"avoid-in-if-you-can-use-exists",children:"Avoid IN if you can use EXISTS"}),"\n",(0,i.jsx)(n.p,{children:"Use (NOT) EXISTS instead of (NOT) IN whenever you can."}),"\n",(0,i.jsx)(n.p,{children:"Analyze cases where you only want a Yes/No answer (do records meet a particular condition or not?)."}),"\n",(0,i.jsx)(n.p,{children:"If you can use it, (NOT) EXISTS is always faster than (NOT) IN, because searching stops as soon as a record is (not) found."}),"\n",(0,i.jsx)(n.p,{children:"(NOT) IN causes records to be fetched and stored temporarily before the main query can be evaluated."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example"})}),"\n",(0,i.jsx)(n.p,{children:'Consider the business rule: "A reservation must have a participant with an insurance". Rewrite an SQL statement like the following:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"SELECT \xa0 \xa0'' violation\nFROM \xa0 \xa0 \xa0reservation r\nWHERE \xa0 \xa0 r.res_id NOT IN\n(\n \xa0 \xa0 \xa0 \xa0 \xa0SELECT \xa0 \xa0pt.res_id\n \xa0 \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 \xa0participant pt\n \xa0 \xa0 \xa0 \xa0 \xa0WHERE \xa0 \xa0 pt.res_id = r.res_id\n \xa0 \xa0 \xa0 \xa0 \xa0AND \xa0 \xa0 \xa0 pt.insurance = 'Y'\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"SELECT \xa0 \xa0'' violation\nFROM \xa0 \xa0 \xa0reservation r\nWHERE NOT EXISTS\n(\n \xa0 \xa0 \xa0 \xa0 \xa0SELECT \xa0 \xa0' '\n \xa0 \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 \xa0participant pt\n \xa0 \xa0 \xa0 \xa0 \xa0WHERE \xa0 \xa0 pt.res_id = r.res_id\n \xa0 \xa0 \xa0 \xa0 \xa0AND \xa0 \xa0 \xa0 pt.insurance = 'Y'\n)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"avoid-grouping-distinct--group-by",children:"Avoid grouping (DISTINCT / GROUP BY)"}),"\n",(0,i.jsx)(n.p,{children:"If you do not need group information such as SUM, then avoid grouping."}),"\n",(0,i.jsx)(n.p,{children:"In a way comparable to GROUP BY... HAVING, the DISTINCT keyword generally causes large sets of records to be cached for subsequent sorting. Avoid DISTINCT where possible. In the example, the RDBMS can move to the next set of records of the schedtour table as soon as the subquery has been satisfied once."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example"})}),"\n",(0,i.jsx)(n.p,{children:"Rewrite an SQL statement like the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"SELECT \xa0 \xa0DISTINCT st.schedtour_id\nFROM \xa0 \xa0 \xa0schedtour st\n, \xa0 \xa0 \xa0 \xa0 reservation r\nWHERE \xa0 \xa0 s.schedtour_id = r.schedtour_id\n"})}),"\n",(0,i.jsx)(n.p,{children:"to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"SELECT \xa0 \xa0st.schedtour_id\nFROM \xa0 \xa0 \xa0schedtour st\nWHERE EXISTS\n(\n \xa0 \xa0 \xa0 \xa0 \xa0SELECT \xa0 \xa0''\n \xa0 \xa0 \xa0 \xa0 \xa0FROM \xa0 \xa0 \xa0reservation r\n \xa0 \xa0 \xa0 \xa0 \xa0WHERE \xa0 \xa0 s.schedtour_id = r.schedtour_id\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"The first statement with DISTINCT retrieves all IDs of scheduled tours for which at least one corresponding reservation exists. It does this by first performing a join, and then grouping by the primary key value."}),"\n",(0,i.jsx)(n.p,{children:"Instead of the DISTINCT keyword, the same query could be formulated as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"GROUP BY st.schedtour_id\n"})}),"\n",(0,i.jsx)(n.p,{children:"Both the DISTINCT and the GROUP BY version are slow, because grouping must be executed before the result can be delivered."}),"\n",(0,i.jsx)(n.p,{children:"With the EXISTS construct, the RDBMS only needs to scan the SCHEDTOUR table once. For each scheduled tour record, it can decide to add it to the result list as soon as a corresponding child record is found, and then move to the next scheduled tour record. Scheduled tour records do not need to be buffered, since no grouping needs to take place."}),"\n",(0,i.jsx)(n.h2,{id:"group-by-parent-columns",children:"Group by parent columns"}),"\n",(0,i.jsx)(n.p,{children:"Where possible, use GROUP BY with columns of a parent table instead of a child table."}),"\n",(0,i.jsx)(n.p,{children:"In the example, you cannot avoid using HAVING. The RDBMS needs to join the tables before it can decide which scheduled tours have a total price to be paid of more than 1000. The result is the same whether you group by the primary key of the parent table or the foreign key of the child table. As a rule, always group by the primary key of the parent table. This is faster both at Rules Engine and RDBMS levels. Of course, this also holds for statements with subqueries."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example"})}),"\n",(0,i.jsx)(n.p,{children:"In general, use SQL statements like the following:"}),"\n",(0,i.jsx)(n.p,{children:"For each scheduled tour, if the total price to be paid is more than 1000, select the total price to be paid for all reservations."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"SELECT \xa0 \xa0 \xa0st.schedtour_id\n, \xa0 \xa0 \xa0 \xa0 \xa0 SUM(r.price)\nFROM \xa0 \xa0 \xa0 \xa0schedtour st\n, \xa0 \xa0 \xa0 \xa0 \xa0 reservation r\nWHERE \xa0 \xa0 \xa0 st.schedtour_id=r.schedtour_id\nGROUP BY \xa0 \xa0st.schedtour_id\nHAVING \xa0 \xa0 \xa0SUM( r.price ) >= 1000\n"})}),"\n",(0,i.jsx)(n.h2,{id:"use-table-aliases",children:"Use table aliases"}),"\n",(0,i.jsx)(n.p,{children:"Whenever SQL statements involve more than one table, use table aliases, and prefix all columns by them. This way the statement is parsed faster."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example"})}),"\n",(0,i.jsx)(n.p,{children:"In general, use SQL statements like the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"SELECT \xa0 \xa0T1.column\nFROM \xa0 \xa0 \xa0Table1 T1\n, \xa0 \xa0 \xa0 \xa0 Table2 T2\nWHERE \xa0 \xa0 T1.column = T2.column\n"})}),"\n",(0,i.jsx)(n.h2,{id:"write-sql-that-uses-indexes",children:"Write SQL that uses indexes"}),"\n",(0,i.jsx)(n.p,{children:"If possible, write SQL statements in a way that indexes can be used."}),"\n",(0,i.jsx)(n.p,{children:"When an index has been defined on one or more columns, there are a couple of situations where the index will not be used. For example, an index will not be used when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A column value is contained in a function call."}),"\n",(0,i.jsx)(n.li,{children:"A column value is contained in a calculation."}),"\n",(0,i.jsx)(n.li,{children:"Column values are concatenated."}),"\n",(0,i.jsx)(n.li,{children:"Column values are excluded (NOT, <> , != )."}),"\n",(0,i.jsx)(n.li,{children:"Column values are not the first within an index."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If an index has been defined on more than one column, values are indexed as concatenations of the values in the individual columns. Concatenation is in the order in which the columns are mentioned in the CREATE INDEX command."}),"\n",(0,i.jsx)(n.p,{children:'This means that any WHERE clause that implies a search for the entire indexed string, or for the first column(s) of the index ("front-end searches"), will make the index available.'}),"\n",(0,i.jsx)(n.p,{children:"Any WHERE clause that implies a search for the last part of the indexed string but not the front part, will NOT make the index available."}),"\n",(0,i.jsx)(n.p,{children:"Incidentally, this is also why LIKE 'A%' constructs make an index available whereas LIKE '%A' constructs (\"back-end search\") do not."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Examples"})}),"\n",(0,i.jsx)(n.p,{children:"Rewrite a WHERE clause like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"WHERE \xa0 \xa0SUBSTR(name,1,3) = 'AUS'\n"})}),"\n",(0,i.jsx)(n.p,{children:"to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"WHERE \xa0 \xa0name LIKE 'AUS%'\n"})}),"\n",(0,i.jsx)(n.p,{children:"Rewrite a WHERE clause like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"WHERE \xa0 \xa0price * 2.21026 < 1000\n"})}),"\n",(0,i.jsx)(n.p,{children:"to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"WHERE \xa0 \xa0price < 1000/2.21026\n"})}),"\n",(0,i.jsx)(n.p,{children:"Rewrite a WHERE clause like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"WHERE \xa0 \xa0ColA || ColB = 'ABC'\n"})}),"\n",(0,i.jsx)(n.p,{children:"to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"WHERE \xa0ColA='A' \xa0AND \xa0ColB='BC'\n"})}),"\n",(0,i.jsx)(n.p,{children:"Rewrite a WHERE clause like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"WHERE \xa0 \xa0amount != 0\n"})}),"\n",(0,i.jsx)(n.p,{children:"to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"WHERE \xa0 \xa0amount > 0\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);