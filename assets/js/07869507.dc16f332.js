"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[64075],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(96540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}},93276:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"Task_flow/External_sets/The_VARIABLE_file_format_in_external_sets","title":"The VARIABLE file format in external sets","description":"Records are terminated by a newline character.","source":"@site/docs/Task_flow/External_sets/The_VARIABLE_file_format_in_external_sets.md","sourceDirName":"Task_flow/External_sets","slug":"/Task_flow/External_sets/The_VARIABLE_file_format_in_external_sets","permalink":"/udocs/Task_flow/External_sets/The_VARIABLE_file_format_in_external_sets","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"The_VARIABLE_file_format_in_external_sets"},"sidebar":"sidebar","previous":{"title":"File formats in external sets","permalink":"/udocs/Task_flow/External_sets/File_formats_in_external_sets"},"next":{"title":"The CSV file format in external sets","permalink":"/udocs/Task_flow/External_sets/The_CSV_file_format_in_external_sets"}}');var i=n(74848),r=n(28453);const a={id:"The_VARIABLE_file_format_in_external_sets"},o="The VARIABLE file format in external sets",l={},h=[{value:"Notes",id:"notes",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"the-variable-file-format-in-external-sets",children:"The VARIABLE file format in external sets"})}),"\n",(0,i.jsx)(t.p,{children:"Records are terminated by a newline character."}),"\n",(0,i.jsx)(t.p,{children:"When you choose VARIABLE as the file format, USoft Batch will look for (import) or insert (export) commas as column separators in the external file."}),"\n",(0,i.jsx)(t.p,{children:"If a string contains a comma, a newline character, or a single quote, the string must be enclosed in single quotes. In other cases you may use the string delimiters if you wish, but they are not mandatory."}),"\n",(0,i.jsx)(t.p,{children:"For import tasks, single quotes in the import data must be represented as two quotes, one of which will be removed during the import process. For example the following record, consisting of two fields, can be successfully imported:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"1,'This is a single quote '' in the variable import data'"})}),"\n",(0,i.jsx)(t.p,{children:"If a field starts with the quote, USoft Batch assumes that it is a field enclosed in quotes. The field may then contain the quote doubled, as shown above, as well as the comma and newline characters."}),"\n",(0,i.jsx)(t.p,{children:"If the first character is not the quote, then the string may contain the quote, which should not be doubled, but it may not contain the comma or the newline character."}),"\n",(0,i.jsx)(t.p,{children:"When exporting, if the data contains the string delimiter, or record separator, USoft Batch encloses the data in string delimiters automatically, and every occurrence of the string delimiter is automatically escaped (doubled)."}),"\n",(0,i.jsx)(t.p,{children:"For external sets, the following fields are surrounded by the string delimiter (by default a single quote):"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["All fields with one of the following ",(0,i.jsx)(t.strong,{children:"data types"}),": CHAR, TEXT, DATE, SMALLDATE, VARCHAR, VARCHAR2"]}),"\n",(0,i.jsxs)(t.li,{children:["All fields of which the data contains the ",(0,i.jsx)(t.strong,{children:"string delimiter"})," (by default a single quote)."]}),"\n",(0,i.jsxs)(t.li,{children:["All fields of which the data contains the ",(0,i.jsx)(t.strong,{children:"column separator"})," (by default a comma)."]}),"\n",(0,i.jsxs)(t.li,{children:["All fields of which the data contains the ",(0,i.jsx)(t.strong,{children:"record separator"})," (by default a newline)."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Every occurrence of the string delimiter in the actual data is replaced by two consecutive string delimiters."}),"\n",(0,i.jsx)(t.h2,{id:"notes",children:"Notes"}),"\n",(0,i.jsx)(t.p,{children:"You can also specify a different string delimiter using the string_delimiter parameter. If you do this, you must remember that any string that then contains the (new) delimiter must itself be delimited using the new character, and that the character must be doubled inside the string (for import tasks). This applies to both CSV and VARIABLE file formats."}),"\n",(0,i.jsx)(t.p,{children:"For example, suppose that you have the following string in an import process:"}),"\n",(0,i.jsx)(t.p,{children:"\xa0"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"This is a percent % sign\n\n"})}),"\n",(0,i.jsx)(t.p,{children:"\xa0"}),"\n",(0,i.jsx)(t.p,{children:"If you now change the string delimiter to %, you must enclose the string in delimiters, and also code the symbol in the string twice, as follows:"}),"\n",(0,i.jsx)(t.p,{children:"\xa0"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"%This is a percent %% sign%\n\n"})}),"\n",(0,i.jsx)(t.p,{children:"\xa0"}),"\n",(0,i.jsx)(t.p,{children:"In the same way, if you change the column separator using the colsep parameter, you must allow for any strings that contain the new separator, and enclose them within the correct string delimiters. In this case, you do not need to double the symbol in the string."}),"\n",(0,i.jsx)(t.p,{children:"\xa0"})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);