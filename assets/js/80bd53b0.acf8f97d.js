"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[74283],{28453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>r});var t=n(96540);const i={},a=t.createContext(i);function l(e){const s=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(a.Provider,{value:s},e.children)}},82573:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>l,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"Repositories/Blend_directives/pcValidateSchemas","title":"pc:ValidateSchemas","description":"This article is about the pc:ValidateSchemas Blend directive.","source":"@site/docs/Repositories/Blend_directives/pcValidateSchemas.md","sourceDirName":"Repositories/Blend_directives","slug":"/Repositories/Blend_directives/pcValidateSchemas","permalink":"/udocs/Repositories/Blend_directives/pcValidateSchemas","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"pcValidateSchemas"},"sidebar":"sidebar","previous":{"title":"pc:USoftTempDir","permalink":"/udocs/Repositories/Blend_directives/pcUSoftTempDir"},"next":{"title":"pc:value-of","permalink":"/udocs/Repositories/Blend_directives/pcvalueof"}}');var i=n(74848),a=n(28453);const l={id:"pcValidateSchemas"},r="pc",c={},o=[{value:"<strong>pc</strong>",id:"pc-1",level:2},{value:"Example: Testing that XML is well-formed",id:"example-testing-that-xml-is-well-formed",level:2},{value:"Example: Testing that XML is schema-valid and well-formed",id:"example-testing-that-xml-is-schema-valid-and-well-formed",level:2},{value:"Example: Testing XML against multiple schemas",id:"example-testing-xml-against-multiple-schemas",level:2}];function m(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsxs)(s.h1,{id:"pc",children:["pc",":ValidateSchemas"]})}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:["This article is about the ",(0,i.jsxs)(s.strong,{children:["pc",":ValidateSchemas"]}),(0,i.jsx)(s.a,{href:"/Repositories/Blend_directives",children:" Blend directive"}),"."]})}),"\n",(0,i.jsx)(s.h2,{id:"pc-1",children:(0,i.jsxs)(s.strong,{children:["pc",":ValidateSchemas"]})}),"\n",(0,i.jsx)(s.p,{children:"Finds out whether an XML document is well-formed. If you provide XML schemas, finds out whether the XML document is valid according to one of these schemas."}),"\n",(0,i.jsx)(s.p,{children:"Returns an XML document reporting on the outcome."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.em,{children:"Syntax"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'<pc:ValidateSchemas\n    xml="*xml*"\n  [ attr="*xml-schema*" ... ]\n>\n'})}),"\n",(0,i.jsxs)(s.p,{children:["The required ",(0,i.jsx)(s.strong,{children:"xml"})," is the input XML document."]}),"\n",(0,i.jsx)(s.p,{children:"You can optionally specify one or more XML schemas. For these, you can use any attr attribute name, provided that the attribute names are unique."}),"\n",(0,i.jsx)(s.h2,{id:"example-testing-that-xml-is-well-formed",children:"Example: Testing that XML is well-formed"}),"\n",(0,i.jsx)(s.p,{children:'This example tests that the XML document stored in the "persons.xml" file is well-formed XML. If the XML is well-formed, the return value is:'}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-xml",children:'<ValidationResult valid="yes" errors="0" warnings="0" exceptions="0"/>\n'})}),"\n",(0,i.jsx)(s.p,{children:"If the XML is not well-formed, the return value will be a message such as the following:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"The 'persson' start tag on line 2 position 3 does not match the end tag of 'person'.Line 6, position 4.\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.em,{children:"Example"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-xml",children:'<example xmlns:pc="Processing.Command" pc:hideme="true">\n   <pc:assign-nodeset xml="persons.xml"/>\n   <pc:ValidateSchemas xml="{$xml}" />\n</example>\n'})}),"\n",(0,i.jsx)(s.h2,{id:"example-testing-that-xml-is-schema-valid-and-well-formed",children:"Example: Testing that XML is schema-valid and well-formed"}),"\n",(0,i.jsx)(s.p,{children:'This example tests that the XML document stored in the "persons.xml" file is schema-valid when checked against the schema in the "persons.xsd" file. In addition, it tests whether the XML is well-formed in itself (see the previous section). If the XML is both schema-valid and well-formed, the return value is:'}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-xml",children:'<ValidationResult valid="yes" errors="0" warnings="0" exceptions="0"/>\n'})}),"\n",(0,i.jsx)(s.p,{children:"If the XML is not schema-valid, the return value will be a message such as the following:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-xml",children:'<ValidationResult valid="no" errors="1" warnings="0" exceptions="0">\n   <Error Message="The element \'person\' has invalid child element \'age\'. List of possible elements expected: \'birthdate\'." SourceUri="" />\n</ValidationResult>\n'})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.em,{children:"Example"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-xml",children:'<example xmlns:pc="Processing.Command" pc:hideme="true">\n   <pc:assign-nodeset xml="persons.xml"/>\n   <pc:assign-nodeset xsd="persons.xsd"/>   \n   <pc:ValidateSchemas xml="{$xml}" xsd="{$xsd}"/>\n</example>\n'})}),"\n",(0,i.jsx)(s.h2,{id:"example-testing-xml-against-multiple-schemas",children:"Example: Testing XML against multiple schemas"}),"\n",(0,i.jsx)(s.p,{children:"This example tests whether an XML document is schema-valid against at least one of multiple schemas. If you supply multiple schemas, these must be disjunct: if the schemas overlap, so that an input document could be valid against either one or the other, it's an error. The example has disjunct schemas where one tests English-language and the other Dutch-language input XML."}),"\n",(0,i.jsx)(s.p,{children:"This example also illustrates how you can pass the XML schemas inline rather than in separate files."}),"\n",(0,i.jsx)(s.p,{children:"The example script below raises error:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-xml",children:'<ValidationResult valid="no" errors="0" warnings="0" exceptions="1">\n  <Exception message="The value \'male\' is invalid according to its schema type \'String\' - The Enumeration constraint failed." />\n</ValidationResult>\n'})}),"\n",(0,i.jsx)(s.p,{children:'given the following "persons.xml" file:'}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-xml",children:'<persons>\n   <person version="1.0" xmlns:xi="http://www.w3.org/2001/XMLSchema-instance">\n      <author>Brent Smith</author>\n      <gender>male</gender>\n      <birthdate>1988-01-24</birthdate>\n   </person>\n</persons>\n'})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.em,{children:"Example"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-xml",children:'<example xmlns:pc="Processing.Command" pc:hideme="true">\n   <pc:assign-string workingdir="{path:GetFullPath(\'.\')}" />\n   <pc:assign-nodeset this="{files:XmlFile(path:Combine($workingdir,\'persons.xml\'))}"/>\n   <pc:ValidateSchemas xml="{$this}" xsd1="{xs:schema[1]}" xsd2="{xs:schema[2]}">\n      <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">\n         <xs:element name="persons"/>\n         <xs:element name="person">\n            <xs:complexType>\n               <xs:sequence>\n                  <xs:element name="author"/>\n                  <xs:element name="gender" default="male">\n                     <xs:simpleType>\n                        <xs:restriction base="xs:string">\n                           <xs:enumeration value="M"/>\n                           <xs:enumeration value="F"/>\n                        </xs:restriction>\n                     </xs:simpleType>\n                  </xs:element>\n                  <xs:element name="birthdate">\n                     <xs:simpleType>\n                        <xs:restriction base="xs:date"/>\n                     </xs:simpleType>\n                  </xs:element>\n               </xs:sequence>\n               <xs:attribute name="version" use="required"/>\n            </xs:complexType>\n         </xs:element>\n      </xs:schema>\n      <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">\n         <xs:element name="personen"/>\n            <xs:element name="persoon">\n               <xs:complexType>\n                  <xs:sequence>\n                     <xs:element name="auteur"/>\n                     <xs:element name="geslacht" default="man">\n                        <xs:simpleType>\n                           <xs:restriction base="xs:string">\n                              <xs:enumeration value="man"/>\n                              <xs:enumeration value="vrouw"/>\n                           </xs:restriction>\n                        </xs:simpleType>\n                     </xs:element>\n                     <xs:element name="geboortedatum">\n                        <xs:simpleType>\n                           <xs:restriction base="xs:date"/>\n                        </xs:simpleType>\n                     </xs:element>\n                  </xs:sequence>\n                  <xs:attribute name="version" use="required"/>\n               </xs:complexType>\n            </xs:element>\n      </xs:schema>\n   </pc:ValidateSchemas>\n</example>\n'})}),"\n",(0,i.jsx)(s.p,{children:"\xa0"})]})}function d(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}}}]);