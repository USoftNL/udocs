"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[14880],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>d});var r=t(96540);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}},79437:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>d,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Extensions/RDMI_Components/Component_parameters","title":"Component parameters","description":"When you use RDMI, you are likely to pass parameters to the method and/or receive parameters back from the method. For each method call you need to determine:","source":"@site/docs/Extensions/RDMI_Components/Component_parameters.md","sourceDirName":"Extensions/RDMI_Components","slug":"/Extensions/RDMI_Components/Component_parameters","permalink":"/udocs/Extensions/RDMI_Components/Component_parameters","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Component_parameters"},"sidebar":"sidebar","previous":{"title":"Java Enterprise (J2EE) components","permalink":"/udocs/Extensions/RDMI_Components/Java_Enterprise_J2EE_components"},"next":{"title":"Component state","permalink":"/udocs/Extensions/RDMI_Components/Component_state"}}');var s=t(74848),a=t(28453);const o={id:"Component_parameters"},d="Component parameters",i={},l=[{value:"How parameters are passed to and from components",id:"how-parameters-are-passed-to-and-from-components",level:2},{value:"Parameter datatypes",id:"parameter-datatypes",level:2},{value:"Parameter modes",id:"parameter-modes",level:2}];function h(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"component-parameters",children:"Component parameters"})}),"\n",(0,s.jsx)(n.p,{children:"When you use RDMI, you are likely to pass parameters to the method and/or receive parameters back from the method. For each method call you need to determine:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The number of parameters you need."}),"\n",(0,s.jsx)(n.li,{children:"For each parameter, the mode of the parameter (In, Out, Return, or InList)."}),"\n",(0,s.jsx)(n.li,{children:"For each parameter, the data type of the parameter."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"how-parameters-are-passed-to-and-from-components",children:"How parameters are passed to and from components"}),"\n",(0,s.jsx)(n.p,{children:"How parameters are passed to and from components depends on the sequence number and kind of parameter, and on the SQL syntax that the INVOKE clause is used in. The following example illustrates this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"UPDATE \xa0MyTab1\nSET \xa0 \xa0 (col1, col2) =\n(\n \xa0 \xa0INVOKE \xa0 \xa0MyComponent.MyMethod WITH\n \xa0 \xa0SELECT \xa0 \xa0colX, colY, colZ \xa0 \xa0\n    FROM \xa0 \xa0 \xa0MyTab2\n)\n\n"})}),"\n",(0,s.jsx)(n.p,{children:'The following table shows the parameters defined for "MyMethod" and how they are used:'}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Par Seqno"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Par Name"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Par Kind"})}),(0,s.jsx)(n.th,{children:"**\xa0**"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"par1"}),(0,s.jsx)(n.td,{children:"In\xa0"}),(0,s.jsx)(n.td,{children:"Will be passed colX"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"par2"}),(0,s.jsx)(n.td,{children:"Out"}),(0,s.jsx)(n.td,{children:"Will go to col1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"par3"}),(0,s.jsx)(n.td,{children:"Return"}),(0,s.jsx)(n.td,{children:"Will go to col2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"par4"}),(0,s.jsx)(n.td,{children:"In\xa0"}),(0,s.jsx)(n.td,{children:"Will be passed colY"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"5"}),(0,s.jsx)(n.td,{children:"par5"}),(0,s.jsx)(n.td,{children:"In\xa0"}),(0,s.jsx)(n.td,{children:"Will be passed colZ"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"This example shows that the Return parameter is handled as if it were an Out parameter."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"This example shows the rules underpinning parameter use. It is usually a good idea to define In parameters before Out parameters, and Out parameters before the Return parameter."})}),"\n",(0,s.jsx)(n.h2,{id:"parameter-datatypes",children:"Parameter datatypes"}),"\n",(0,s.jsx)(n.p,{children:"The following datatypes are supported for method parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"String"}),"\n",(0,s.jsx)(n.li,{children:"Boolean"}),"\n",(0,s.jsx)(n.li,{children:"Date"}),"\n",(0,s.jsx)(n.li,{children:"Double"}),"\n",(0,s.jsx)(n.li,{children:"Long Integer"}),"\n",(0,s.jsx)(n.li,{children:"Variable"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Use Long Integer for integer numeric values. Use Double for non-integer numeric values."}),"\n",(0,s.jsx)(n.p,{children:"Use Variable only in combination with the InList parameter mode."}),"\n",(0,s.jsx)(n.p,{children:"The following rules are applied for boolean values used by components:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Numeric input values other than 0 are converted to boolean True."}),"\n",(0,s.jsx)(n.li,{children:"0 input value is converted to boolean False."}),"\n",(0,s.jsx)(n.li,{children:"'N' input value is converted to boolean False."}),"\n",(0,s.jsx)(n.li,{children:"'Y' input value is converted to boolean True."}),"\n",(0,s.jsx)(n.li,{children:"For any other input value an error message is generated."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If you use COM, the parameters that can have a NULL value must be defined as VARIANT in the source code. This is, for example, the case with the parameters of the QueryExe method of a table component."}),"\n",(0,s.jsx)(n.h2,{id:"parameter-modes",children:"Parameter modes"}),"\n",(0,s.jsx)(n.p,{children:"Four modes of RDMI parameters are supported: In, Out, Return, and InList."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Define In parameters for all parameters that are passed from the USoft application to the external component."}),"\n",(0,s.jsx)(n.li,{children:"Define a Return parameter for the value that is passed back from the component to USoft as a standard procedure. This value could be used to verify that an invocation has been successful, or it could be data that is used again by the USoft application, for example when the component is called to perform a complex calculation."}),"\n",(0,s.jsx)(n.li,{children:"Define Out parameters for all parameters passed back from the component to the USoft application, other than the Return parameter."}),"\n",(0,s.jsx)(n.li,{children:"Define one InList parameter for all non-mandatory (variable) parameters of a method."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You can define one InList parameter for all non-mandatory (variable) parameters of a method."}),"\n",(0,s.jsx)(n.p,{children:"For this InList parameter, define the Variable data type. There can only be one parameter with InList Mode, and this parameter must be the last one in the in-going parameter list."}),"\n",(0,s.jsx)(n.p,{children:"For COM components, the Variable data type is translated to VARIANT. For Java components, the Variable data type is an array of Objects."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Example:"})}),"\n",(0,s.jsx)(n.p,{children:"Suppose a CALCULATE component has a SUM method that adds up all parameters. The minimum number of parameters is two, and there is no maximum number. The statement:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"SELECT \xa0 Calculate.Sum( 2, 3 )\n"})}),"\n",(0,s.jsx)(n.p,{children:"must return: 5, and the statement:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"SELECT \xa0 Calculate.Sum( 2, 3, 7, 4 )\n"})}),"\n",(0,s.jsx)(n.p,{children:"must return: 16."}),"\n",(0,s.jsx)(n.p,{children:"For the SUM method, define parameters:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Seqno"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Name"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Mode"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Data Type"})})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"par1"}),(0,s.jsx)(n.td,{children:"In\xa0"}),(0,s.jsx)(n.td,{children:"Long Integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"par2"}),(0,s.jsx)(n.td,{children:"In\xa0"}),(0,s.jsx)(n.td,{children:"Long Integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"Result"}),(0,s.jsx)(n.td,{children:"Return"}),(0,s.jsx)(n.td,{children:"Long Integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"variables"}),(0,s.jsx)(n.td,{children:"InList"}),(0,s.jsx)(n.td,{children:"Variable"})]})]})]})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);