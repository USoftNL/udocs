"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[16125],{7963:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>c,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Services/Predefined_REST_services/Versioning_predefined_REST_services","title":"Versioning predefined REST services","description":"This help topic is about versioning predefined REST services. You can also version custom REST services.","source":"@site/docs/Services/Predefined_REST_services/Versioning_predefined_REST_services.md","sourceDirName":"Services/Predefined_REST_services","slug":"/Services/Predefined_REST_services/Versioning_predefined_REST_services","permalink":"/udocs/Services/Predefined_REST_services/Versioning_predefined_REST_services","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Versioning_predefined_REST_services"},"sidebar":"sidebar","previous":{"title":"URL query parameters in predefined REST Services","permalink":"/udocs/Services/Predefined_REST_services/URL_query_parameters_in_predefined_REST_Services"},"next":{"title":"Custom SOAP services","permalink":"/udocs/Services/Custom_SOAP_services"}}');var r=i(74848),t=i(28453);const c={id:"Versioning_predefined_REST_services"},o="Versioning predefined REST services",a={},d=[{value:"Logical Views",id:"logical-views",level:2},{value:"Rules-Based Logical Views",id:"rules-based-logical-views",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"versioning-predefined-rest-services",children:"Versioning predefined REST services"})}),"\n",(0,r.jsx)(n.p,{children:"\xa0"}),"\n",(0,r.jsx)(n.p,{children:"This help topic is about versioning predefined REST services. You can also version custom REST services."}),"\n",(0,r.jsx)(n.p,{children:"USoft predefined REST services offer simple, standard, default functionality. But the underlying data structures can still change."}),"\n",(0,r.jsx)(n.p,{children:'For example, you can use the USoft Table Resource to quickly build a standard interface for accessing data in a table T. But table T can change overtime: initially (in "Version 1"), it may have 2 columns, but at some point (in "Version 2") a 3rd column may be added to it.'}),"\n",(0,r.jsx)(n.p,{children:"When a data structure changes, you can continue to support multiple concurrent REST versions that connect to it. A typical way to achieve this is to use Logical Views but there are also other techniques."}),"\n",(0,r.jsx)(n.h2,{id:"logical-views",children:"Logical Views"}),"\n",(0,r.jsx)(n.p,{children:"You can create a Logical View as a REST-specific interface between the REST clients and the changing data structure."}),"\n",(0,r.jsx)(n.p,{children:"Do this by creating different Logical Views on table T for different versions. Use the version number in the Logical View Name:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Logical View: T_V1"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT \xa0 \xa0 column1\n, \xa0 \xa0 \xa0 \xa0 \xa0column2\nFROM \xa0 \xa0 \xa0 t\n\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Logical View: T_V2"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT \xa0 column\n, \xa0 \xa0 \xa0 \xa0column2\n, \xa0 \xa0 \xa0 \xa0column3\nFROM \xa0 \xa0 t\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Clients expecting Version 1 use a request URL of type:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"http://localhost:8090/myservice/myconnection/T_V1\n"})}),"\n",(0,r.jsx)(n.p,{children:"Clients expecting Version 2 use a request URL of type:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"http://localhost:8090/myservice/myconnection/T_V2\n"})}),"\n",(0,r.jsx)(n.p,{children:"Just to give another example, if column DEFINED was renamed to CONSOLIDATED in Version 2 for reasons unrelated to the REST interface, you can use an alias in a Logical View to shield clients from this change:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Logical View: T_V2"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT \xa0 \xa0column1\n, \xa0 \xa0 \xa0 \xa0 ...\n, \xa0 \xa0 \xa0 \xa0 consolidated \xa0defined\n...\n\n"})}),"\n",(0,r.jsx)(n.h2,{id:"rules-based-logical-views",children:"Rules-Based Logical Views"}),"\n",(0,r.jsx)(n.p,{children:"Letting REST clients talk to Logical Views instead of directly to the database tables introduces a lot of the flexibility that you need when versioning REST interfaces against a changing data structure. However, especially with POST and PUT HTTP verbs, you may need more sophisticated techniques. \xa0In this case, consider Rules-Based Logical Views. These views allow you to specify in USoft constraints what data manipulation must be executed in the background when a REST client attempts to manipulate data in the view."}),"\n",(0,r.jsx)(n.p,{children:'For more information, go to help topic " Designing REST-specific interfaces ".'}),"\n",(0,r.jsx)(n.p,{children:"\xa0"})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>o});var s=i(96540);const r={},t=s.createContext(r);function c(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);