"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[19889],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var s=t(96540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}},35504:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"Repositories/Blend_functions/stringsReplaceVariables","title":"strings:ReplaceVariables","description":"This article is about the strings:ReplaceVariables Blend function.","source":"@site/docs/Repositories/Blend_functions/stringsReplaceVariables.md","sourceDirName":"Repositories/Blend_functions","slug":"/Repositories/Blend_functions/stringsReplaceVariables","permalink":"/udocs/Repositories/Blend_functions/stringsReplaceVariables","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"stringsReplaceVariables"},"sidebar":"sidebar","previous":{"title":"strings:Replace","permalink":"/udocs/Repositories/Blend_functions/stringsReplace"},"next":{"title":"strings:REReplace","permalink":"/udocs/Repositories/Blend_functions/stringsREReplace"}}');var r=t(74848),a=t(28453);const i={id:"stringsReplaceVariables"},l="strings",c={},o=[{value:"<strong>strings</strong>",id:"strings-1",level:2},{value:"System-named attributes",id:"system-named-attributes",level:2},{value:"User-named attributes",id:"user-named-attributes",level:2},{value:"Pattern attributes for substitution based on regular expressions",id:"pattern-attributes-for-substitution-based-on-regular-expressions",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsxs)(n.h1,{id:"strings",children:["strings",":ReplaceVariables"]})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["This article is about the ",(0,r.jsxs)(n.strong,{children:["strings",":ReplaceVariables"]}),(0,r.jsx)(n.a,{href:"/Repositories/Blend_functions",children:" Blend function"}),"."]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#system-named-attributes",children:"System-named attributes"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#user-named-attributes",children:"User-named attributes"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#pattern-attributes-for-substitution-based-on-regular-expressions",children:"Pattern attributes for substitution based on regular expressions"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"strings-1",children:(0,r.jsxs)(n.strong,{children:["strings",":ReplaceVariables"]})}),"\n",(0,r.jsx)(n.p,{children:"In an input text, replaces all occurrences of a set of text strings, or matches of regular-expression patterns, by target values. The replacements required are provided as replacement instructions."}),"\n",(0,r.jsx)(n.p,{children:"Returns the replaced text."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Syntax"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Namespace declaration"})}),"\n",(0,r.jsx)(n.p,{children:"You need to declare this namespace only if you call the function directly from the USCSXSL component but outside Blend. In a Blend context (ublendit.exe, uscsxsl.blend()) the namespace is already declared in the Blend transformation, which is in xsl\\Util\\Batch.1.0.xsl in your USoft installation folder."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'xmlns:strings="USoft:Strings"\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Function call"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"strings:ReplaceVariables(\n*input-text*\n, *replace-instruction*\n  [{\n   , *name-attribute-name*\n   , *value-attribute-name*\n   , *pattern-attribute-name*\n  }]\n)\n\n*replace-instruction*  ::=\n\n  <*top-level-element*>\n    <*instruction-element   name-attribute  pattern-attribute   value-attribute*  />\n    <*instruction-element   name-attribute  pattern-attribute   value-attribute*  />\n    ...\n\n  </*top-level-element*>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The required ",(0,r.jsx)(n.em,{children:"input-text"})," is a regular text string, for example, a SQL statement."]}),"\n",(0,r.jsxs)(n.p,{children:["The required ",(0,r.jsx)(n.em,{children:"replace-instruction"})," is an XML fragment containing a single top-level-element and any number of child instruction-elements. 0 instruction elements is legal but will have no effect."]}),"\n",(0,r.jsxs)(n.p,{children:["You can pass input parameters to the replacement routine by using variable references in the ",(0,r.jsx)(n.em,{children:"replace-instruction"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["What each ",(0,r.jsx)(n.em,{children:"instruction-element"})," must look like depends on whether you are passing ",(0,r.jsx)(n.em,{children:"name-attribute-name, value-attribute-nam"}),"e and ",(0,r.jsx)(n.em,{children:"pattern-attribute-name"})," or not. Either NONE of these 3 arguments must be passed, or ALL 3 must be passed as single-quoted string literals, in which case the single-quoted empty string (\xa0''\xa0) is a valid option."]}),"\n",(0,r.jsx)(n.h2,{id:"system-named-attributes",children:"System-named attributes"}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.strong,{children:"none"})," of the 3 optional arguments is passed, each ",(0,r.jsx)(n.em,{children:"instruction-element"})," must have an attribute named NAME (with capitals) and an attribute named VALUE (with capitals)."]}),"\n",(0,r.jsx)(n.p,{children:'In place of the NAME attribute you can have a PATTERN attribute, or you can have both a NAME and a PATTERN attribute. See the "Pattern attributes" section later in this article.'}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Example"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<example xmlns:pc="Processing.Command" pc:hideme="true" >\n<pc:defs>\n     update book set published_in = \'English\' where author = \'English\'; update book set published_in = \'American\' where author = \'American\';\n</pc:defs>\n<pc:defs>\n   <Languages>\n      <LANGUAGE_CODE NAME="eng" VALUE="en"/>   \n        <LANGUAGE_CODE NAME="English" VALUE="eng-GB"/>\n        <LANGUAGE_CODE NAME="American" VALUE="eng-US"/>\n    </Languages>\n</pc:defs>\n<pc:assign-string   input_text=    "{//pc:defs[1]}"/>\n<pc:assign-nodeset  replacements=  "{//pc:defs[2]/*}"/>\n<pc:assign-string   replaced_text="{strings:ReplaceVariables($input_text,$replacements)}" />     \n\n<pc:value-of select="$replaced_text"/>\n\n</example>\n'})}),"\n",(0,r.jsx)(n.p,{children:"The result is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"update book set published_in = 'en-GB' where author = 'en-GB'; update book set published_in = 'en-US' where author = 'en-US';\n"})}),"\n",(0,r.jsx)(n.h2,{id:"user-named-attributes",children:"User-named attributes"}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.strong,{children:"all"})," of the 3 optional arguments are passed, each ",(0,r.jsx)(n.em,{children:"instruction-element"})," in ",(0,r.jsx)(n.em,{children:"replace-instruction"})," must have:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["an attribute by the name of ",(0,r.jsx)(n.em,{children:"name-attribute-name"}),", or an attribute by the name of ",(0,r.jsx)(n.em,{children:"pattern-attribute-name"}),", or both, and :"]}),"\n",(0,r.jsxs)(n.li,{children:["an attribute by the name of ",(0,r.jsx)(n.em,{children:"value-attribute-name"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Example"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<example xmlns:pc="Processing.Command" pc:hideme="true" >\n<pc:defs>\n     update book set published_in = \'English\' where author = \'English\'; update book set published_in = \'American\' where author = \'American\';\n</pc:defs>\n<pc:defs>\n   <Languages>\n      <LANGUAGE_CODE language="eng" code="en"/>   \n        <LANGUAGE_CODE language="English" code="eng-GB"/>\n        <LANGUAGE_CODE language="American" code="eng-US"/>\n    </Languages>\n</pc:defs>\n<pc:assign-string   input_text=    "{//pc:defs[1]}"/>\n<pc:assign-nodeset  replacements=  "{//pc:defs[2]/*}"/>\n<pc:assign-string   replaced_text="{strings:ReplaceVariables($input_text,$replacements, \'language\', \'code\', \'\')}" />     \n\n<pc:value-of select="$replaced_text"/>\n\n</example>\n'})}),"\n",(0,r.jsx)(n.p,{children:"The result is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"update book set published_in = 'en-GB' where author = 'en-GB'; update book set published_in = 'en-US' where author = 'en-US';\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pattern-attributes-for-substitution-based-on-regular-expressions",children:"Pattern attributes for substitution based on regular expressions"}),"\n",(0,r.jsxs)(n.p,{children:["The above examples showed simple string substitutions because ",(0,r.jsx)(n.em,{children:"pattern-attribute-name"})," was empty."]}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.em,{children:"pattern-attribute-name"})," is non-empty, then all text occurrences that match any of the values of ",(0,r.jsx)(n.em,{children:"pattern-attribute-name"})," (considered as regular-expression patterns) are replaced by the corresponding ",(0,r.jsx)(n.em,{children:"value-attribute-name"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If both ",(0,r.jsx)(n.em,{children:"name-attribute-name"})," and ",(0,r.jsx)(n.em,{children:"pattern-attribute-name"})," are non-empty, replacements on the basis of the regular-expression patterns occur first, followed by replacements on the basis of the hard-coded strings."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Example"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<example xmlns:pc="Processing.Command" pc:hideme="true" >\n<pc:defs>\n     ID: 18900, RGB: grey red; ID: 18901, RGB: gray red;\n</pc:defs>\n<pc:defs>\n   <colours>\n      <colour en="red" de="rot" />   \n      <colour en_pattern="gr[a|e]y" de="grau" />\n    </colours>\n</pc:defs>\n<pc:assign-string    input_text=    "{//pc:defs[1]}"/>\n<pc:assign-nodeset   replacements=  "{//pc:defs[2]/*}"/>\n<pc:assign-string    replaced_text="{strings:ReplaceVariables($input_text,$replacements, \'en\', \'de\', \'en_pattern\')}" />     \n\n<pc:value-of select="$replaced_text"/>\n\n</example>\n'})}),"\n",(0,r.jsx)(n.p,{children:"The result is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"ID: 18900, RGB: grau rot; ID: 18901, RGB: grau rot;\n"})}),"\n",(0,r.jsx)(n.p,{children:"\xa0"})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);