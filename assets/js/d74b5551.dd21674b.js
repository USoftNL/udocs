"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[40714],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(96540);const a={},o=i.createContext(a);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:t},e.children)}},98331:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Authorisation_and_access/Deployment_configurations/Optimize_Changed_Table","title":"Optimize_Changed_Table","description":"This article is about the Optimize_Changed_Tabledeployment configuration parameter.","source":"@site/docs/Authorisation_and_access/Deployment_configurations/Optimize_Changed_Table.md","sourceDirName":"Authorisation_and_access/Deployment_configurations","slug":"/Authorisation_and_access/Deployment_configurations/Optimize_Changed_Table","permalink":"/udocs/Authorisation_and_access/Deployment_configurations/Optimize_Changed_Table","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Optimize_Changed_Table"},"sidebar":"sidebar","previous":{"title":"Number_of_Update_Columns","permalink":"/udocs/Authorisation_and_access/Deployment_configurations/Number_of_Update_Columns"},"next":{"title":"Request_Log_Size","permalink":"/udocs/Authorisation_and_access/Deployment_configurations/Request_Log_Size"}}');var a=n(74848),o=n(28453);const s={id:"Optimize_Changed_Table"},r="Optimize_Changed_Table",d={},c=[{value:"<strong>Optimize_Changed_Table</strong>",id:"optimize_changed_table-1",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"optimize_changed_table",children:"Optimize_Changed_Table"})}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["This article is about the ",(0,a.jsx)(t.strong,{children:"Optimize_Changed_Table"}),(0,a.jsx)(t.a,{href:"/udocs/Authorisation_and_access/Deployment_configurations/Deployment_configuration_parameters",children:"deployment configuration parameter"}),"."]})}),"\n",(0,a.jsx)(t.h2,{id:"optimize_changed_table-1",children:(0,a.jsx)(t.strong,{children:"Optimize_Changed_Table"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"Allowed values"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"{ True | False }\n"})}),"\n",(0,a.jsx)(t.p,{children:"The underlined value is the USoft factory default. It applies if you have not set this deployment parameter to a different value."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"Context"})}),"\n",(0,a.jsx)(t.p,{children:"This parameter may be set for all 3 deployment configuration contexts: Client Server, RunBatch, and Rules Service."}),"\n",(0,a.jsx)(t.p,{children:"You can set this parameter in the Additional Parameters list at the bottom of the tab page for each context. To get there, in USoft Authorizer, choose Define, Deployment Configurations from the menu."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"Explanation"})}),"\n",(0,a.jsx)(t.p,{children:"This is where you specify that you want the Rules Engine to add, whenever possible, key conditions to multi-table constraint SQL statements even if it is not possible to find a path from the manipulated table to the driving table using standard join conditions."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"Background"})}),"\n",(0,a.jsx)(t.p,{children:"In order to process constraint SQL statements as fast as possible, the Rules Engine attempts to bind each statement to the constellation of records being manipulated by adding a condition that contains a key value. If the manipulated table is not the driving table, this optimization strategy is applied only if a path can be found from the manipulated table to the driving table via standard join conditions. A standard join condition is a SQL condition that has an is-equal operator ('=') joining columns from related tables (of the type 'table1.col1 = table2.col1'). Otherwise, the Rules Engine is reduced to sending the entire statement to the database without added conditions, which in terms of performance can be unattractive."}),"\n",(0,a.jsx)(t.p,{children:"This strategy can now be made to be applied more widely by setting the Optimize_Changed_Table additional parameter. If this parameter is set, the Rules Engine will also add extra key conditions in certain other situations where a path is found from the changed table to the driving table but not via standard join conditions, for example, in join conditions with added expressions (eg., of the type 'table1.col1 = table2.col1 + integer')."}),"\n",(0,a.jsx)(t.p,{children:"The optimization strategy is never applied when the manipulated table is under a NOT EXISTS operator, in a GROUP BY clause, or under an aggregation function."}),"\n",(0,a.jsx)(t.p,{children:"You need to ascertain (by comparing Benchmark profiles) if setting this parameter really gives you better performance. For example, if you have constraint SQL with many conditions connected by OR, separate statements will be construed for each of these conditions. In such cases it may be faster to forget the optimization strategy and send the entire statement to the database as-is."}),"\n",(0,a.jsx)(t.p,{children:"The effect of the parameter is limited by the fact that it may only be set application-wide, not for individual constraints. However, there are cases where its setting will resolve particular bottlenecks in your application."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);