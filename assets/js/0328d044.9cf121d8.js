"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[2846],{8334:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Repositories/Blend_functions/sqlDataTableSetExport","title":"sql:DataTableSetExport","description":"This article is about the sql:DataTableSetExport Blend function.","source":"@site/docs/Repositories/Blend_functions/sqlDataTableSetExport.md","sourceDirName":"Repositories/Blend_functions","slug":"/Repositories/Blend_functions/sqlDataTableSetExport","permalink":"/udocs/Repositories/Blend_functions/sqlDataTableSetExport","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"sqlDataTableSetExport"},"sidebar":"sidebar","previous":{"title":"service:ServiceState","permalink":"/udocs/Repositories/Blend_functions/serviceServiceState"},"next":{"title":"sql:SqlStmnt","permalink":"/udocs/Repositories/Blend_functions/sqlSqlStmnt"}}');var o=n(74848),i=n(28453);const a={id:"sqlDataTableSetExport"},r="sql",l={},c=[{value:"<strong>sql</strong>",id:"sql-1",level:2},{value:"Return format",id:"return-format",level:2},{value:"Behaviour with subtypes",id:"behaviour-with-subtypes",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsxs)(t.h1,{id:"sql",children:["sql",":DataTableSetExport"]})}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsxs)(t.p,{children:["This article is about the ",(0,o.jsxs)(t.strong,{children:["sql",":DataTableSetExport"]}),(0,o.jsx)(t.a,{href:"/Repositories/Blend_functions",children:" Blend function"}),"."]})}),"\n",(0,o.jsx)(t.h2,{id:"sql-1",children:(0,o.jsxs)(t.strong,{children:["sql",":DataTableSetExport"]})}),"\n",(0,o.jsxs)(t.p,{children:["Returns the contents of a set of zero or more tables in a USoft XML format that is re-importable by passing it to the XML.IMPORT method of the USoft XML internal component. This format may also be passed as an input format to <pc",":Compare","> for data comparisons."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"Syntax"})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"Namespace declaration"})}),"\n",(0,o.jsx)(t.p,{children:"You need to declare this namespace only if you call the function directly from the USCSXSL component but outside Blend. In a Blend context (ublendit.exe, uscsxsl.blend()) the namespace is already declared in the Blend transformation, which is in xsl\\Util\\Batch.1.0.xsl in your USoft installation folder."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'xmlns:sql="USoft:Sql"\n'})}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"Function call"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"sql:DataTableSetExport(\n*connection*\n,           *tableregexp*\n,           *outputfile*\n,           *conditions*\n)\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Connection and ",(0,o.jsx)(t.em,{children:"tableregexp"})," are required. ",(0,o.jsx)(t.em,{children:"Outputfile"})," and ",(0,o.jsx)(t.em,{children:"conditions"})," are optional."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.em,{children:"Connection"})," defines an application location by a combination of a database connection and a USoft application name, as used to define and run a Rules Service instance against this application location, and as exemplified below."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.em,{children:"Tableregexp"})," is a regular expression acting on table names. It can be used to restrict the output to a subset of tables matching the regular expression. If tableregexp is the empty string, the keyschema of all the tables is reported."]}),"\n",(0,o.jsxs)(t.p,{children:["If ",(0,o.jsx)(t.em,{children:"outputfile"})," is specified, the return value is written to the specified folder and file on the file system."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"Example"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-xml",children:'<root \n  xmlns:pc="Processing.Command" \n  xmlns:assign="Processing.Command.Assign">\n\n   <pc:RunRulesService waittime="10000"\n        user="MYNAME" pwd="MYPWD" rdbmstype="oracle" connection="XE" application="MYAPP"\n        owner="MYNAME"\n        assign:instance="/*/@id" />   \n\n  <pc:evaluate select="sql:DataTableSetExport($instance, \'.*\', \'c:\\temp\\myoutputfile.xml\', \'\')" />\n\n</root>\n'})}),"\n",(0,o.jsx)(t.h2,{id:"return-format",children:"Return format"}),"\n",(0,o.jsx)(t.p,{children:"The returned XML format looks like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-xml",children:'<?usoft-xml version="1.0" action="multi-tables-import" use-io-formats="no" verify-original-values="no" return-corrected-records ="yes"?>\n<MultiExport>\n  <object-name-plural-no-space documentName="object-name-plural">\n    <table-name column-name="column-value"> ... />\n\n   ...\n  </object-name-plural-no-space>\n\n ...\n</MultiExport>\n'})}),"\n",(0,o.jsx)(t.p,{children:"For example:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-xml",children:'<?usoft-xml version="1.0" action="multi-tables-import" use-io-formats="no" verify-original-values="no" return-corrected-records ="yes"?>\n<MultiExport>\n  <Hired_Employees documentName="Hired Employees">\n    <H_EMPLOYEE NAME="JONES" FIRST_NAME="Bill" ... />\n    <H_EMPLOYEE NAME="SMITH" FIRST_NAME="Ann" ... />\n  </Hired_Employees>\n  <Departments documentName="Departments">\n    <DEPARTMENT DEPTNAME="Finance" >\n    <DEPARTMENT DEPTNAME="Sales" >\n  ...\n</MultiExport>\n'})}),"\n",(0,o.jsx)(t.h2,{id:"behaviour-with-subtypes",children:"Behaviour with subtypes"}),"\n",(0,o.jsxs)(t.p,{children:["To minimise potential problems with the re-importability of the result of sql",":DataTableSetExport",", when you export a supertype table, only those supertype records for which all subtype indicators are set to N are exported."]}),"\n",(0,o.jsx)(t.p,{children:"At first sight, this behaviour seems to cause supertype data to be skipped. On the contrary, supertype data that have Y for at least 1 subtype are still included in the export (and thus also in a potential re-import) if you include the corresponding subtype table, since they are an integral part of the subtype data. Another way of saying this is that, if you export only a supertype table, supertype data of subtypes is not considered in-scope."}),"\n",(0,o.jsx)(t.p,{children:"Complex subtype constellations may not be automatically re-importable."})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(96540);const o={},i=s.createContext(o);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);