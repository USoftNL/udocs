"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[23585],{28453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>i});var s=o(96540);const t={},l=s.createContext(t);function a(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(l.Provider,{value:n},e.children)}},98693:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Repositories/Blend_functions/booleanflagsToBoolean","title":"booleanflags:ToBoolean","description":"This article is about the booleanflags:ToBoolean Blend function.","source":"@site/docs/Repositories/Blend_functions/booleanflagsToBoolean.md","sourceDirName":"Repositories/Blend_functions","slug":"/Repositories/Blend_functions/booleanflagsToBoolean","permalink":"/udocs/Repositories/Blend_functions/booleanflagsToBoolean","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"booleanflagsToBoolean"},"sidebar":"sidebar","previous":{"title":"booleanflags:Show","permalink":"/udocs/Repositories/Blend_functions/booleanflagsShow"},"next":{"title":"clipboard:GetText","permalink":"/udocs/Repositories/Blend_functions/clipboardGetText"}}');var t=o(74848),l=o(28453);const a={id:"booleanflagsToBoolean"},i="booleanflags",r={},c=[{value:"<strong>booleanflags</strong>",id:"booleanflags-1",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsxs)(n.h1,{id:"booleanflags",children:["booleanflags",":ToBoolean"]})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["This article is about the ",(0,t.jsxs)(n.strong,{children:["booleanflags",":ToBoolean"]}),(0,t.jsx)(n.a,{href:"/Repositories/Blend_functions",children:" Blend function"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"booleanflags-1",children:(0,t.jsxs)(n.strong,{children:["booleanflags",":ToBoolean"]})}),"\n",(0,t.jsx)(n.p,{children:'Attempts to convert a string to boolean true() or boolean false() by applying a special "flag-based string-to-boolean conversion" principle. This principle consists of using an internal list that is a mapping between string values and truth values.'}),"\n",(0,t.jsxs)(n.p,{children:["You can view this internal list by calling the booleanflags",":Show","() function. You can add to this list by calling the pc",":define-boolean-flags"," directive."]}),"\n",(0,t.jsx)(n.p,{children:'The "flag-based string-to-boolean conversion" principle contrasts with the XSLT 1.0 rules for string-to-boolean conversion, which state that any non-empty string converts to true() and only the empty string converts to false() .'}),"\n",(0,t.jsx)(n.p,{children:"The flag-based conversion is performed case-insensitively. If yes is associated to boolean true(), then so are Yes and YES."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Syntax"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Namespace declaration"})}),"\n",(0,t.jsx)(n.p,{children:"You need to declare this namespace only if you call the function directly from the USCSXSL component but outside Blend. In a Blend context (ublendit.exe, uscsxsl.blend()) the namespace is already declared in the Blend transformation, which is in xsl\\Util\\Batch.1.0.xsl in your USoft installation folder."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'xmlns:booleanflags="USoft:BooleanFlags"\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Function call"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"booleanflags:ToBoolean( *string* )\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The required ",(0,t.jsx)(n.em,{children:"string"}),' is the string value that you want to convert using "flag-based string-to-boolean conversion".']}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Example"})}),"\n",(0,t.jsx)(n.p,{children:'This example returns the text "Executed verbosely" if the runtime user passes one of the following on the command line:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"verbose=true\nverbose=yes\n"})}),"\n",(0,t.jsx)(n.p,{children:"but not if he passes one of the following, or nothing at all:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"verbose=false\nverbose=no\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The booleanflags",":ToBoolean",'() function is necessary to get this behaviour. If it were omitted, the text "Executed verbosely" would always appear because the test would be whether or not the verbose variable had a non-empty string as a value. This is always the case because of the pc',":assign-string-default"," line."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<example xmlns:pc="Processing.Command">\n  <pc:assign-string-default verbose="no"/>\n  <pc:if-then test="booleanflags:ToBoolean($verbose)">\n      Executed verbosely\n  </pc:if-then>\n</example>\n'})}),"\n",(0,t.jsx)(n.p,{children:"\xa0"})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);