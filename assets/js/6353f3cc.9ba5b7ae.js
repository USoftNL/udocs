"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[83333],{28453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>a});var o=t(96540);const i={},s=o.createContext(i);function r(n){const e=o.useContext(s);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),o.createElement(s.Provider,{value:e},n.children)}},55736:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"Extensions/USCSXSL_internal_component/USCSXSL_internal_component","title":"USCSXSL internal component","description":"This article contains general information about the USCSXSL internal component.","source":"@site/docs/Extensions/USCSXSL_internal_component/USCSXSL_internal_component.md","sourceDirName":"Extensions/USCSXSL_internal_component","slug":"/Extensions/USCSXSL_internal_component/","permalink":"/udocs/Extensions/USCSXSL_internal_component/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"USCSXSL_internal_component"},"sidebar":"sidebar","previous":{"title":"USCSXSL internal component","permalink":"/udocs/Extensions/USCSXSL_internal_component"},"next":{"title":"USCSXSL.Apply","permalink":"/udocs/Extensions/USCSXSL_internal_component/USCSXSLApply"}}');var i=t(74848),s=t(28453);const r={id:"USCSXSL_internal_component"},a="USCSXSL internal component",l={},c=[{value:"What is it?",id:"what-is-it",level:2},{value:"Intended use",id:"intended-use",level:2},{value:"Encoding",id:"encoding",level:2}];function d(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"uscsxsl-internal-component",children:"USCSXSL internal component"})}),"\n",(0,i.jsx)(e.admonition,{type:"note",children:(0,i.jsxs)(e.p,{children:["This article contains general information about the ",(0,i.jsx)(e.strong,{children:"USCSXSL"})," internal component.\nFor an alphabetic list of USCSXSL methods, click ",(0,i.jsx)(e.a,{href:"/Extensions/USCSXSL_internal_component",children:"here"}),"."]})}),"\n",(0,i.jsx)(e.h2,{id:"what-is-it",children:"What is it?"}),"\n",(0,i.jsx)(e.p,{children:"The USCSXSL internal component is an XSLT 1.0 processor with rich extensions also found in XSLT 2.0 or 3.0. It is a USoft-proprietary C# implementation."}),"\n",(0,i.jsxs)(e.p,{children:["The USCSXSL internal component gives you the same basic XSLT functionality as the ",(0,i.jsx)(e.a,{href:"/udocs/Extensions/USXSL_internal_component/",children:"USXSL component"}),". This is to say that it provides a standard XSLT 1.0 processor and, in addition, the capability to mix in USoft application data."]}),"\n",(0,i.jsxs)(e.p,{children:["But in addition to the USXSL component, USCSXSL also allows you to call ",(0,i.jsx)(e.a,{href:"/Repositories/Blend_functions",children:"extension functions"}),". You can discover these functions by calling ublendit.exe:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"> *usoft-bindir*\\ublendit.exe functions\n\n> *usoft-bindir*\\ublendit.exe functions ns=strings\n\n> *usoft-bindir*\\ublendit.exe functions p=title\n"})}),"\n",(0,i.jsx)(e.admonition,{type:"note",children:(0,i.jsxs)(e.p,{children:["To find out all about extension functions but also other Blend-related resources, go to ",(0,i.jsx)(e.a,{href:"/udocs/Repositories/Blend_scripts_for_repository_management/Learning_USoft_Blend_for_repository_management",children:"Learning USoft Blend for repository management"}),"."]})}),"\n",(0,i.jsx)(e.h2,{id:"intended-use",children:"Intended use"}),"\n",(0,i.jsx)(e.p,{children:"Use this component in any way that you would normally use XSLT 1.0:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Apply an XSL transformation to an XML document."}),"\n",(0,i.jsx)(e.li,{children:"Retrieve a value from an XML document."}),"\n",(0,i.jsx)(e.li,{children:"Retrieve a complete node from an XML document."}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Use it also to:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Mix USoft application datainto an XSLT transformation."}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["Finally, use it also for its extension functions. You can call these functions from ",(0,i.jsx)(e.a,{href:"/udocs/Repositories/Blend_scripts_for_repository_management/Introducing_Blend_scripts",children:"Blend scripts"}),", a special way of using USCSXSL, but you can also call these functions directly when you apply USCSXSL to transform an XML document, for example:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-xml",children:'<xsl:variable name="rdmlx" select="xslutil:xmlfragment(strings:Text2Xml(files:ReadFile($filepath, .)), .)"/>\n'})}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsxs)(e.p,{children:["Some functions, if called directly from an XSL transformation and not from a Blend script, expect a context. In the example above, the context for the call to the files",":ReadFile","() function is provided by the second argument passed to it: the dot xpath (",(0,i.jsx)(e.strong,{children:"."}),") for current node."]})}),"\n",(0,i.jsx)(e.h2,{id:"encoding",children:"Encoding"}),"\n",(0,i.jsx)(e.p,{children:"A different encoding is produced depending on whether the output is internal or external."}),"\n",(0,i.jsx)(e.p,{children:"The USCSXSL component produces UTF-16 output encoding internally, ie., as long as the output is not written to a file on the file system or passed to a third party by way of a webservice call. This is because with UTF-16 we can easily exchange Unicode characters with controls and other Windows-related interfaces. UTF-16 is also the encoding recommended by Microsoft."}),"\n",(0,i.jsxs)(e.p,{children:['Correspondingly, in this case, the USCSXSL component produces the attribute encoding="UTF-16" in the XML declaration at the top of the output document. You cannot change this behaviour. It applies regardless of what is the value of the encoding attribute of the <xsl',":output","> instruction in the XSL stylesheet (if such an attribute is present)."]}),"\n",(0,i.jsxs)(e.p,{children:["By default, the USCSXSL component produces UTF-8 output encoding externally, ie., when the result is written to a file on the file system, as is the case when you call ",(0,i.jsx)(e.strong,{children:"USCSXSL.Apply2File"}),", or is passed to a third party by way of a webservice call. This is because UTF-8 is a common default in these cases. You can obtain a different external output encoding by specifying it as the encoding attribute of the <xsl",":output","> instruction in the XSL stylesheet, for example:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-xml",children:'<xsl:output encoding="UTF-16"/>\n'})}),"\n",(0,i.jsx)(e.p,{children:"or"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-xml",children:'<xsl:output encoding="ISO-8859-1"/>\n'})}),"\n",(0,i.jsx)(e.p,{children:"\xa0"})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}}}]);