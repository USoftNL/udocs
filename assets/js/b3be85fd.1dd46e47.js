"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[17926],{2265:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Modeller_and_Rules_Engine/SQL_syntax/Join_constructs","title":"Join constructs","description":"This article is about Join constructs as part of the SQL syntax that USoft supports.","source":"@site/docs/Modeller_and_Rules_Engine/SQL_syntax/Join_constructs.md","sourceDirName":"Modeller_and_Rules_Engine/SQL_syntax","slug":"/Modeller_and_Rules_Engine/SQL_syntax/Join_constructs","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_syntax/Join_constructs","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Join_constructs"},"sidebar":"sidebar","previous":{"title":"SELECT","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_syntax/SELECT"},"next":{"title":"INSERT","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_syntax/INSERT"}}');var o=t(74848),i=t(28453);const a={id:"Join_constructs"},r="Join constructs",l={},c=[{value:"<strong>Join constructs</strong>",id:"join-constructs-1",level:2},{value:"Inner join: standard syntax",id:"inner-join-standard-syntax",level:2},{value:"Inner join: [INNER] JOIN syntax",id:"inner-join-inner-join-syntax",level:2},{value:"Outer join: LEFT/RIGHT [OUTER] JOIN syntax",id:"outer-join-leftright-outer-join-syntax",level:2},{value:"Outer join: (+) syntax",id:"outer-join--syntax",level:2},{value:"Outer join: *= syntax",id:"outer-join--syntax-1",level:2},{value:"Cross join",id:"cross-join",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"join-constructs",children:"Join constructs"})}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["This article is about ",(0,o.jsx)(n.strong,{children:"Join constructs"})," as part of the ",(0,o.jsx)(n.a,{href:"/Modeller_and_Rules_Engine/SQL_syntax",children:"SQL syntax"})," that USoft supports."]})}),"\n",(0,o.jsx)(n.h2,{id:"join-constructs-1",children:(0,o.jsx)(n.strong,{children:"Join constructs"})}),"\n",(0,o.jsx)(n.p,{children:"USoft supports a variety of join constructs to express SQL SELECT statements that refer to more than 1 table instance."}),"\n",(0,o.jsxs)(n.p,{children:["In all code examples in this article, ",(0,o.jsx)(n.em,{children:"table"})," represents a required ",(0,o.jsx)(n.strong,{children:"table name"})," for which you can optionally supply an ",(0,o.jsx)(n.strong,{children:"alias"}),". Aliases are recommended - all the examples use aliases. Each occurrence of table represents not a table as such, but a ",(0,o.jsx)(n.strong,{children:"table instance"}),": within a single join statement, you can have multiple table occurrences for the same table, resulting in multiple table instances of that table. ",(0,o.jsx)(n.strong,{children:"Table name"})," in USoft may refer to a database table, a Logical View, or a component table."]}),"\n",(0,o.jsx)(n.h2,{id:"inner-join-standard-syntax",children:"Inner join: standard syntax"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Syntax"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"*SELECT-clause*\nFROM           *table  alias,              table  alias*\n[,              *table  alias* ...]\n[ *join-condition* ... ]\n\n*join-condition*   ::=  { \n    RELATE *  parent-table parent-role child-table* | \n    WHERE *   column* = *column*\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"An inner join is a SQL statement that has more than 1 table instance in the FROM clause. Table instances are separated by commas. You can join any number of table instances."}),"\n",(0,o.jsx)(n.p,{children:"If one table has m rows and the other n rows, joining them WITHOUT any join-condition results in m * n rows in the query result (Cartesian product). Typically, such a query result is reduced in size by adding one or more join-conditions that restrict the query result to combinations of related data."}),"\n",(0,o.jsx)(n.p,{children:"To express join conditions, you can alternatively use RELATE or WHERE. USoft recommends RELATE:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"RELATE clauses connect the tables via a USoft relationship declared in USoft Definer. The join is made by comparing values of the columns declared for the relationship. The relationship as a whole is identified by the combination of parent, role and child: parent is the Parent Object, role is the Parent Role, child is the Child Object of the relationship. RELATE is a USoft-specific extension to the SQL language. RELATE is equivalent to a WHERE condition with an equality operator."}),"\n",(0,o.jsxs)(n.li,{children:["WHERE clauses that typically test the equality of foreign key values in the child table to primary key values in the parent table. Other comparison operators ( ",(0,o.jsx)(n.code,{children:">, <, >=, <=, <>, !="}),") are also supported."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Example 1: RELATE"})}),"\n",(0,o.jsx)(n.p,{children:"The role identifier is conventionally surrounded by double quotes. These double quotes are required only when role contains a space."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:'SELECT         c.name\n,              o.order_date\n,              sum( i.amount ) total\nFROM           customer c\n,              order o\n,              orderitem i\nRELATE         c "PLACES" o\n,              o "INCLUDES" i\nGROUP BY       c.name\n,              o.order_date\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Example 2: WHERE"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT         c.name\n,              o.order_date\n,              sum( i.amount ) total\nFROM           customer c\n,              order o\n,              orderitem i\nWHERE          o.customer_name = c.name\nAND            i.order_id = o.id\nGROUP BY       c.name\n,              o.order_date\n"})}),"\n",(0,o.jsx)(n.h2,{id:"inner-join-inner-join-syntax",children:"Inner join: [INNER] JOIN syntax"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Syntax"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"SELECT          *output-list*\nFROM            *join-clause*\n\n*join-clause*     ::=  *operand*  [INNER] JOIN *operand* [ON *join-condition*]\n\n*operand*         ::=  { *table* [*alias*] | ( *join-clause* ) }\n\n*join-condition*  ::=  *column comparison-operator column* [*logical-operator join-condition* ...]\n\n"})}),"\n",(0,o.jsx)(n.p,{children:"In this syntax, the JOIN keyword is required and the INNER keyword is optional."}),"\n",(0,o.jsxs)(n.p,{children:["The required top\u2011level ",(0,o.jsx)(n.em,{children:"join-clause"})," links 2 data sets (the ",(0,o.jsx)(n.em,{children:"operands"})," of the join), where a data set is either a ",(0,o.jsx)(n.em,{children:"table"}),", with an optional ",(0,o.jsx)(n.em,{children:"alias"}),", or the outcome of a sub\u2011level ",(0,o.jsx)(n.em,{children:"join\u2011clause"}),". A sub\u2011level ",(0,o.jsx)(n.em,{children:"join\u2011clause"})," is allowed to be any join construct that uses the JOIN keyword - it could be another inner join, but also an outer join. Sub\u2011level join\u2011clauses are surrounded by parentheses in much the same way as subqueries."]}),"\n",(0,o.jsx)(n.p,{children:"It is customary that an ON sub-clause restricts the query result to combinations of related data."}),"\n",(0,o.jsxs)(n.p,{children:["If present, the ON keyword introduces a ",(0,o.jsx)(n.em,{children:"join-condition"})," that typically uses the ",(0,o.jsx)(n.strong,{children:"="})," comparison operator to test the equality of foreign key values in the child table to primary key values in the parent table. Other comparison operators ( ",(0,o.jsx)(n.code,{children:">, <, >=, <=, \\<>, !="}),") are also supported. Within the ON clause, multiple conditions may be combined by using logical operators, eg., ON ... AND ... . ."]}),"\n",(0,o.jsxs)(n.p,{children:["The ON sub-clause is optional. If you omit the ON sub-clause, if one data set has ",(0,o.jsx)(n.strong,{children:"m"})," rows and the other ",(0,o.jsx)(n.strong,{children:"n"})," rows, the query result has ",(0,o.jsx)(n.strong,{children:"m * n"})," rows (Cartesian product)."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Example"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT         c.name\n,              o.order_date\n,              sum( i.amount ) total\nFROM           \n( customer c JOIN order o ON o.customer_name = c.name ) JOIN orderitem i ON i.order_id = o.id\nGROUP BY       c.name\n,              o.order_date\n"})}),"\n",(0,o.jsx)(n.h2,{id:"outer-join-leftright-outer-join-syntax",children:"Outer join: LEFT/RIGHT [OUTER] JOIN syntax"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Syntax"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"SELECT          *output-list*\nFROM            *join-clause*\n\n*join-clause*     ::=  *operand* { LEFT | RIGHT } [OUTER] JOIN *operand* ON *join-condition*\n\n*operand*         ::=  { *table* [*alias*] | ( *join-clause* ) }\n\n*join-condition*  ::=  *column comparison-operator column* [*logical-operator join-condition* ...]\n\n"})}),"\n",(0,o.jsx)(n.p,{children:"In this syntax, either LEFT JOIN or RIGHT JOIN is required. The word OUTER can optionally precede JOIN. The ON clause is required."}),"\n",(0,o.jsxs)(n.p,{children:["The required top-level ",(0,o.jsx)(n.em,{children:"join\u2011clause"})," links 2 data-sets (the ",(0,o.jsx)(n.em,{children:"operands"})," of the join), where a data set is either a ",(0,o.jsx)(n.em,{children:"table"}),", with an optional ",(0,o.jsx)(n.em,{children:"alias"}),", or the outcome of a sub\u2011level ",(0,o.jsx)(n.em,{children:"join\u2011clause"}),". A sub\u2011level ",(0,o.jsx)(n.em,{children:"join\u2011clause"})," is allowed to be any join construct that uses the JOIN keyword - it could be another inner join, but also an outer join. Sub\u2011level join\u2011clauses are surrounded by parentheses in much the same way as subqueries."]}),"\n",(0,o.jsxs)(n.p,{children:["The effect of outer join is that, in addition to returning all record combinations of the first data set and the second data set that satisfy the ON clause, ",(0,o.jsx)(n.strong,{children:"the query result will contain a extra record for one of the data sets:"})]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["With ",(0,o.jsx)(n.strong,{children:"LEFT"}),' [OUTER] JOIN, a result record is "added" for each element of the data set mentioned ',(0,o.jsx)(n.strong,{children:"before"})," the JOIN keyword for which there is no join with an element from the other data set."]}),"\n",(0,o.jsxs)(n.li,{children:["With ",(0,o.jsx)(n.strong,{children:"RIGHT"}),' [OUTER] JOIN, a result record is "added" for each element of the data set mentioned ',(0,o.jsx)(n.strong,{children:"after"})," the JOIN keyword for which there is no join with an element from the other data set."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Extra output records that are added tot the result in this way will have NULL values for any output columns of the other data set."}),"\n",(0,o.jsxs)(n.p,{children:["The required ON clause typically uses the equality operator, as in the Example below. Other comparison operators ( ",(0,o.jsx)(n.code,{children:">, <, >=, <=, \\<>, !="}),") are also supported. Within the ON clause, multiple conditions may be combined by using logical operators, eg., ON ... AND ... . ."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Example 1"})}),"\n",(0,o.jsx)(n.p,{children:"In this example, the effect of the LEFT keyword is that the query result will contain not only each combination of customer and order, but also a record for each customer who has NOT placed an order. The extra records (if any) have the NULL value in the o.id output column."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT         c.name\n,              o.id\nFROM           customer c\nLEFT JOIN      order o    ON o.customer_name = c.name\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Example 2"})}),"\n",(0,o.jsx)(n.p,{children:"In this example, the effect of the RIGHT keyword is that the query result will contain not only each combination of customer and order, but also a record for each order that is NOT associated with a customer. The extra records (if any) have the NULL value in the c.name output column."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT         c.name\n,              o.id\nFROM           customer c\nRIGHT JOIN     order o    ON o.customer_name = c.name\n"})}),"\n",(0,o.jsx)(n.h2,{id:"outer-join--syntax",children:"Outer join: (+) syntax"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Syntax"})}),"\n",(0,o.jsx)(n.p,{children:"To simplify, this syntax summary concentrates on the outer join itself. In practice, an outer join may be combined with other joins."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"*SELECT-clause*\nFROM           *table-1  [alias]*\n,              *table-2  [alias]*\nWHERE          {  \n                  table-1.column(+)  operator  table-2.column\n               |  table-1.column     operator  table-2.column(+)\n               }\n"})}),"\n",(0,o.jsx)(n.p,{children:"The only difference with the standard join syntax with WHERE clauses, shown at the beginning of this help topic, is that one of the column names in the WHERE clause now has an added"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"(+)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["modifier following it. This (+) modifier may be placed, alternatively, at the first-mentioned column or at the second-mentioned column. The connecting operator is typically the equality operator (\xa0=\xa0). Other comparison operators ( ",(0,o.jsx)(n.code,{children:">, <, >=, <=, \\<>, !="})," ) are also supported."]}),"\n",(0,o.jsx)(n.p,{children:"The effect of adding the (+) modifier to table\u20111.column is that, in addition to record combinations of table-1 and table-2 that satisfy the WHERE clause, a dummy NULL record is added to the table\u20111 data set."}),"\n",(0,o.jsx)(n.p,{children:"Elements from the table\u20112 data set that do not satisfy the WHERE condition are deemed to match this added dummy record. The net effect is that the query result will contain a record for each record in table\u20112 that does NOT satisfy the WHERE condition."}),"\n",(0,o.jsx)(n.p,{children:'If you have multiple join conditions, which is typically necessary if you have a primary key spanning multiple columns, then the (+) operator must be placed "on the same side" in each of the conditions. Otherwise, it\'s an error ("A circular outer join has been detected").'}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Example"})}),"\n",(0,o.jsx)(n.p,{children:"In this example, the effect of the added (+) modifier is that the query result will contain not only each combination of customer and order, but also a record for each customer who has NOT placed any order. In such a record, the order ID is NULL."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT         c.name\n,              o.id\nFROM           customer c\n,              order o\nWHERE          c.name = o.customer_name(+)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"outer-join--syntax-1",children:"Outer join: *= syntax"}),"\n",(0,o.jsx)(n.admonition,{type:"danger",children:(0,o.jsxs)(n.p,{children:["This syntax is ",(0,o.jsx)(n.strong,{children:"deprecated"})," and supported for backward compatibility only. This syntax is associated with SQL for ODBC."]})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Syntax"})}),"\n",(0,o.jsx)(n.p,{children:"To simplify, this syntax summary concentrates on the outer join itself. In practice, an outer join may be combined with other joins."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"*SELECT-clause*\nFROM           *table-1  [alias]*\n,              *table-2  [alias]*\nWHERE          {  \n*table-1.column*  *=  *table-2.column*\n               |  *table-1.column*  =*  *table-2.column*\n               }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This is an outer join because of the ",(0,o.jsx)(n.strong,{children:"asterisk (*)"})," added either before or after the equality symbol in the join condition(s)."]}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsx)(n.p,{children:'The following special ODBC join operator for "full outer outer join" is not supported by USoft:'})}),"\n",(0,o.jsx)(n.p,{children:"\xa0"}),"\n",(0,o.jsx)(n.p,{children:"The effect of adding an asterisk in this way is that, in addition to record combinations of table-1 and table-2 that satisfy the equality operator, in either table\u20111 or table\u20112, the query result will contain an extra item for each record that does NOT satisfy the equality operator. The effect is as follows:"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{}),(0,o.jsx)(n.th,{})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:["*",(0,o.jsx)(n.strong,{children:"="})]}),(0,o.jsxs)(n.td,{children:['The extra items (if any) are "added" to the table instance mentioned before the asterisk (here, to ',(0,o.jsx)(n.em,{children:"table-1"}),")."]})]})})]}),"\n",(0,o.jsxs)(n.p,{children:["In this case, The query result for the join will have, for the extra items, the NULL value in any output columns selected from ",(0,o.jsx)(n.em,{children:"table-2"}),"."]}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{}),(0,o.jsx)(n.th,{})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.strong,{children:"="}),"*"]}),(0,o.jsxs)(n.td,{children:['The extra items (if any) are "added" to the table instance mentioned after the asterisk (here, to ',(0,o.jsx)(n.em,{children:"table-2"}),")."]})]})})]}),"\n",(0,o.jsxs)(n.p,{children:["In this case, The query result for the join will have, for the extra items, the NULL value in any output columns selected from ",(0,o.jsx)(n.em,{children:"table-1"}),"."]}),"\n",(0,o.jsx)(n.p,{children:'If you have multiple join conditions, which is typically necessary if you have a primary key spanning multiple columns, then the asterisk must be placed "on the same side" in each of the conditions. Otherwise, it\'s an error ("A circular outer join has been detected").'}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Example"})}),"\n",(0,o.jsx)(n.p,{children:"In this example, the effect of the added asterisk is that the query result will contain not only each combination of customer and order, but also a record for each customer who has NOT placed any order. In such a record, the order ID is NULL."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT         c.name\n,              o.id\nFROM           customer c\n,              order o\nWHERE          c.name *= o.customer_name\n"})}),"\n",(0,o.jsx)(n.h2,{id:"cross-join",children:"Cross join"}),"\n",(0,o.jsx)(n.p,{children:"A cross join is the effect of joining 2 tables without imposing a join condition. The result is a Cartesian product: each record of the first table is combined with each record of the second table. The number of result records is the product of the number of records in the first table and the number of records in the second table."}),"\n",(0,o.jsx)(n.p,{children:"When developing a USoft application you do not normally need to express cross joins."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Syntax 1: Standard syntax"})}),"\n",(0,o.jsx)(n.p,{children:"To simplify, this syntax concentrates on the cross join itself. In practice, a cross join may be combined with other joins, as shown earlier in this help topic for inner joins.\nWhat makes this syntax a cross join is the fact that the FROM clause contains 2 tables, in combination with the fact that no join condition is present."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"*SELECT-clause*\nFROM           *table*\n,              *table*\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Syntax 2: CROSS JOIN syntax"})}),"\n",(0,o.jsx)(n.p,{children:"To simplify, this syntax concentrates on the cross join itself. In practice, a cross join may be combined with other joins, as shown earlier in this help topic for inner joins.\nIn this syntax, the JOIN keyword is required and the CROSS keyword is optional. This construct has a JOIN clause but not an ON clause."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"*SELECT-clause*\nFROM           \n*table*  CROSS JOIN  *table*\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(96540);const o={},i=s.createContext(o);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);