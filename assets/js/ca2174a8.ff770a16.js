"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[53470],{21300:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Modeller_and_Rules_Engine/SQL_syntax/SELECT","title":"SELECT","description":"This article is about SELECT statements as part of the SQL syntax that USoft supports.","source":"@site/docs/Modeller_and_Rules_Engine/SQL_syntax/SELECT.md","sourceDirName":"Modeller_and_Rules_Engine/SQL_syntax","slug":"/Modeller_and_Rules_Engine/SQL_syntax/SELECT","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_syntax/SELECT","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"SELECT"},"sidebar":"sidebar","previous":{"title":"SQL syntax","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_syntax"},"next":{"title":"Join constructs","permalink":"/udocs/Modeller_and_Rules_Engine/SQL_syntax/Join_constructs"}}');var o=t(74848),a=t(28453);const i={id:"SELECT"},r="SELECT",l={},c=[{value:"<strong>SELECT</strong>",id:"select-1",level:2},{value:"Subqueries",id:"subqueries",level:2},{value:"Function call syntax",id:"function-call-syntax",level:2},{value:"CONNECT BY, START WITH",id:"connect-by-start-with",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"select",children:"SELECT"})}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["This article is about ",(0,o.jsx)(n.strong,{children:"SELECT"})," statements as part of the ",(0,o.jsx)(n.a,{href:"/Modeller_and_Rules_Engine/SQL_syntax",children:"SQL syntax"})," that USoft supports."]})}),"\n",(0,o.jsx)(n.h2,{id:"select-1",children:(0,o.jsx)(n.strong,{children:"SELECT"})}),"\n",(0,o.jsx)(n.p,{children:"Retrieves data from the RDBMS or from a component."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Syntax"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT         DISTINCT *column-list*\nFROM           { *table-name [table-alias]* | *join-construct* }\n*[where-clause][group-by-clause][order-by-clause]*\n\n*column-list*         ::=  *column-expression* [, ... ]\n\n*where-clause*        ::=  WHERE condition\n*group-by-clause*     ::=  GROUP BY column-list [ HAVING condition ]\n*order-by-clause*     ::=  ORDER BY *column-list*\n                           { ASC | ASCENDING | DESC | DESCENDING | }\n\n*condition*           ::= * condition* [ { AND | OR } condition \u2026 }\n"})}),"\n",(0,o.jsx)(n.p,{children:"The required SELECT clause contains a list of 1 or more comma-separated output expressions. Instead of this list, you can have an asterisk (*) as column wildcard meaning 'all the columns'. For the optional DISTINCT keyword, see GROUP BY below."}),"\n",(0,o.jsx)(n.p,{children:"A FROM clause is normally present. In USoft, you can omit the FROM clause if you don't need to retrieve stored data from the RDBMS, as when you are only interested in the outcome of a SQL function:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT    AVG ( 178, 211 )\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If present, the FROM clause must refer to at least 1 table. For each ",(0,o.jsx)(n.em,{children:"table"})," instance, you can optionally supply an ",(0,o.jsx)(n.em,{children:"alias"}),". If you need to retrieve data from multiple tables or table instances, a ",(0,o.jsx)(n.em,{children:"join-construct"})," of some sort is required. Depending on the case, an alternative for join-construct may be to write a subquery (next section)."]}),"\n",(0,o.jsx)(n.p,{children:"Using WHERE conditions, you can restrict your query result. Rows that do not satisfy the WHERE condition(s) are removed from the result."}),"\n",(0,o.jsx)(n.p,{children:"If you use GROUP BY followed by a single column name or expression, then if the query result has multiple rows for which this column or expression evaluates to the same value, then this value is returned only once. In other words, rows with identical values are grouped. If GROUP BY is followed by multiple column names or expressions, the rows are grouped by unique combinations of those colums. The result of the following query can only contain rows that have a unique combination of destination and tour_type:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT    destination, tour_type\nFROM      tour\nGROUP BY  destination, tour_type\n"})}),"\n",(0,o.jsx)(n.p,{children:"even though the primary key of this table could be the combination (destination, tour_type, year), which would allow multiple rows with the same (destination, tour_type) combination to be present in the database. Adding DISTINCT after the SELECT keyword is a shortcut notation which has the same effect as adding a GROUP BY clause with the same columns or expressions as in the SELECT list. Except for convenience in ad-hoc querying, when DISTINCT is faster to type, USoft recommends using GROUP BY instead of DISTINCT."}),"\n",(0,o.jsx)(n.p,{children:"If you add GROUP BY, the SELECT clause is only allowed to contain (a) expressions that also appear in the GROUP BY clause, (b) group functions, (c) literals. This example shows, for each combination of destination and tour_type, how many times this combination occurred over the years:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT    destination, tour_type, COUNT(*) total\nFROM      tour\nGROUP BY  destination, tour_type\n"})}),"\n",(0,o.jsx)(n.p,{children:"If you add GROUP BY, you can optionally add a HAVING clause. This causes a row grouped as a result of GROUP BY to be removed from the query result if that row does not satisfy the condition(s) following HAVING. The HAVING list is only allows to contain (just like the SELECT list) (a) expressions that also appear in the GROUP BY clause, (b) group functions, (c) literals. This example shows the same as the previous example but only for combinations of destination and tour_type that occurred at least 10 times in the year 2000 or later:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT    destination, tour_type, COUNT(*) total\nFROM      tour\nWHERE     year >= 2000\nGROUP BY  destination, tour_type\nHAVING    COUNT(*) >= 10\n"})}),"\n",(0,o.jsx)(n.p,{children:"If you add ORDER BY, the query result is sorted by the column or expression that follows the ORDER BY keyword. If there are multiple columns or expressions, the result is ordered by the combination, sorted first by the first-mentioned column. Sorting is in ascending order by default, and also if you add the optional ASC or ASCENDING keyword. Sorting is in descending order if you add the DESC or DESCENDING keyword. If a GROUP BY clause is present, you may only ORDER BY columns or expressions that also appear in the GROUP BY list."}),"\n",(0,o.jsx)(n.h2,{id:"subqueries",children:"Subqueries"}),"\n",(0,o.jsx)(n.p,{children:"A subquery is a parenthesised SELECT statement in a condition. A subquery takes the place of the element appearing after the comparison operator. The SQL statement that contains the condition is the embedding statement. This may be a higher-level SELECT, but also an INSERT, UPDATE or DELETE statement."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Syntax"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"*embedding-statement*\n(\n     SELECT ...\n)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Use subqueries to retrieve additional data needed for the execution of your higher-level statement. You can nest subqueries any level deep."}),"\n",(0,o.jsxs)(n.p,{children:["An ",(0,o.jsx)(n.em,{children:"independent subquery"})," does not reference any element in the higher-level query. When the statement executes, the subquery is first executed independently. In the example, the subquery yields a constant integer. Each of the data groups retrieved by the higher-level query is added to the result set if that integer is lower than the number of items in the group:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT    c.name\n,         COUNT(*)\nFROM      customer c\n,         asset a\nRELATE    c \"HAS\" a\nGROUP BY  c.name\nHAVING    COUNT(*) >\n(\n    SELECT   b.value\n    FROM     boundary b\n    WHERE    b.name = 'max_no_of_assets'\n)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.em,{children:"joined"})," or ",(0,o.jsx)(n.em,{children:"correlated subquery"})," refers to a table instance in the higher-level SQL statement, joining each record of the subquery to each corresponding record in the higher-level query, much in the same way as joining takes place when you use a join-construct (next section). In the example, the subquery yields a variable integer: a different integer for each customer and his number of assets:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT    c.name\n,         COUNT(*)\nFROM      customer c\n,         asset a\nRELATE    c \"HAS\" a\nGROUP BY  c.name\nHAVING    COUNT(*) >\n(\n    SELECT   b.value\n    FROM     boundary b\n    WHERE    b.name = 'max_no_of_assets'\n    AND      b.country = c.country_of_residence\n)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"function-call-syntax",children:"Function call syntax"}),"\n",(0,o.jsxs)(n.p,{children:["You can use SELECT to call RDMI components. This uses ",(0,o.jsx)(n.em,{children:"function call syntax"})," and is an alternative to using the INVOKE statement:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT *component.method*(\n*value(s)*\n)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In function call syntax, ",(0,o.jsx)(n.em,{children:"component.method"})," is an argument of the SELECT keyword. A FROM keyword does not appear."]}),"\n",(0,o.jsx)(n.p,{children:"Function call syntax may also be used in other places than in the SELECT output list, for example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT   ...\nFROM     ...\nWHERE    column = *component.method*( *value(s)* )\n"})}),"\n",(0,o.jsx)(n.h2,{id:"connect-by-start-with",children:"CONNECT BY, START WITH"}),"\n",(0,o.jsx)(n.p,{children:"The following construct can be used in USoft Developer in most contexts:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sql",children:"SELECT      ...\nFROM        ...\nCONNECT BY  ...\nSTART WITH  \u2026\n"})}),"\n",(0,o.jsx)(n.p,{children:"but not:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"In constraints."}),"\n",(0,o.jsx)(n.li,{children:"In the SQL statement of a logical view."}),"\n",(0,o.jsx)(n.li,{children:"When selecting from component tables."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"On Oracle, a START WITH clause can precede the CONNECT BY clause."})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var s=t(96540);const o={},a=s.createContext(o);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);