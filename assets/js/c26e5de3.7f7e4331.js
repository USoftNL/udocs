"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[88792],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var i=t(96540);const s={},a=i.createContext(s);function l(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(a.Provider,{value:n},e.children)}},71940:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"Extensions/USMeta_internal_component/USMetaRelationships","title":"USMeta.Relationships","description":"This article is about the Relationships method of the USMeta internal component.","source":"@site/docs/Extensions/USMeta_internal_component/USMetaRelationships.md","sourceDirName":"Extensions/USMeta_internal_component","slug":"/Extensions/USMeta_internal_component/USMetaRelationships","permalink":"/udocs/Extensions/USMeta_internal_component/USMetaRelationships","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"USMetaRelationships"},"sidebar":"sidebar","previous":{"title":"USMeta.Modules","permalink":"/udocs/Extensions/USMeta_internal_component/USMetaModules"},"next":{"title":"USMeta.Roles","permalink":"/udocs/Extensions/USMeta_internal_component/USMetaRoles"}}');var s=t(74848),a=t(28453);const l={id:"USMetaRelationships"},o="USMeta.Relationships",r={},h=[{value:"<strong>USMeta.Relationships</strong>",id:"usmetarelationships-1",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"usmetarelationships",children:"USMeta.Relationships"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["This article is about the ",(0,s.jsx)(n.strong,{children:"Relationships"})," method of the ",(0,s.jsx)(n.a,{href:"/Extensions/USMeta_internal_component",children:"USMeta internal component"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"usmetarelationships-1",children:(0,s.jsx)(n.strong,{children:"USMeta.Relationships"})}),"\n",(0,s.jsx)(n.p,{children:"At runtime, gets metadata information about relationships and relationship columns from the model developed in USoft Definer. For each retrieved relationship, this information takes the form of name/value pairs:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Name"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Value"})})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"PARENT_TABLE"}),(0,s.jsx)(n.td,{children:"Parent Object"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CHILD_TABLE"}),(0,s.jsx)(n.td,{children:"Child Object"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"PARENT_ROLE"}),(0,s.jsx)(n.td,{children:"Parent Role"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"MODULE_NAME"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("p",{children:"If the relationship is not from a consumed module: the current application name."}),(0,s.jsx)("p",{children:"If you are calling from a USoft application, this is the USoft application name, eg., USD for USoft Definer."}),(0,s.jsx)("p",{children:"If you are calling from a User Application, this is the User Application name, eg. SALES."}),(0,s.jsx)("p",{children:"If the relationship is from a consumed module: the name of the consumed module."}),"> [!TIP]"]})]})]})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"The relationship is from a consumed module if it is in the .CON file that that module provides.\nIf the parent table and child table are both usable as interface, it is also possible for the current application to define the relationship itself."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["|\n|CHILD_ROLE|Child Role|\n|ALIAS_PARENT|Alias Parent|\n|REV_MENU_LINE|Lookup Window Name|\n|MENU_LINE|Related Window Name|\n|FK_MANDATORY|Foreign Key Mandatory|\n|FK_CHECK_PARTIAL|Check Partial Foreign Key|\n|LOCK_ON_FK_CHECK|Lock Foreign Key on Check|\n|FK_UPDATABLE|",(0,s.jsx)("p",{children:"Foreign Key Updatable:"}),(0,s.jsx)("p",{children:"\u2018Y\u2019 if Yes;"}),(0,s.jsx)("p",{children:"'ONLY_IF_NULL\u2019 if \u201cOnly If Null\u201d;"}),(0,s.jsx)("p",{children:"'N\u2019 if No."}),"|\n|CHILD_MANDATORY|Child Must Exist|\n|MIN_NO_OF_CHILDREN|Minimum Children|\n|MAX_NO_OF_CHILDREN|Maximum Children|\n|LOOKUP_METHOD|",(0,s.jsx)("p",{children:"Lookup Method:"}),(0,s.jsx)("p",{children:"'WINDOW PAGE\u2019 if \"Lookup Window or Page\u201d (the default);"}),(0,s.jsx)("p",{children:"'DROPDOWN\u2019 if \"Dropdown List\u201d;"}),(0,s.jsx)("p",{children:"'RADIO\u2019 if \"Radio\u201d."}),"|\n|DELETE_RULE|",(0,s.jsx)("p",{children:"Delete Rule:"}),(0,s.jsx)("p",{children:"'RESTRICTED\u2019, \u2018CASCADING\u2019, or 'NULLIFY\u2019."}),"|\n|UPDATE_RULE|",(0,s.jsx)("p",{children:"Update Rule:"}),(0,s.jsx)("p",{children:"'RESTRICTED\u2019, \u2018CASCADING\u2019, or 'NULLIFY\u2019."}),"|\n|TYPE_OF_RELATIONSHIP|",(0,s.jsx)("p",{children:"Type Of Relationship:"}),(0,s.jsx)("p",{children:"'REFERENCE\u2019 or 'COMPOSITION\u2019."}),"|"]}),"\n",(0,s.jsx)(n.p,{children:"Relationship columns are shown in a child element, for example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<Relationship PARENT_TABLE="PERSON" CHILD_TABLE="ORDER" ... >\n    <Relationship_Columns>\n        <Column PARENT="PERSON_ID" CHILD="ORDER_ID"/>\n    </Relationship_Columns>\n</Relationship>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Returns an XML document of the form demonstrated in Example 1 below."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Syntax"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT USMeta.Relationships(\n\xa0\xa0\xa0\xa0*parent-table-name-pattern*   Parents\n,\xa0\xa0\xa0*child-table-name-pattern*    Children\n,\xa0\xa0\xa0*role-name-pattern*           Roles\n,\xa0\xa0\xa0*mime-type*                   MimeType\n)\n\n*mime-type*   ::=  {  application/xml\n                 ,  xml\n                 ,  application/json\n                 ,  json  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["All parameters are optional. Parameter values that you pass are mapped to parameters by alias name. The 'PERSON' value in the following example is for ",(0,s.jsx)(n.em,{children:"parent-table-name-pattern"}),' because of the "Parents" alias:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT   USMeta.Relationships( 'PERSON' Parents )\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"For backward compatibility only, it is possible to supply parameter values by position. Using this syntax, a list of non-aliased values maps to the parameter list in the order stated, with empty values at the end of the list if you supply\xa0 less than 3 values, and '' (the empty string) as a way of explicitly declaring an empty value."})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Parent-table-name-pattern"})," is a regular expression that matches zero, one or more parent tables in the model. The result data is limited to relationships that have a parent table matching the pattern. If ",(0,s.jsx)(n.em,{children:"parent-table-name-pattern"})," is omitted, then result data is not limited in this way."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Child-table-name-pattern"})," is a regular expression that matches zero, one or more child tables in the model. The result data is limited to relationships that have a child table matching the pattern. If ",(0,s.jsx)(n.em,{children:"child-table-name-pattern"})," is omitted, then result data is not limited in this way."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Role-name-pattern"})," is a regular expression that matches zero, one or more role names in the model. The result data is limited to relationships that have a Parent Role name matching the pattern. If ",(0,s.jsx)(n.em,{children:"role-name-pattern"})," is omitted, then result data is not limited in this way."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Mime-type"})," determines whether the output is in XML ( \u2018application/xml\u2018 or 'xml\u2019) or in JSON ('application/json\u2019 or 'json\u2019). The default is XML."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Example 1"})}),"\n",(0,s.jsx)(n.p,{children:"This example returns relationship information on all relationships that have the TOUR table als their child table:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT USMeta.Relationships( 'TOUR' Children )\n"})}),"\n",(0,s.jsx)(n.p,{children:"The return value of this statement could be:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" encoding="UTF-16"?>\n<Meta>\n\t<Relationships>\n\t\t<Relationship PARENT_TABLE="GUIDE" CHILD_TABLE="TOUR" PARENT_ROLE="GUIDES" MODULE_NAME="TRAVEL" CHILD_ROLE="are guided by" ALIAS_PARENT="" REV_MENU_LINE="Persons guiding Tours" MENU_LINE="Tours guided by this Person" FK_MANDATORY="N" FK_CHECK_PARTIAL="Y" LOCK_ON_FK_CHECK="Y" FK_UPDATABLE="Y" CHILD_MANDATORY="N" MIN_NO_OF_CHILDREN="0" MAX_NO_OF_CHILDREN="0" LOOKUP_METHOD="WINDOW PAGE" DELETE_RULE="RESTRICTED" UPDATE_RULE="RESTRICTED" TYPE_OF_RELATIONSHIP="REFERENCE">\n\t\t\t<Relationship_Columns>\n\t\t\t\t<Column PARENT="PERSON_ID" CHILD="GUIDE"/>\n\t\t\t</Relationship_Columns>\n\t\t</Relationship>\n\t\t<Relationship PARENT_TABLE="TOUR_PROGRAMME" CHILD_TABLE="TOUR" PARENT_ROLE="IS FOLLOWED BY" MODULE_NAME="TRAVEL" CHILD_ROLE="follows" ALIAS_PARENT="" REV_MENU_LINE="Tour_programmes is followed by tour" MENU_LINE="Tours is followed by tour_programme" FK_MANDATORY="Y" FK_CHECK_PARTIAL="Y" LOCK_ON_FK_CHECK="Y" FK_UPDATABLE="Y" CHILD_MANDATORY="N" MIN_NO_OF_CHILDREN="0" MAX_NO_OF_CHILDREN="0" LOOKUP_METHOD="WINDOW PAGE" DELETE_RULE="RESTRICTED" UPDATE_RULE="CASCADING" TYPE_OF_RELATIONSHIP="REFERENCE">\n\t\t\t<Relationship_Columns>\n\t\t\t\t<Column PARENT="DESTINATION" CHILD="DESTINATION"/>\n\t\t\t\t<Column PARENT="TOUR_TYPE" CHILD="TOUR_TYPE"/>\n\t\t\t</Relationship_Columns>\n\t\t</Relationship>\n\t</Relationships>\n</Meta>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Example 2"})}),"\n",(0,s.jsx)(n.p,{children:"This example returns relationship information about all relationships that have as their child table name an alphanumeric uppercase string that contains 'TOUR':"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"SELECT USMeta.Relationships( '^[A-Z]*TOUR[A-Z]*$' Children )\n"})}),"\n",(0,s.jsx)(n.p,{children:"\xa0"})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);