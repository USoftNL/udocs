"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[98931],{28453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>c});var i=n(96540);const t={},r=i.createContext(t);function o(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:s},e.children)}},59271:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"Services/Event_processing/Design_patterns_for_event_processing","title":"Design patterns for event processing","description":"Event-driven architecture gives you a type of solution where events are key. An event is something that happens in the real world, has a business meaning, and carries information. Depending on the business case and on system requirements, different patterns will emerge that turn out to achieve the best result. They can be classified as:","source":"@site/docs/Services/Event_processing/Design_patterns_for_event_processing.md","sourceDirName":"Services/Event_processing","slug":"/Services/Event_processing/Design_patterns_for_event_processing","permalink":"/udocs/Services/Event_processing/Design_patterns_for_event_processing","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Design_patterns_for_event_processing"},"sidebar":"sidebar","previous":{"title":"Event processing","permalink":"/udocs/Services/Event_processing/"},"next":{"title":"Event processing best practices","permalink":"/udocs/Services/Event_processing/Event_processing_best_practices"}}');var t=n(74848),r=n(28453);const o={id:"Design_patterns_for_event_processing"},c="Design patterns for event processing",a={},h=[{value:"Synchronous input processing with synchronous result",id:"synchronous-input-processing-with-synchronous-result",level:2},{value:"Synchronous input processing with asynchronous result",id:"synchronous-input-processing-with-asynchronous-result",level:2},{value:"Asynchronous input processing with synchronous result",id:"asynchronous-input-processing-with-synchronous-result",level:2},{value:"Asynchronous input processing with asynchronous result",id:"asynchronous-input-processing-with-asynchronous-result",level:2}];function l(e){const s={h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"design-patterns-for-event-processing",children:"Design patterns for event processing"})}),"\n",(0,t.jsx)(s.p,{children:"Event-driven architecture gives you a type of solution where events are key. An event is something that happens in the real world, has a business meaning, and carries information. Depending on the business case and on system requirements, different patterns will emerge that turn out to achieve the best result. They can be classified as:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Synchronous input processing with synchronous result"}),"\n",(0,t.jsx)(s.li,{children:"Synchronous input processing with asynchronous result"}),"\n",(0,t.jsx)(s.li,{children:"Asynchronous input processing with synchronous result"}),"\n",(0,t.jsx)(s.li,{children:"Asynchronous input processing with asynchronous result"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Asynchronous patterns may be implemented with different levels of asynchronicity."}),"\n",(0,t.jsx)(s.h2,{id:"synchronous-input-processing-with-synchronous-result",children:"Synchronous input processing with synchronous result"}),"\n",(0,t.jsx)(s.p,{children:"In synchronous processing, the input is processed immediately when it arrives. If a response is needed, that response is sent directly as a result of the processing."}),"\n",(0,t.jsx)(s.p,{children:"In this pattern, the same process that receives an event also handles the event, so a queue table is not strictly needed. It is, however, best practice to use a queue table in any case, even if only for traceability."}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"When to consider"})}),"\n",(0,t.jsx)(s.p,{children:"This pattern is a good choice when:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Events have low frequency and can be processed one-by-one."}),"\n",(0,t.jsx)(s.li,{children:"Processing the event does not require a lot of resources and does not take much time, or the necessary processing time is acceptable to the caller."}),"\n",(0,t.jsx)(s.li,{children:"Events do not have to be processed in a specific order and an enterprise message bus is used to scale the workload."}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Advantages"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Easy to write and to understand."}),"\n",(0,t.jsx)(s.li,{children:"Simple deployment procedure."}),"\n",(0,t.jsx)(s.li,{children:"Simple to monitor in a production environment."}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Disadvantages"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Does not scale."}),"\n",(0,t.jsx)(s.li,{children:"Is based on the request-response principle, so the caller has to wait for the response."}),"\n",(0,t.jsx)(s.li,{children:"Is not ready to deal with unexpected event frequency."}),"\n",(0,t.jsx)(s.li,{children:"Cannot guarantee the delivery of output events (this can be achieved by using an asynchronous result)."}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{src:n(90062).A+"",width:"848",height:"515"})}),"\n",(0,t.jsx)(s.h2,{id:"synchronous-input-processing-with-asynchronous-result",children:"Synchronous input processing with asynchronous result"}),"\n",(0,t.jsx)(s.p,{children:"Synchronous processing, in which the input is processed as soon as it arrives, may be combined with asynchronous results: if a response is needed, the response message is placed in a queue table and sent when the system is available."}),"\n",(0,t.jsx)(s.p,{children:"This pattern must be considered when input processing does not take much time but creating and sending an output message is relatively costly. It is also useful if the responding service must guarantee the delivery of output messages: if an output message cannot be delivered because of an error, the system must retry after a period of time."}),"\n",(0,t.jsx)(s.p,{children:"The advantage is that you are still using the easiest way to process input. Because output processing is asynchronous, it may be dealt with by a parallel process if needed."}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{src:n(92632).A+"",width:"810",height:"622"})}),"\n",(0,t.jsx)(s.h2,{id:"asynchronous-input-processing-with-synchronous-result",children:"Asynchronous input processing with synchronous result"}),"\n",(0,t.jsx)(s.p,{children:"In asynchronous input processing, the input is stored in a queue table when it arrives and a separate queuing service will pick it up for processing. As part of this processing, a response is sent immediately if necessary."}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"When to consider"})}),"\n",(0,t.jsx)(s.p,{children:"This pattern is a good choice when:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Events have a high frequency and cannot be processed one-by-one, or:"}),"\n",(0,t.jsx)(s.li,{children:"The processing of an event requires a lot of resources, or:"}),"\n",(0,t.jsx)(s.li,{children:"The processing of an event takes much time."}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Advantages"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Scalable in time. If the number of events grows in time, events may be processed in parallel for a better overall performance."}),"\n",(0,t.jsx)(s.li,{children:"Tolerant to failure in that this pattern allows fault isolation: if the processing service fails, the receiving service is still available."}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Disadvantages"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"More difficult to write and understand than synchronous input processing."}),"\n",(0,t.jsx)(s.li,{children:"Often more complex to deploy."}),"\n",(0,t.jsx)(s.li,{children:"Testing is more complex and may require more time and resources."}),"\n",(0,t.jsx)(s.li,{children:"Monitoring of the system in the production environment is required."}),"\n",(0,t.jsx)(s.li,{children:"Cannot guarantee the delivery of output events (this can be achieved by using an asynchronous result)."}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"asynchronous-input-processing-with-asynchronous-result",children:"Asynchronous input processing with asynchronous result"}),"\n",(0,t.jsx)(s.p,{children:"Asynchronous input processing, in which input is stored in a queue table and picked up from there, may be combined with asynchronous results: if a response is needed, the response message is placed in a second queue table and sent when the system is available."}),"\n",(0,t.jsx)(s.p,{children:"This is a variation on asynchronous input processing with synchronous result.It is useful if the responding service must guarantee the delivery of output messages: if an output message cannot be delivered because of an error, the system must retry after a period of time."}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{src:n(91893).A+"",width:"831",height:"625"})}),"\n",(0,t.jsx)(s.p,{children:"\xa0"})]})}function u(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},90062:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/09526438-1d5c-4d69-96e4-17559c290a34-c29f181f17b80e7eb127eb3aa76ea97c.png"},91893:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/e9708927-2d4d-4dab-9856-96b8bec186d5-d90690066ea3af3801f36b416ab505bb.png"},92632:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/12dbcb60-1f52-4933-8028-9bf7d6c11b7e-c548e8ae3f449b2141a91d225158a204.png"}}]);