"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[5829],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(96540);const o={},i=s.createContext(o);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:t},e.children)}},63973:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Repositories/USoft_XML_formats/MetaRowsFields_document_format","title":"Meta-Rows-Fields document format","description":"A Meta-Rows-Fields XML document is allowed to contain data from multiple tables.","source":"@site/docs/Repositories/USoft_XML_formats/MetaRowsFields_document_format.md","sourceDirName":"Repositories/USoft_XML_formats","slug":"/Repositories/USoft_XML_formats/MetaRowsFields_document_format","permalink":"/udocs/Repositories/USoft_XML_formats/MetaRowsFields_document_format","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"MetaRowsFields_document_format"},"sidebar":"sidebar","previous":{"title":"XML representation of queries","permalink":"/udocs/Repositories/USoft_XML_formats/XML_representation_of_queries"},"next":{"title":"XML error messages","permalink":"/udocs/Repositories/USoft_XML_formats/XML_error_messages"}}');var o=n(74848),i=n(28453);const a={id:"MetaRowsFields_document_format"},r="Meta-Rows-Fields document format",l={},d=[{value:"Unique aliases",id:"unique-aliases",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"meta-rows-fields-document-format",children:"Meta-Rows-Fields document format"})}),"\n",(0,o.jsxs)(t.p,{children:["A ",(0,o.jsx)(t.strong,{children:"Meta-Rows-Fields XML document"})," is allowed to contain data from multiple tables."]}),"\n",(0,o.jsxs)(t.p,{children:["Unlike ",(0,o.jsx)(t.a,{href:"/udocs/Repositories/USoft_XML_formats/XML_multitable_document_format",children:"multi-table XML documents"}),", this document type can have in the output list not just simple column names, but also compound column expressions, that is, output expressions using operators or literals or both, in addition to actual column names."]}),"\n",(0,o.jsx)(t.p,{children:"A compound column expression must be accompanied by an alias. See the Unique Aliases section later in this article."}),"\n",(0,o.jsx)(t.admonition,{type:"tip",children:(0,o.jsxs)(t.p,{children:["This document format is produced by calls to ",(0,o.jsx)(t.a,{href:"/udocs/Extensions/XML_internal_component/XMLSQLExport",children:"XML.SQLExport"})," and ",(0,o.jsx)(t.a,{href:"/udocs/Extensions/XML_internal_component/XMLSQLStatementExport",children:"XML.SQLStatementExport"}),"."]})}),"\n",(0,o.jsx)(t.admonition,{type:"danger",children:(0,o.jsxs)(t.p,{children:["This document format is not re-importable by calling ",(0,o.jsx)(t.a,{href:"/udocs/Extensions/XML_internal_component/XMLImport",children:"XML.Import"}),"."]})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.em,{children:"Syntax"}),"\n\xa0"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-xml",children:'<SQLXMLExport>\n  <Meta>\n    <OutputExpressions>\n*output-expression* ...\n    </OutputExpressions>\n  </Meta>\n  <Rows>\n    <Row>\n      <Field alias="*alias*"> *value* </Field> ...\n    </Row>\n    ...\n  </Rows>\n</SQLXMLExport>\n\n*output-expression*  ::=  { <Column ... />  | <Expression ... />}\n'})}),"\n",(0,o.jsx)(t.p,{children:"In <Meta>, each output-expression describes an element of the SELECT output list. As the Example shows, output-expression for a compound expression is an <Expression> element, and output\u2011expression for a simple column expression is a <Column> element; <Column> provides attribute values taken from the column definition in USoft Definer."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"Example"})}),"\n",(0,o.jsx)(t.p,{children:"The result of this call:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sql",children:"invoke      xml.sqlexport with\nselect      concat( concat( t.destination, ' ' ), t.tour_type ) tour_label\n,           tp.num_days\nfrom        tour_programme tp\n,           tour t\nrelate      tp \"IS FOLLOWED BY\" t\nwhere       t.destination = 'AUSTRALIA'\ngroup by    t.destination, t.tour_type, tp.num_days\n"})}),"\n",(0,o.jsx)(t.p,{children:"is this Meta-Rows-Fields document:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-xml",children:'<SQLXMLExport>\n  <Meta>\n    <OutputExpressions>\n      <Expression alias="tour_label">CONCAT(CONCAT(t.DESTINATION, \'; \';), t.TOUR_TYPE)</Expression>\n      <Column tableName="TOUR_PROGRAMME" tableAlias="tp" name="NUM_DAYS" alias="NUM_DAYS" objectNamePlural="Tour Programmes" prompt="Number of Days"/>\n    </OutputExpressions>\n  </Meta>\n  <Rows>\n    <Row>\n      <Field alias="tour_label">AUSTRALIA ISLAND SUNTANNER</Field>\n      <Field alias="NUM_DAYS">12</Field>\n    </Row>\n    <Row>\n      <Field alias="tour_label">AUSTRALIA UP OR DOWN THE TRACK</Field>\n      <Field alias="NUM_DAYS">10</Field>\n    </Row>\n  </Rows>\n</SQLXMLExport>\n'})}),"\n",(0,o.jsx)(t.h2,{id:"unique-aliases",children:"Unique aliases"}),"\n",(0,o.jsx)(t.p,{children:"Each expression in the SELECT output list must have a unique alias. Unique aliases are required to provide the link between the data and the metadata within the XML document."}),"\n",(0,o.jsx)(t.p,{children:"If the expression does not simply map to a column but is composite, eg. by involving a SQL function, multiple column references, a string operator or a mathematical operation, then you must supply an alias."}),"\n",(0,o.jsx)(t.p,{children:"If the expression simply maps to a column and you do not supply an alias, the Rules Engine will use the column name as an alias."}),"\n",(0,o.jsx)(t.p,{children:"If you use multiple occurrences of the same column name in your SELECT output list, the Rules Engine will generate number suffixes to distinguish between these occurrences:"}),"\n",(0,o.jsxs)(t.table,{children:[(0,o.jsx)(t.thead,{children:(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.th,{children:(0,o.jsx)(t.strong,{children:"Statement"})}),(0,o.jsx)(t.th,{children:(0,o.jsx)(t.strong,{children:"Generated unique aliases"})})]})}),(0,o.jsxs)(t.tbody,{children:[(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"SELECT id, id, id FROM emp"}),(0,o.jsx)(t.td,{children:"ID, ID_2, ID_3"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"SELECT 'Application' id, id FROM emp"}),(0,o.jsx)(t.td,{children:"ID, ID_2"})]})]})]}),"\n",(0,o.jsx)(t.p,{children:"If you use different columns with identical column names from different table instances, the Rules Engine will use the table name as a prefix to make the distinction at the alias level. In the case of two instance of the same table, it is ultimately the suffix that ensures alias uniqueness:"}),"\n",(0,o.jsxs)(t.table,{children:[(0,o.jsx)(t.thead,{children:(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.th,{children:(0,o.jsx)(t.strong,{children:"Statement"})}),(0,o.jsx)(t.th,{children:(0,o.jsx)(t.strong,{children:"Generated unique aliasesGenerated unique aliases"})})]})}),(0,o.jsxs)(t.tbody,{children:[(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"SELECT e.id, d.id FROM emp e, dept d"}),(0,o.jsx)(t.td,{children:"EMP_ID, DEPT_ID"})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"SELECT t1.id, t2.id, FROM tour t1, tour t2"}),(0,o.jsx)(t.td,{children:"TOUR_ID, TOUR_ID_2"})]})]})]}),"\n",(0,o.jsx)(t.p,{children:"If multiple SELECT clauses are connected by one or more set operators ( UNION, MINUS, INTERSECT), the first SELECT statement after the INVOKE keyword provides the alias."})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);