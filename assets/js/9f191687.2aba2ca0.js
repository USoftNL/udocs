"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[13182],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var r=t(96540);const i={},o=r.createContext(i);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:n},e.children)}},66981:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"Repositories/Data_flow_control_with_XML_or_JSON/Generating_key_values_for_parentchild_data_on_import","title":"Generating key values for parent-child data on import","description":"If you use XML.Import to import into a table for which the receiving repository normally generates unique primary key values:","source":"@site/docs/Repositories/Data_flow_control_with_XML_or_JSON/Generating_key_values_for_parentchild_data_on_import.md","sourceDirName":"Repositories/Data_flow_control_with_XML_or_JSON","slug":"/Repositories/Data_flow_control_with_XML_or_JSON/Generating_key_values_for_parentchild_data_on_import","permalink":"/udocs/Repositories/Data_flow_control_with_XML_or_JSON/Generating_key_values_for_parentchild_data_on_import","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Generating_key_values_for_parentchild_data_on_import"},"sidebar":"sidebar","previous":{"title":"Obsolete children on import","permalink":"/udocs/Repositories/Data_flow_control_with_XML_or_JSON/Obsolete_children_on_import"},"next":{"title":"XML import: Known problems and workarounds","permalink":"/udocs/Repositories/Data_flow_control_with_XML_or_JSON/XML_import_Known_problems_and_workarounds"}}');var i=t(74848),o=t(28453);const a={id:"Generating_key_values_for_parentchild_data_on_import"},s="Generating key values for parent-child data on import",l={},h=[{value:"RELATE strategy",id:"relate-strategy",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"generating-key-values-for-parent-child-data-on-import",children:"Generating key values for parent-child data on import"})}),"\n",(0,i.jsx)(n.p,{children:"If you use XML.Import to import into a table for which the receiving repository normally generates unique primary key values:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If you want this to happen also with the data being imported, make sure you ",(0,i.jsx)(n.strong,{children:"omit"})," the primary key column from the XML content."]}),"\n",(0,i.jsxs)(n.li,{children:["If you want the data being imported to keep their own primary key value, make sure you ",(0,i.jsx)(n.strong,{children:"include"})," the primary key column in the XML content. In this case you may need to take separate action to ensure that the database sequence or component generating the values does not end up with a current number lower than the highest primary key value imported, otherwise non-unique values will be generated in the future."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If you are importing a multi-table XML document with parent-child data, and the receiving repository normally generates unique primary key values in the parent table:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If you want this to happen also with the data being imported, use the ",(0,i.jsx)(n.strong,{children:"RELATE strategy"})," explained next. This ensures that child records remain connected with their parent even though a new primary key value is generated for the parent during import."]}),"\n",(0,i.jsxs)(n.li,{children:["If you want the parent-child data being imported to keep their own primary key values and foreign key values, again, make sure you ",(0,i.jsx)(n.strong,{children:"include"})," all these values in the XML content."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"relate-strategy",children:"RELATE strategy"}),"\n",(0,i.jsx)(n.p,{children:"You can import parent records for which new primary key values are generated during import (this is determined by Generate Unique Values for the domain that the parent's primary key column is based on), and have matching foreign key values generated for the child records in the process, so that the parent-child relations are still intact in the end result."}),"\n",(0,i.jsx)(n.p,{children:"To achieve this, replace each parent primary key attribute in the XML:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'column="key-value"\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"by an attribute with the special syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'table.id="key-value"\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"and add to each child element a special RELATE child element with the Parent Role name of the relationship (as defined in USoft Definer) and the attribute"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'href="#key-value"\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"so that the added RELATE element looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'<RELATE ROLE="parent-role" href="#key-value"/>\n\n'})}),"\n",(0,i.jsxs)(n.p,{children:["During import, children are connected with their parent on the basis of identical ",(0,i.jsx)(n.em,{children:"key-value."})," It does not matter what ",(0,i.jsx)(n.em,{children:"key-value"})," is, as long as it is the same value in the parent and its children and uniquely identifies the parent in the XML. ",(0,i.jsx)(n.em,{children:"Key-values"})," are only used during the import process and do not appear in the resulting database records."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<?usoft-xml version="1.0" action="multi-tables-import" use-io-formats="no" verify-original-values="no" return-corrected-records ="yes"?>\n<MultiImport>\n \xa0<Companies>\n \xa0 \xa0<COMPANY NAME="Company A" COMPANY.id="C1"/>\n \xa0</Companies>\n \xa0<Departments>\n \xa0 \xa0<DEPARTMENT NAME="Engineering" DEPARTMENT.id="D1">\n \xa0 \xa0 \xa0<RELATE ROLE="HAS" href="#C1"/>\n \xa0 \xa0</DEPARTMENT>\n \xa0 \xa0<DEPARTMENT NAME="Support" DEPARTMENT.id="D2">\n \xa0 \xa0 \xa0<RELATE ROLE="HAS" href="#C1"/>\n \xa0 \xa0</DEPARTMENT>\n \xa0</Departments>\n \xa0<Employees>\n \xa0 \xa0<EMPLOYEE NAME="Employee1" >\n \xa0 \xa0 \xa0<RELATE ROLE="HAS" href="#D1"/>\n \xa0 \xa0</EMPLOYEE>\n \xa0 \xa0<EMPLOYEE NAME="Employee2" >\n \xa0 \xa0 \xa0<RELATE ROLE="HAS" href="#D2"/>\n \xa0 \xa0</EMPLOYEE>\n \xa0</Employees>\n</MultiImport>\n\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Key-value"})," can be any value chosen by the user; USoft uses this value only to match the reference from the child record with the parent record."]}),"\n",(0,i.jsxs)(n.p,{children:["The RELATE strategy will work with parent records ",(0,i.jsx)(n.em,{children:"following"})," child records only if the foreign key of the child record is not part of the primary key or the foreign key is not mandatory, Placing parents before children improves performance during import."]})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);