"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[67847],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var o=n(96540);const r={},s=o.createContext(r);function i(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:t},e.children)}},36136:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"Repositories/Data_flow_control_with_XML_or_JSON/XML_import_Known_problems_and_workarounds","title":"XML import: Known problems and workarounds","description":"This help topic discusses typical problems with XML.Import(). Some of these problems are inherent in the USoft product and require workarounds. Others are mistakes that developers often make in practice.","source":"@site/docs/Repositories/Data_flow_control_with_XML_or_JSON/XML_import_Known_problems_and_workarounds.md","sourceDirName":"Repositories/Data_flow_control_with_XML_or_JSON","slug":"/Repositories/Data_flow_control_with_XML_or_JSON/XML_import_Known_problems_and_workarounds","permalink":"/udocs/Repositories/Data_flow_control_with_XML_or_JSON/XML_import_Known_problems_and_workarounds","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"XML_import_Known_problems_and_workarounds"},"sidebar":"sidebar","previous":{"title":"Generating key values for parent-child data on import","permalink":"/udocs/Repositories/Data_flow_control_with_XML_or_JSON/Generating_key_values_for_parentchild_data_on_import"},"next":{"title":"Example: XML export with DTD name and IO formats","permalink":"/udocs/Repositories/Data_flow_control_with_XML_or_JSON/Example_XML_export_with_DTD_name_and_IO_formats"}}');var r=n(74848),s=n(28453);const i={id:"XML_import_Known_problems_and_workarounds"},a="XML import: Known problems and workarounds",l={},c=[{value:"Parents and children must stay together but with newly generated values",id:"parents-and-children-must-stay-together-but-with-newly-generated-values",level:3},{value:"Non-supplied mandatory subtype columns without default",id:"non-supplied-mandatory-subtype-columns-without-default",level:3},{value:"&quot;Double insert&quot; conflict with <code>&lt;Insert/&gt;</code> tags for subtypes",id:"double-insert-conflict-with-insert-tags-for-subtypes",level:3},{value:"",id:"",level:3},{value:"&quot;Double delete&quot; conflict with <code>&lt;Delete/&gt;</code> tags for cascading deletes",id:"double-delete-conflict-with-delete-tags-for-cascading-deletes",level:3},{value:"Unwanted drop of obsolete children",id:"unwanted-drop-of-obsolete-children",level:3}];function d(e){const t={code:"code",em:"em",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"xml-import-known-problems-and-workarounds",children:"XML import: Known problems and workarounds"})}),"\n",(0,r.jsx)(t.p,{children:"This help topic discusses typical problems with XML.Import(). Some of these problems are inherent in the USoft product and require workarounds. Others are mistakes that developers often make in practice."}),"\n",(0,r.jsx)(t.h3,{id:"parents-and-children-must-stay-together-but-with-newly-generated-values",children:"Parents and children must stay together but with newly generated values"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Problem"})}),"\n",(0,r.jsx)(t.p,{children:"If you import a multi-table XML document that contains generated parent primary key values, and also child foreign keys values referring to these primary key values, then parents and children will remain correctly related to each other in the end result."}),"\n",(0,r.jsx)(t.p,{children:"But if you import a multi-table XML document that contains parents and children, and you do NOT supply values for the parent primary key, the receiving repository will generate its own values for the incoming records. This may be intended, but you must make sure that matching foreign key values are generated on import. If you don't, children will no longer refer to the correct parent after import."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Solution"})}),"\n",(0,r.jsx)(t.p,{children:"Follow the RELATE strategy."}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h3,{id:"non-supplied-mandatory-subtype-columns-without-default",children:"Non-supplied mandatory subtype columns without default"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Problem"})}),"\n",(0,r.jsx)(t.p,{children:"The import of a record that has a subtype indicator for a subtype S with value 'Y' automatically causes the Rules Engine to insert also a record for S itself. This second insert fails if S has a mandatory column without default, since the value for that column is required but not supplied at the time the record is created. A column is \"without default\" if its Default Value attribute is empty, and the Default Value attribute of its Domain is also empty, and there is also no constraint that allows the Rules Engine to supply a default value."}),"\n",(0,r.jsxs)(t.p,{children:["This problem occurs if the supertype record appears earlier in the import document than the record for S, or if the document contains no record for S at all. It also occurs if S has a sibling subtype and a record for this sibling subtype appears earlier in the document than the record for S. If S and the sibling subtype ",(0,r.jsx)(t.em,{children:"each"})," have a mandatory column without default, then the problem occurs regardless of document order."]}),"\n",(0,r.jsx)(t.p,{children:'The problem occurs independently of whether the "Create Separate Table" attribute of S is set to Yes or to No.'}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Solution 1"})}),"\n",(0,r.jsx)(t.p,{children:"This solution works only if the receiving repository does NOT have 'Y' as the default value for the subtype indicator."}),"\n",(0,r.jsx)(t.p,{children:"Make sure that the import document does not contain subtype indicators. The Rules Engine in the receiving repository will not set the 'Y' indicator until the subtype record comes in, at which time the mandatory value is supplied."}),"\n",(0,r.jsx)(t.p,{children:'To strip subtype indicators, you can call the XML.MultiExportTables export method. It automatically suppresses all subtype indicators from the document. In USoft Delivery Manager, you can execute the "Export metadata" action. It has the same effect.'}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Solution 2"})}),"\n",(0,r.jsx)(t.p,{children:"Make sure that supertype sections in the import document list only supertype records for instances that are not also a subtype (or more than one subtype)."}),"\n",(0,r.jsx)(t.p,{children:"To suppress supertype records for instances that are also a subtype, you can call the XML.MultiExportTables export method with the RestrictiveSupertypeListing parameter set to 'yes'."}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsxs)(t.h3,{id:"double-insert-conflict-with-insert-tags-for-subtypes",children:['"Double insert" conflict with ',(0,r.jsx)(t.code,{children:"<Insert/>"})," tags for subtypes"]}),"\n",(0,r.jsx)(t.p,{children:"*\xa0Problem*"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"<Insert/>"})," instruction tags for the import of a new subtype constellation can lead to a unique-key error if the engine is instructed to insert the same primary key twice, once for the supertype and once for the subtype."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Solution"})}),"\n",(0,r.jsxs)(t.p,{children:["Strip the ",(0,r.jsx)(t.code,{children:"<Insert/>"})," tags. The record(s) where you removed the ",(0,r.jsx)(t.code,{children:"<Insert/>"}),' tag will still be inserted as per the default "UPSERT" behavior.']}),"\n",(0,r.jsxs)(t.p,{children:["You can strip ",(0,r.jsx)(t.code,{children:"<Insert/>"}),' tags by applying an XSLT transformation to the document that has the following template or a similar template. To make XSLT operations optimally traceable, use USoft Delivery Manager, for example its "Added XSL" feature.']}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:'<xsl:template match="Insert"/>\n\n'})}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h3,{id:"",children:"\xa0"}),"\n",(0,r.jsxs)(t.h3,{id:"double-delete-conflict-with-delete-tags-for-cascading-deletes",children:['"Double delete" conflict with ',(0,r.jsx)(t.code,{children:"<Delete/>"})," tags for cascading deletes"]}),"\n",(0,r.jsx)(t.p,{children:"*\xa0Problem*"}),"\n",(0,r.jsxs)(t.p,{children:["A ",(0,r.jsx)(t.code,{children:"<Delete/>"})," instruction tag can lead to an error if a parent delete with Delete Rule = Cascading appears earlier in XML document order than the corresponding child delete. When the child delete is processed, the error is that the child cannot be found."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.em,{children:"Solution"}),"\nMake sure that the Rules Engine does not check whether the record to be deleted actually exists. One way to achieve this is to call XML.Import with the VerifyOriginalValues parameter set to NoCheckOnPk. Alternatively, make sure that your import document has the setting ",(0,r.jsx)(t.strong,{children:'verify-original-values="no-check-on-pk"'})," in its usoft-xml processing instruction."]}),"\n",(0,r.jsx)(t.p,{children:'You can reset an usoft-xml processing instruction by applying an XSLT transformation that has the following template or a like template. To make XSLT operations optimally traceable, use USoft Delivery Manager, for example its "Added XSL" feature.'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:'<xsl:template match="processing-instruction()[local-name()=\'usoft-xml\']">\n \xa0<xsl:processing-instruction name="usoft-xml">\n \xa0 \xa0<xsl:text>\n \xa0 \xa0 \xa0version="1.0" action="multi-tables-import" use-io-formats="no" \n \xa0 \xa0 \xa0verify-original-values="no-check-on-pk" return-corrected-records ="yes"\n \xa0 \xa0</xsl:text>\n \xa0</xsl:processing-instruction>\n</xsl:template>\n\n'})}),"\n",(0,r.jsx)(t.p,{children:"\xa0"}),"\n",(0,r.jsx)(t.h3,{id:"unwanted-drop-of-obsolete-children",children:"Unwanted drop of obsolete children"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Problem"})}),"\n",(0,r.jsxs)(t.p,{children:["Importing a parent record and a new set of child records can cause existing children, so-called obsolete children, in the receiving repository to be automatically dropped if the relation has Type Of Relationship = Composition. This is especially confusing if the import document specifies ",(0,r.jsx)(t.code,{children:"<Insert/>"})," instruction tags for the children, because this wrongly suggests that the new children will be ",(0,r.jsx)(t.em,{children:"added"})," to the existing children."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"Solution"})}),"\n",(0,r.jsxs)(t.p,{children:["Disable the effect of Type Of Relationship = Composition during import. Do this by making sure that the import document has the setting ",(0,r.jsx)(t.strong,{children:'relationship-behaviour="as-reference"'}),' in its usoft-xml processing instruction. You can reset an usoft-xml processing instruction by applying an XSLT transformation that has the following template or a similar template. To make XSLT operations optimally traceable, use USoft Delivery Manager, for example its "Added XSL" feature.']}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-xml",children:'<xsl:template match="processing-instruction()[local-name()=\'usoft-xml\']">\n \xa0<xsl:processing-instruction name="usoft-xml">\n \xa0 \xa0<xsl:text>\n \xa0 \xa0 \xa0version="1.0" action="multi-tables-import" use-io-formats="no" \n \xa0 \xa0 \xa0relationship-behaviour="as-reference" return-corrected-records ="yes"\n \xa0 \xa0</xsl:text>\n \xa0</xsl:processing-instruction>\n</xsl:template>\n\n'})}),"\n",(0,r.jsx)(t.p,{children:"\xa0"})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);