"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[87199],{24673:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"Repositories/Blend_scripts_for_repository_management/Guide_to_Blend_expressions_and_data_types","title":"Guide to Blend expressions and data types","description":"USoft Blend combines operating system file paths, XML fragments, XPath expressions, SQL statements, JSON fragments, and many more to provide a complete and highly expressive tool for installing, delivering and maintaining instances of USoft applications.","source":"@site/docs/Repositories/Blend_scripts_for_repository_management/Guide_to_Blend_expressions_and_data_types.md","sourceDirName":"Repositories/Blend_scripts_for_repository_management","slug":"/Repositories/Blend_scripts_for_repository_management/Guide_to_Blend_expressions_and_data_types","permalink":"/udocs/Repositories/Blend_scripts_for_repository_management/Guide_to_Blend_expressions_and_data_types","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Guide_to_Blend_expressions_and_data_types"},"sidebar":"sidebar","previous":{"title":"Guide to Blend debugging","permalink":"/udocs/Repositories/Blend_scripts_for_repository_management/Guide_to_Blend_debugging"},"next":{"title":"Blend directives","permalink":"/udocs/Repositories/Blend_directives"}}');var r=s(74848),i=s(28453);const l={id:"Guide_to_Blend_expressions_and_data_types"},a="Guide to Blend expressions and data types",d={},o=[{value:"Literal expressions",id:"literal-expressions",level:2},{value:"Date literals",id:"date-literals",level:3},{value:"String literals",id:"string-literals",level:3},{value:"Path expressions",id:"path-expressions",level:2},{value:"Absolute paths and relative paths",id:"absolute-paths-and-relative-paths",level:3},{value:"File paths and folder paths",id:"file-paths-and-folder-paths",level:3},{value:"File name patterns",id:"file-name-patterns",level:3},{value:"Directory name patterns",id:"directory-name-patterns",level:3},{value:"XML expressions",id:"xml-expressions",level:2},{value:"xml-fragment",id:"xml-fragment",level:3},{value:"Explanation",id:"explanation",level:4},{value:"Examples",id:"examples",level:4},{value:"xml-fragment",id:"xml-fragment-1",level:3},{value:"Explanation",id:"explanation-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"xml-document",id:"xml-document",level:3},{value:"Explanation",id:"explanation-2",level:4},{value:"Examples",id:"examples-2",level:4},{value:"xml-text",id:"xml-text",level:3},{value:"Explanation",id:"explanation-3",level:4},{value:"Examples",id:"examples-3",level:4},{value:"embedded-xml",id:"embedded-xml",level:3},{value:"Explanation",id:"explanation-4",level:4},{value:"Examples",id:"examples-4",level:4},{value:"Embedded XML",id:"embedded-xml-1",level:3},{value:"SQL expressions",id:"sql-expressions",level:2},{value:"USoft-supported SQL syntax",id:"usoft-supported-sql-syntax",level:3},{value:"RDBMS-supported SQL syntax",id:"rdbms-supported-sql-syntax",level:3},{value:"XPath expressions",id:"xpath-expressions",level:2},{value:"Overview",id:"overview",level:3},{value:"Node set expressions",id:"node-set-expressions",level:3},{value:"Booleans",id:"booleans",level:3},{value:"Strings",id:"strings",level:3},{value:"Numbers",id:"numbers",level:3},{value:"Function calls",id:"function-calls",level:3},{value:"Variable references",id:"variable-references",level:3},{value:"Implicit XPath data type conversion",id:"implicit-xpath-data-type-conversion",level:3},{value:"Evaluated expressions vs. literal expressions",id:"evaluated-expressions-vs-literal-expressions",level:2},{value:"Automatic evaluation",id:"automatic-evaluation",level:3},{value:"Attribute Value Templates",id:"attribute-value-templates",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"guide-to-blend-expressions-and-data-types",children:"Guide to Blend expressions and data types"})}),"\n",(0,r.jsx)(n.p,{children:"USoft Blend combines operating system file paths, XML fragments, XPath expressions, SQL statements, JSON fragments, and many more to provide a complete and highly expressive tool for installing, delivering and maintaining instances of USoft applications.\nThis help section helps you understand the most frequently encountered expression types and their data types. It concentrates on their use in a USoft Blend context. Look elsewhere for tutorials on the languages themselves, for example, on XPath."}),"\n",(0,r.jsx)(n.h2,{id:"literal-expressions",children:"Literal expressions"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.em,{children:"literal expression"})," is an expression made up of Unicode characters and not specific to any technology such as: Windows file system paths, SQL, XML, or XPath/XSLT."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Type"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Explanation"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Examples"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"csv-list"})}),(0,r.jsxs)(n.td,{children:["A comma-separated list of ",(0,r.jsx)(n.em,{children:"string-literal"})," values"]}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{children:["oracle,sqlserver,jdbc",(0,r.jsx)("br",{}),"0,1"]})}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"date-literal"})}),(0,r.jsx)(n.td,{children:"A string that is susceptible to being interpreted as an indication of a date, or of a date and a time."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{children:["12-05-2019",(0,r.jsx)("br",{}),"12-MAY-2019 13:00"]})}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"integer-literal"})}),(0,r.jsx)(n.td,{children:"An integer number"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{children:["0",(0,r.jsx)("br",{}),"1000"]})}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"string-literal"})}),(0,r.jsx)(n.td,{children:(0,r.jsxs)("p",{children:["A simple alphanumeric string that is allowable as an identifier of an object. Subsets ",(0,r.jsx)(n.em,{children:"text-literal"}),"."]})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{children:["myalias",(0,r.jsx)("br",{}),"MyAlias",(0,r.jsx)("br",{}),"MyAlias_4"]})}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"text-literal"})}),(0,r.jsx)(n.td,{children:"A string of Unicode characters including interpunction characters and whitespace"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"Default-8090@C:\\USoft\\servers\\Default\\"}),(0,r.jsx)("p",{children:"\xa0"})]})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"date-literals",children:"Date literals"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Date literal"})," is a data type for string values susceptible of being interpreted as an indication of a date, or of a date and a time, for example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"12-05-2019\n12-MAY-2019 13:00\n"})}),"\n",(0,r.jsx)(n.p,{children:"XPath does not have a special data type for dates or clock times. USoft Blend is able to interpret (XPath and non-XPath) string expressions as indications of date or time by applying the list of format masks that is returned by:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:value-of select="dates:ShowInputFormats" />\n'})}),"\n",(0,r.jsx)(n.p,{children:"For example, the following string:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"12-05-2019\n"})}),"\n",(0,r.jsx)(n.p,{children:"is interpreted as an expression of May 12, 2019 if the following date format mask is featured in this list:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"DD-MM-YYYY\n"})}),"\n",(0,r.jsx)(n.h3,{id:"string-literals",children:"String literals"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"String literal"})," is a USoft Blend data type for simple single-word, name-like strings that serve to identify objects.\nIn the XML model, string literals occur in a number of different contexts, notably as a text node surrounded by the start tag and end tag of an XML element, and as a simple attribute value. Because of the USoft XML format that USoft Blend often processes, in which data corresponding to database records is placed in attribute values, asimple attribute values tend to be the most relevant context for string literals processed by USoft Blend.\nA string literal is a sequence made up of ASCII alphabetic characters (A-Z, a-z), hyphens (\xa0-\xa0), underscores (\xa0_\xa0) and full stops (\xa0.\xa0) but not whitespace and not colons. Digits (0-9) are also allowed but not as the first character.\nExamples of valid string literals include:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"myalias\nMyAlias\nMyAlias_4\n"})}),"\n",(0,r.jsx)(n.p,{children:"Examples of INVALID string literals include:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"^variable\n(variable)\nmy variable\n4_Alias\npc:if\n"})}),"\n",(0,r.jsx)(n.h2,{id:"path-expressions",children:"Path expressions"}),"\n",(0,r.jsx)(n.p,{children:"In contexts where folders or files are expected, the USoft Blend framework processes path expressions. They are the expressions that Microsoft Windows supports for designating (sets of) folders and files on the file system in command line syntax, ie., in the context of a Command Line Prompt (cmd.exe)."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Data type"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Explanation"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Examples"})})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"path"})}),(0,r.jsx)(n.td,{children:"An expression that points to a file or folder on the file system, or to a set of files or folders"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{children:["c:\\temp\\MyFolder",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"temp\\MyFolder<br/>",(0,r.jsx)("br",{}),"\\fs\\temp\\MyExample.xml",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"..\\MyExample.xml",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"temp*.xml",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"c:/temp/MyFolder"]})}),(0,r.jsx)("p",{children:"\xa0"})]})]})})]}),"\n",(0,r.jsx)(n.p,{children:"Many path expressions are a sequence of steps separated by backslashes that traverse the file system to point at the target file(s) or folder(s):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"c:\\MyFolder\\MySubFolder\\MyFile.txt\n"})}),"\n",(0,r.jsx)(n.p,{children:"In the Windows OS, the backslash (\xa0\\\xa0) is the most common separator symbol between steps. It is the separator symbol required in DOS command lines. The USoft Blend API accepts the forward slash (\xa0/\xa0) as an alternative. But because of the mix of paths and XPath expressions, best practice in USoft Blend scripting is to reserve the backward slash for path expressions and the forward slash for XPath expressions.\nSteps are not allowed to contain spaces, but they may contain underscores (\xa0_\xa0) and hyphens (\xa0\u2011\xa0).\nIf a path ends in a backslash, the path matches only a folder, not any file in that folder:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"c:\\temp\\\n"})}),"\n",(0,r.jsx)(n.p,{children:'If the rightmost step is intended as a file name, one or more asterisks (\xa0*\xa0) in this file name act as wildcards representing any number of characters. The following path pattern points to all the files with extension ".xml" in the "c:\\temp" folder:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"c:\\temp\\*.xml\n"})}),"\n",(0,r.jsx)(n.h3,{id:"absolute-paths-and-relative-paths",children:"Absolute paths and relative paths"}),"\n",(0,r.jsx)(n.p,{children:"Each path is either an absolute path or a relative path:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Data type"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Explanation"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Examples"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"absolute-path"})}),(0,r.jsx)(n.td,{children:"A path that points at a file or folder, or set of files or folders, independently of the working context."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{children:["c:\\temp\\MyExample.xml",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"d:\\temp\\MySubDirectory",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"\\fs\\temp*.xml",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"\\fs.mycompany.com\\temp$\\MyExample.xml"]})}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"relative-path"})}),(0,r.jsx)(n.td,{children:"A path that points at a file or folder, or set of files or folders by taking the working folder as a starting point."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{children:["MyExample.xml",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"MySubDirectory*.xml",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"..\\MyExample.xml",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),".\\MyExample.xml"]})}),(0,r.jsx)("p",{children:"\xa0"})]})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"An absolute path is a path that starts with a letter indicating a local drive:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"c:\\temp\\MyExample.xml\nd:\\temp\\MyExample.xml\n"})}),"\n",(0,r.jsx)(n.p,{children:"or with a double backslash indicating a shared drive:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\\\\fs\\temp$\\MyExample.xml\n\\\\fs.mycompany.com\\temp$\\MyExample.xml\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"A relative path is any other path. A relative path is interpreted relatively to the current directory or working directory, where the leftmost element is a child folder or file relative to the current directory:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"temp\\MyExample.xml\n"})}),"\n",(0,r.jsx)(n.p,{children:"At the beginning of a relative path, a double full stop (\xa0..\xa0) represents the parent directory of the current directory or working directory. Using this syntax, it is possible to point to ancestors at higher levels:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"..\\temp\\MyExample.xml\n..\\..\\temp\\MyExample.xml\n"})}),"\n",(0,r.jsx)(n.p,{children:"At the beginning of a relative path, a single full stop (\xa0.\xa0) represents the current directory or working directory itself. In USoft Blend this is useful in calls like the following, which returns the full path to the current directory:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"path:GetFullPath('.')\n"})}),"\n",(0,r.jsx)(n.h3,{id:"file-paths-and-folder-paths",children:"File paths and folder paths"}),"\n",(0,r.jsx)(n.p,{children:"Each path is either a file path or a folder path:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Data type"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Explanation"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Examples"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"file-path"})}),(0,r.jsxs)(n.td,{children:["A ",(0,r.jsx)(n.em,{children:"path"})," in which the rightmost step is interpreted as the name of a file, or as an expression pointing to a set of files."]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"c:\\temp\\MyExample.xml"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"folder-path"})}),(0,r.jsxs)(n.td,{children:["A ",(0,r.jsx)(n.em,{children:"path"})," in which the rightmost step is interpreted as the name of a folder."]}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"c:\\temp\\MySubDirectory"})," ",(0,r.jsx)(n.code,{children:"c:\\temp\\MySubDirectory\\"})]})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["In a ",(0,r.jsx)(n.em,{children:"file-path"}),", the rightmost step is interpreted as the name of a file, or as file pattern pointing at a set of files. In a folder path, the rightmost step is interpreted as the name of a folder.\nYou can enforce that the rightmost step must be interpreted as a folder rather than a file by adding a trailing backslash:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"c:\\temp\\MySubDirectory\\\n"})}),"\n",(0,r.jsx)(n.p,{children:'For a path expression not ending in a backslash, there is no formal way of knowing whether the rightmost step is intended to point at a directory or at a file. The following example is likely to point at all the files in the "c:\\temp" folder that have the ".xml" file extension, but theoretically it is possible that it points at a set of directory names ending in ".xml". File names are allowed to not contain full stops. Folder names are allowed to contain full stops.'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"c:\\temp\\*.xml\n"})}),"\n",(0,r.jsx)(n.p,{children:"This example uses as asterisk as a wildcard, turning the rightmost step into a pattern. See next two sections."}),"\n",(0,r.jsx)(n.h3,{id:"file-name-patterns",children:"File name patterns"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.em,{children:"file name pattern"}),' is a file name that contains an asterisk (\xa0*\xa0) in one or more places. The asterisk acts as a wildcard for file names. The following file name pattern represents all files with extension ".xml" in the given context:']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"*.xml\n"})}),"\n",(0,r.jsx)(n.p,{children:'A file name pattern may occur as the rightmost step of a file path. The following file path represents all files with extension ".xml" in directory "c:\\temp":'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"c:\\temp\\*.xml\n"})}),"\n",(0,r.jsx)(n.p,{children:"A file name pattern may also occur as an attribute value in selected contexts, for example, as the value of the filter attribute of pc:Directory:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:Directory filepath="c:\\temp" filter="*.xml">\n'})}),"\n",(0,r.jsx)(n.h3,{id:"directory-name-patterns",children:"Directory name patterns"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.em,{children:"directory name pattern"})," is a step in a path expression that contains an asterisk (\xa0*\xa0) in one or more places and does not, or not exclusively, point at files.\nThe asterisk acts as a wildcard for both directory names and file names found in the current directory. Each step acts as a filter for directories and files that further restricts the result:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Directory name pattern"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Matches"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"*"}),(0,r.jsx)("p",{children:"\xa0"})]}),(0,r.jsx)(n.td,{children:"The entire content of the current directory, including subdirectories (to any level deep)."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"*.xml"}),(0,r.jsx)("p",{children:"\xa0"})]}),(0,r.jsxs)(n.td,{children:['All the files in the current directory that have the ".xml" extension.',(0,r.jsx)("br",{}),"   All the subdirectories of which the name ends in .xml, including all their file contents and all subdirectories and their contents (to any level deep)."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"asset*"}),(0,r.jsx)("p",{children:"\xa0"})]}),(0,r.jsx)(n.td,{children:"All the subdirectories and files of which the name starts with asset, including (in the case of the subdirectories) all file contents and all subdirectories and their contents (to any level deep)."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"asset*\\resource*"}),(0,r.jsx)("p",{children:"\xa0"})]}),(0,r.jsx)(n.td,{children:"All the subdirectories A of which the name starts with asset and that have a subdirectory B or file B that starts with resource. For each subdirectory A, all the subdirectories B with all their content (to any level deep), and also, all the files B."})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"xml-expressions",children:"XML expressions"}),"\n",(0,r.jsxs)(n.p,{children:["In contexts where XML is expected, the USoft Blend framework processes literal XML and expressions evaluating to literal XML. This XML must be valid according to the XML 1.0 specification by W3C.\nUSoft uses XML to describe data that must be exported, imported, compared, delivered, configured outside a USoft repository. The first examples in the table below are in this format.\nUSoft Blend uses XML to facilitate composite input and output of directives. This is referred to as ",(0,r.jsx)(n.em,{children:"embedded XML"}),"*:*"]}),"\n",(0,r.jsx)(n.h3,{id:"xml-fragment",children:"xml-fragment"}),"\n",(0,r.jsx)(n.h4,{id:"explanation",children:"Explanation"}),"\n",(0,r.jsx)(n.p,{children:"An XML structure consisting of one or more XML nodes."}),"\n",(0,r.jsx)(n.h4,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<T_AUTH_USER USERNAME="admin"/>\n<T_AUTH_USER USERNAME="admin2"/>\n\n<Users>\n   <T_AUTH_USER USERNAME="admin"/>\n   <T_AUTH_USER USERNAME="admin2"/>\n</Users>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"xml-fragment-1",children:"xml-fragment"}),"\n",(0,r.jsx)(n.p,{children:"(Also: an expression evaluating to such a structure.)"}),"\n",(0,r.jsx)(n.h4,{id:"explanation-1",children:"Explanation"}),"\n",(0,r.jsx)(n.p,{children:"An expression evaluating to an XML structure."}),"\n",(0,r.jsx)(n.h4,{id:"examples-1",children:"Examples"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<msg>Logging in: \n  <pc:value-of select="$logfile"/>...\n  <pc:newline/>\n</msg>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"xml-document",children:"xml-document"}),"\n",(0,r.jsx)(n.h4,{id:"explanation-2",children:"Explanation"}),"\n",(0,r.jsxs)(n.p,{children:["An XML fragment that is a valid XML document, i.e., that has a single top-level node (",(0,r.jsx)(n.em,{children:"document node"}),").\nAn expression evaluating to such a structure.\nSubsets ",(0,r.jsx)(n.em,{children:"xml-fragment"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"examples-2",children:"Examples"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<Users>\n   <T_AUTH_USER USERNAME="admin"/>\n   <T_AUTH_USER USERNAME="admin2"/>\n</Users>\n\n<msg>\n   Logging in: <pc:value-of select="$logfile"/>...\n   <pc:newline/>\n</msg>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"xml-text",children:"xml-text"}),"\n",(0,r.jsx)(n.h4,{id:"explanation-3",children:"Explanation"}),"\n",(0,r.jsxs)(n.p,{children:["An XML fragment that is a valid XML text node.\nAn expression evaluating to a valid XML text node.\nSubsets ",(0,r.jsx)(n.em,{children:"xml-fragment"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"examples-3",children:"Examples"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'admin2\n\nLogging in: <pc:value-of select="$logfile"/>...\n<pc:newline/>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"embedded-xml",children:"embedded-xml"}),"\n",(0,r.jsx)(n.h4,{id:"explanation-4",children:"Explanation"}),"\n",(0,r.jsx)(n.p,{children:"An XML fragment (usually, an XML document) that is allowed to be a child node of a USoft Blend directive, or is returned by a USoft Blend directive, or both."}),"\n",(0,r.jsx)(n.h4,{id:"examples-4",children:"Examples"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:Dialog>\n   <Form w="250">\n      <Title>USoft Blend dialog</Title>\n      <Label dx="5" dy="10" w="40" >\n        This is a USoft Blend dialog.\n      </Label>      \n      <Button dy="20" newline="true">\n        <Result>OK</Result>OK\n      </Button>\n   </Form>\n</pc:Dialog>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"embedded-xml-1",children:"Embedded XML"}),"\n",(0,r.jsxs)(n.p,{children:["Some USoft Blend directives are designed to contain and return a subsystem of XML elements referred to as embedded XML.\nEmbedded XML is a specialised use of XML. It is specific to the USoft Blend framework. In each case, embedded XML has the structure of an XML document: it contains a single top-level node (the document node).\n",(0,r.jsx)(n.em,{children:"Example"}),"\nThis example shows XML embedded in a pc",":Dialog"," element."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:Dialog>\n   <Form w="250">\n      <Title>USoft Blend dialog</Title>\n      <Label dx="5" dy="10" w="40" >This is a USoft Blend dialog.</Label>      \n      <Button dy="20" newline="true"><Result>OK</Result>OK</Button>\n   </Form>\n</pc:Dialog>\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Embedded XML as input"})}),"\n",(0,r.jsxs)(n.p,{children:["In some cases you can pass embedded XML as part of your script. The example of this help topic shows that in pc",":Dialog",", you can pass embedded XML to specify the visual aspects and the behaviour of the dialog."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Embedded XML as output"})}),"\n",(0,r.jsxs)(n.p,{children:["Some directives return embedded XML as an output value. For example, pc",":Directory"," returns embedded XML that describes the files and folders of a directory:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<Directory dirpath="c:\\temp\\" dirname="temp" \n        lastwrite="2019/0109100614">\n  <Directory dirpath="c:\\temp\\mydir2" dirname="mydir2" \n        lastwrite="2019/0109100620">\n    <File filepath="c:\\temp\\mydir2\\myfile3.txt" filename="myfile3.xml" \n        lastwrite="2019/0109093257" />\n    <File filepath="c:\\temp\\mydir2\\myfile4.txt" filename="myfile4.txt" \n        lastwrite="2019/0109100021" />\n  </Directory>\n    <File filepath="c:\\temp\\myfile1.xml" filename="myfile1.xml" \n        lastwrite="2019/0109093257" />\n</Directory>\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Embedded XML as output, changing pc",":return"]})}),"\n",(0,r.jsxs)(n.p,{children:["To ",(0,r.jsx)(n.em,{children:"change"})," the embedded XML that you get as output, use the special pc",":return"," attribute on the directive. Values of ",(0,r.jsxs)(n.strong,{children:["pc",":return"]})," take the root node of the embedded XML as the root node (for absolute location path values) and as the context node (for relative location path values), so that the two following location paths return the same result:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:Directory filepath="c:\\temp" pc:return="/Directory/File" />\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:Directory filepath="c:\\temp" pc:return="Directory/File" />\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Embedded XML as output, referring to: assign",":variable"]})}),"\n",(0,r.jsxs)(n.p,{children:["To ",(0,r.jsx)(n.em,{children:"refer"}),", later in your Blend script, to information in the embedded XML that you get as output, use an ",(0,r.jsxs)(n.strong,{children:["assign",":variable"]})," attribute on the directive.\nThe following example selects the /Directory/File nodes from the embedded XML returned by pc",":Directory",". You can refer to these nodes later in your script by writing ",(0,r.jsx)(n.strong,{children:"$myfiles"}),". Values of ",(0,r.jsxs)(n.strong,{children:["assign",":variable"]})," take the root node of the embedded XML as the root node (for absolute location path values) and as the context node (for relative location path values), so that the following 2 location paths return the same result:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:Directory filepath="c:\\temp"\n    assign:myfiles="/Directory/File" />\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:Directory filepath="c:\\temp"\n    assign:myfiles="Directory/File" />\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Embedded XML as output, automatically suppressed"})}),"\n",(0,r.jsxs)(n.p,{children:["USoft Blend automatically suppresses the output of embedded XML if you use a ",(0,r.jsxs)(n.strong,{children:["pc",":return"]})," or ",(0,r.jsxs)(n.strong,{children:["assign",":variable"]})," attribute on the directive. This behaviour is based on the idea that if you have a reason to use ",(0,r.jsxs)(n.strong,{children:["pc",":return"]})," or ",(0,r.jsxs)(n.strong,{children:["assign",":variable"]}),", then you are unlikely to be interested in seeing the standard return XML as well.\nAs a result, if you simply want to suppress the return XML altogether, you can write one"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Embedded XML as a variable set: pc",":defs"]})}),"\n",(0,r.jsxs)(n.p,{children:["You can read, configure, and edit embedded XML programmatically. One way is to place embedded XML in a ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"<pc:defs>"})})," section of your script. You can then mobilise it when you need it, for example, to produce a certain type of dialog with ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"<pc:Dialog>"})}),". If you work in this way, embedded XML has the role of a variable set."]}),"\n",(0,r.jsx)(n.h2,{id:"sql-expressions",children:"SQL expressions"}),"\n",(0,r.jsxs)(n.p,{children:["In contexts where SQL is expected, the USoft Blend framework processes full SQL statements. Their data type subsets the ",(0,r.jsx)(n.em,{children:"string"})," data type."]}),"\n",(0,r.jsx)(n.h3,{id:"usoft-supported-sql-syntax",children:"USoft-supported SQL syntax"}),"\n",(0,r.jsxs)(n.p,{children:["This type of SQL runs in a USoft context and is portable across database platforms. See the ",(0,r.jsx)(n.a,{href:"/Modeller_and_Rules_Engine/SQL_syntax",children:"SQL syntax"})," section for details of USoft-supported SQL syntax."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Data type"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Explanation"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Examples"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"sql-statement"})}),(0,r.jsx)(n.td,{children:"A SQL statement with a syntax supported by USoft that starts with one of the keywords SELECT, INVOKE, INSERT, UPDATE, DELETE."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{class:"language-sql",children:["SELECT DESTINATION, TOUR_TYPE FROM TOUR",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"UPDATE TOUR SET MAX_AGE = 80 ",(0,r.jsx)("br",{}),"WHERE DESTINATION = 'AUSTRALIA'",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"INVOKE batchrunner.DELETE_ACCOUNT WITH",(0,r.jsx)("br",{}),"SELECT '221' \"ACCOUNT_NUMBER\""]})}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"select-statement"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("p",{children:"A SQL statement with a syntax supported by USoft that starts with the SELECT keyword."}),(0,r.jsxs)("p",{children:["Subsets ",(0,r.jsx)(n.em,{children:"sql-statement"}),"."]})]}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"SELECT DESTINATION, TOUR_TYPE FROM TOUR"}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"dml-statement"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("p",{children:"A SQL statement with a syntax supported by USoft that starts with one of the keywords INSERT, UPDATE, DELETE."}),(0,r.jsxs)("p",{children:["Subsets ",(0,r.jsx)(n.em,{children:"sql-statement"}),"."]})]}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{class:"language-sql",children:["UPDATE TOUR SET MAX_AGE = 80 ",(0,r.jsx)("br",{}),"WHERE DESTINATION = 'AUSTRALIA'"]})}),(0,r.jsx)("p",{children:"\xa0"})]})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"rdbms-supported-sql-syntax",children:"RDBMS-supported SQL syntax"}),"\n",(0,r.jsx)(n.p,{children:"This type of SQL is dependent on the database platform. See the database vendor's documentation for details of SQL syntax supported by the RDBMS."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Data type"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Explanation"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Examples"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"rdbms-ddl-statement"})}),(0,r.jsx)(n.td,{children:"A SQL statement with a syntax supported by the RDBMS that starts with one of the keywords CREATE, ALTER, DROP."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"ALTER TABLE TOUR ..."}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"rdbms-ddl-dml-statement"})}),(0,r.jsxs)(n.td,{children:["Either an ",(0,r.jsx)(n.em,{children:"rdbms\u2011ddl\u2011statement"})," or an ",(0,r.jsx)(n.em,{children:"rdbms\u2011dml\u2011statement"}),"."]}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{class:"language-sql",children:["ALTER TABLE TOUR ...",(0,r.jsx)("br",{}),"UPDATE TOUR ..."]})}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"rdbms-dml-statement"})}),(0,r.jsx)(n.td,{children:"A SQL statement with a syntax supported by the RDBMS that starts with one of the keywords INSERT, UPDATE, DELETE."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"UPDATE TOUR ..."}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"rdbms-query"})}),(0,r.jsx)(n.td,{children:"A SQL statement with a syntax supported by the RDBMS that starts with the SELECT keyword."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"SELECT ... FROM TOUR ..."}),(0,r.jsx)("p",{children:"\xa0"})]})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"xpath-expressions",children:"XPath expressions"}),"\n",(0,r.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["In XPath contexts, the USoft Blend framework processes ",(0,r.jsx)(n.em,{children:"XPath expressions"}),".\nXPath is embedded in XSLT 1.0 and in USoft Blend. It is a general expression language with node set expressions as its specialising characteristic. Node set expressions are evaluated relative to a location in an XML document being traversed. They allow you to point from that context to nodes in the XML document in a set-oriented fashion.\nAll the XPath 1.0 types of expression and their data types apply:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Type of XPath expression"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Returns type"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Explanation"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Examples"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)("p",{children:(0,r.jsx)(n.em,{children:"xpath-expression"})}),(0,r.jsxs)("p",{children:["(for short: ",(0,r.jsx)(n.em,{children:"xpath"}),")"]})]}),(0,r.jsx)(n.td,{children:"(Any)"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("p",{children:"Any XPath expression."}),(0,r.jsxs)("p",{children:["All the items in this table subset ",(0,r.jsx)(n.em,{children:"xpath-expression"}),"."]})]}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"node-set-expression"})}),(0,r.jsx)(n.td,{children:"Node set"}),(0,r.jsx)(n.td,{children:"An XPath expression representing a node set."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{children:["node()",(0,r.jsx)("br",{}),"pc:*",(0,r.jsx)("br",{}),"/parent/child[1]"]})}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"absolute-location-path"})}),(0,r.jsx)(n.td,{children:"Node set"}),(0,r.jsx)(n.td,{children:"A node set expression that starts with the\xa0/\xa0character"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"/parent/child[1]"}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"relative-location-path"}),(0,r.jsx)(n.td,{children:"Node set"}),(0,r.jsx)(n.td,{children:"A node set expression that does NOT start with the\xa0/\xa0character"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{children:["node()",(0,r.jsx)("br",{}),"pc:*"]})}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"boolean"})}),(0,r.jsx)(n.td,{children:"Boolean"}),(0,r.jsx)(n.td,{children:'A value expressing the concept of either "true" or "false".'}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{children:["$is-valid",(0,r.jsx)("br",{}),"true()"]})}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"string"})}),(0,r.jsx)(n.td,{children:"String"}),(0,r.jsx)(n.td,{children:"A sequence of Unicode characters."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{children:["'ABC110'",(0,r.jsx)("br",{}),'"My variable value"']})}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"number"})}),(0,r.jsx)(n.td,{children:"Number"}),(0,r.jsx)(n.td,{children:"A floating-point number."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)("pre",{children:(0,r.jsxs)("code",{children:["98",(0,r.jsx)("br",{}),"24.7"]})}),(0,r.jsx)("p",{children:"\xa0"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"variable-reference"})}),(0,r.jsx)(n.td,{children:"(Any)"}),(0,r.jsx)(n.td,{children:"A placeholder representing a variable."}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"$myvar"}),(0,r.jsx)("p",{children:"\xa0"})]})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"node-set-expressions",children:"Node set expressions"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Node set"})," is the most important of the (4) primitive data types that an XPath expression can evaluate to. XPath's mission in life is to represent paths leading to node sets in XML documents. These are different from paths leading to files on a file system."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What is a node set expression?"})}),"\n",(0,r.jsx)(n.p,{children:"A node set expression is a location path that identifies a node set in an XML document. Node set expressions are part of the XSLT 1.0 specification. A node set expression is made up of 1 or more steps that are node tests:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"node()\nOrder/text()\nCustomer\n/Customers/Customer/Orders\n"})}),"\n",(0,r.jsx)(n.p,{children:"This may involve explicitly stated axes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"parent::Customer\n"})}),"\n",(0,r.jsx)(n.p,{children:"filters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Order[@orderid >= 1000]\n"})}),"\n",(0,r.jsx)(n.p,{children:"unions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"order|contract\n"})}),"\n",(0,r.jsx)(n.p,{children:"wildcards:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"/Customers/*/Orders/@*\n"})}),"\n",(0,r.jsx)(n.p,{children:"and special abbreviated notations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:".\n..\n/Customers//Orders\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Absolute location paths and relative location paths"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"An absolute location path is a node set expression that DOES start with the\xa0/\xa0character. This character represents the root node, which is an imaginary node that is parent of the top-level document element of your USoft Blend script."}),"\n",(0,r.jsx)(n.li,{children:"A relative location path is a node set expression that does NOT start with the\xa0/\xa0character. A relative location path is relative to the current node. In a Blend script, the current node is the directive currently being processed. If this is a directive with embedded XML, you can use the relative location path to point to nodes inside this embedded XML (Example 3)."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 1"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:ReadXmlFile filepath="c:\\temp\\myxml.xml" assign:myvar="/*/Resources/RESOURCE[@type=\'SALES\']" />\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here, the absolute location path ",(0,r.jsx)(n.strong,{children:"/*/Resources/RESOURCE[@type='SALES']"}),' has the root node of the "c:\\temp\\myxml.xml" document as its root node.\nThis directive first reads the external file, which is an XML document, and then assigns to the myvar variable the node set returned by applying the absolute location path to the root node of the XML document. Later in the script you can use ',(0,r.jsx)(n.strong,{children:"$myvar"})," to refer to this node set."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 2"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<example xmlns:pc="Processing.Command"/>\n  <pc:defs>\n\xa0    <File path="c:\\temp\\assets.xml" entryname="assets/assets.xml"/>\n     <File path="c:\\temp\\resources.xml" entryname="mypath/resources.xml"/>\n  </pc:defs>\n  <pc:ZipFileCreate filepath="c:\\temp\\mynewzip.zip" select="/*/pc:defs/File" />\n</example>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here, the absolute location path ",(0,r.jsxs)(n.strong,{children:["/*/pc",":defs","/File"]})," has the root node of the script itself (the parent node of the ",(0,r.jsx)(n.code,{children:"<example>"})," document node) as its root node. The ",(0,r.jsxs)(n.strong,{children:["pc",":ZipFileCreate"]})," directive refers back to the ",(0,r.jsxs)(n.strong,{children:["pc",":defs"]})," section to find its input information."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 3"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:ZipFileCreate filepath="c:\\temp\\mynewzip.zip" pc:return="*[contains(@path,\'.xml\')]">\n     <File path="c:\\temp\\assets.xml" entryname="assets/assets.xml"/>\n     <File path="c:\\temp\\resources.xml" entryname="mypath/resources.xml"/>\n     <File path="c:\\temp\\resources.txt" entryname="mypath/resources.txt"/>\n</pc:ZipFileCreate>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here, the relative location path *",(0,r.jsx)(n.strong,{children:"[contains(@path,'.xml')]"})," has as context node the root node of the return value of pc",":ZipFileCreate",", which is the same as the embedded node set, ie., the non-visible parent node of the three ",(0,r.jsx)(n.code,{children:"<File>"})," elements.\nThis example creates a new ZIP file and returns a list of all those files zipped that have the .XML extension. The first two ",(0,r.jsx)(n.code,{children:"<File>"}),' elements referring to files with an ".xml" extension refer to the content that is zipped. The last ',(0,r.jsx)(n.code,{children:"<File>"})," element, which refers to a file with extension '.txt', is ignored."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example 4"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'<pc:JsonToXml assign:mydata="." >\n    <pc:ReadFile filepath="c:\\temp\\myfile.json"/>\n</pc:JsonToXml>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Here, the relative location path . (ie., the full stop character in the first line) has as its context node the root node of the embedded node set, ie., the non-visible parent node of the top-level document element of the JSON file found on the file system.\nThis example assigns to a variable called mydata the value of the ",(0,r.jsxs)(n.strong,{children:["pc",":JsonToXml"]})," element, which is itself the result of converting JSON code found in a file to XML.\nThe JSON code is first read, then converted to XML, and then stored in the mydata variable, ready to be referred to by ",(0,r.jsx)(n.strong,{children:"$mydata"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"booleans",children:"Booleans"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Boolean"})," is one of the (4) primitive data types that an XPath expression can evaluate to. There is no XPath syntax for representing boolean values directly, but Boolean values are returned by the XPath functions of ",(0,r.jsx)(n.strong,{children:"true()"})," and ",(0,r.jsx)(n.strong,{children:"false()"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Flag-based string-to-boolean conversion"})}),"\n",(0,r.jsxs)(n.p,{children:["USoft Blend applies ",(0,r.jsx)(n.em,{children:"implicit data type conversion"}),' rules between the 4 XPath data types (nodeset, string, number, boolean) in the same way as XPath 1.0 and XSLT 1.0. This subject is explored later in this article. In the case of booleans, USoft Blend offers an alternative string-to-boolean conversion mechanism referred to as "flag-based". "Flag-based" interprets the following strings (case-insensitively) as ',(0,r.jsx)(n.strong,{children:"true()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"true\nyes\n"})}),"\n",(0,r.jsxs)(n.p,{children:["and the following string (case-insensitively) as ",(0,r.jsx)(n.strong,{children:"false()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"false\nno\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This contrast with XPath's implicit conversion rule that non-empty strings always evaluate to ",(0,r.jsx)(n.strong,{children:"true()"}),'.\n"Flag-based" string-to-boolean conversion is not the default: you must switch it on explicitly. For details, go to ',(0,r.jsxs)(n.a,{href:"/udocs/Repositories/Blend_directives/pcassignboolean",children:["pc",":assign-boolean"]}),'.\nYou can execute "flag-based" string-to-boolean conversion explicitly by calling the \u201cbooleanflags',":ToBoolean",'\u201d function.\nYou can extend the list of string that "flag-based" conversion interprets as ',(0,r.jsx)(n.strong,{children:"false()"}),". For details, please look up:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["booleanflags",":Show"]}),"\n",(0,r.jsxs)(n.li,{children:["pc",":define-boolean-flags"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"strings",children:"Strings"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"String"}),", in the simplest sense of a string of Unicode characters, is one of the (4) primitive data types that an XPath expression can evaluate to. It is the only string data type that XPath has."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Explicit string typing"})}),"\n",(0,r.jsx)(n.p,{children:"In contexts where an XPath expression is expected, you can surround an XPath expression by quotes to express that you mean a string and not a node set expression (ie., not a node test). The following yields the string 'xy', as opposed to referring to a child element called 'xy\u2019:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<pc:value-of select=\"'xy'\" />\n"})}),"\n",(0,r.jsx)(n.p,{children:"Accordingly, you must quote literal string input parameters that you pass to XPath functions and Blend functions, since these function calls are just another type of XPath expression:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<pc:assign-nodeset mynodeset=\"{files:XmlFile('config.xml')}\" />\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Regular XML attribute values"})}),"\n",(0,r.jsxs)(n.p,{children:["Do not confuse XPath string expressions with regular XML attribute values that are ",(0,r.jsx)(n.em,{children:"string literals"}),". The latter are XML names. In this example, the 'ADMIN' string is a regular XML attribute value, and therefore is not quoted:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'<pc:assign-string user="ADMIN" />\n'})}),"\n",(0,r.jsx)(n.p,{children:"In this example, the SQL statement is a regular XML attribute, and therefore is not quoted. As a consequence, the quotes inside the SQL do not need to be escaped:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<pc:XmlExport sql=\"SELECT destination, tour_type FROM tour WHERE destination LIKE 'AUS%'\" />\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this example, the file path is a regular XML attribute, and therefore is not quoted:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:WriteFile filepath="c:\\temp\\HelloWorld.txt">Hello world</pc:WriteFile>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"numbers",children:"Numbers"}),"\n",(0,r.jsx)(n.p,{children:"Number, in the generic sense of a floating-point number such as:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"24.7\n"})}),"\n",(0,r.jsx)(n.p,{children:"is one of the (4) primitive data types that an XPath expression can evaluate to. It is the only numeric data type that XPath has.\nUSoft Blend treats numbers in the same way as XPath and XSLT. If an XPath expression is expected to be a number but cannot be converted to a number, this yields the special NaN (Not-a-Number) value."}),"\n",(0,r.jsx)(n.h3,{id:"function-calls",children:"Function calls"}),"\n",(0,r.jsx)(n.p,{children:"In USoft Blend, in contexts where an XPath expression is legal, you can use parenthesised expressions that call one of the following:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A USoft Blend function."}),"\n",(0,r.jsx)(n.li,{children:"An XPath function."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'From a syntax point of view, a call to a USoft Blend function may be recognised by the presence of an explicit namespace prefix as, for example, "dates:" in:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:value-of select="dates:ShowInputFormats" />\n'})}),"\n",(0,r.jsxs)(n.p,{children:["By contrast, a call to an XPath function may be recognised by the ",(0,r.jsx)(n.em,{children:"absence"})," of an explicit namespace prefix as, for example, in:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<pc:value-of select=\"concat( 'A', 'B' )\" />\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"USoft Blend functions"})}),"\n",(0,r.jsx)(n.p,{children:"When USoft Blend directives are executed, they call underlying programmed functions that access the source code that implements USoft Blend.\nYou can see how this is done by inspecting the XSLT stylesheet :"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"*usoft-install-dir*\\xsl\\Util\\Batch.1.0.xsl\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Click ",(0,r.jsx)(n.a,{href:"/Repositories/Blend_functions",children:"here"}),' for a list of USoft Blend functions. Alternatively, you can get a full list of USoft Blend functions by using the "functions" Blend command line option:']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"> *usoft-bindir*\\ublendit.exe functions\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"XPath functions"})}),"\n",(0,r.jsx)(n.p,{children:"In a USoft Blend context, in an XPath expression content, all the 27 XPath 1.0 functions are implicitly available:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Node set functions"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"String functions"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Boolean functions"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Number functions"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"count()"}),(0,r.jsx)(n.td,{children:"concat()"}),(0,r.jsx)(n.td,{children:"boolean()"}),(0,r.jsx)(n.td,{children:"ceiling()"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"id()"}),(0,r.jsx)(n.td,{children:"contains()"}),(0,r.jsx)(n.td,{children:"false()"}),(0,r.jsx)(n.td,{children:"floor()"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"last()"}),(0,r.jsx)(n.td,{children:"normalize-space()"}),(0,r.jsx)(n.td,{children:"lang()"}),(0,r.jsx)(n.td,{children:"number()"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"local-name()"}),(0,r.jsx)(n.td,{children:"starts-with()"}),(0,r.jsx)(n.td,{children:"not()"}),(0,r.jsx)(n.td,{children:"round()"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"name()"}),(0,r.jsx)(n.td,{children:"string()"}),(0,r.jsx)(n.td,{children:"true()"}),(0,r.jsx)(n.td,{children:"sum()"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"namespace-uri()"}),(0,r.jsx)(n.td,{children:"string-length()"}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"position()"}),(0,r.jsx)(n.td,{children:"substring()"}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{children:"substring-after()"}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{children:"substring-before()"}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{children:"translate()"}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"variable-references",children:"Variable references"}),"\n",(0,r.jsx)(n.p,{children:"USoft Blend borrows from XPath its"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$*variable*\n"})}),"\n",(0,r.jsx)(n.p,{children:"syntax for referring to variables. Once declared, a USoft Blend variable is global: it may be referred to from any later position in the Blend script."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Declaring Blend variables"})}),"\n",(0,r.jsx)(n.p,{children:"You have a number of different syntax options for introducing USoft Blend variables. It is also possible to load variables from an external file. Here is just one example of the declaration of a Blend variable:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:assign-string\n     mypath="{path:GetFullPath(directories:Get())}" />\n'})}),"\n",(0,r.jsx)(n.p,{children:"For an explanation of the curly braces in this example, go to \u201cEvaluated expressions vs. literals\u201d later in this article."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Referring to Blend variables"})}),"\n",(0,r.jsxs)(n.p,{children:["Here is just one example of how you can refer to the value of a variable called ",(0,r.jsx)(n.strong,{children:"myvariable"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:WriteFile filepath="{$myvariable}">Hello world</pc:WriteFile>\n'})}),"\n",(0,r.jsx)(n.p,{children:"For an explanation of the curly braces in this example, go to \u201cEvaluated expressions vs. literals\u201d later in this article."}),"\n",(0,r.jsx)(n.h3,{id:"implicit-xpath-data-type-conversion",children:"Implicit XPath data type conversion"}),"\n",(0,r.jsx)(n.p,{children:"When dealing with XPath expressions, USoft Blend applies the XPath 1.0 and XSLT 1.0 rules for implicit conversion between the 4 XPath data types (node set, string, number, boolean).\nFor convenience, this section summarises these rules."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Node set is expected"})}),"\n",(0,r.jsx)(n.p,{children:"No other data types are implicitly converted to node sets. As a consequence, if a node set is expected, you must supply an XPath expression that evaluates to a node set. Otherwise, it's an error."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"String is expected"})}),"\n",(0,r.jsx)(n.p,{children:"Whenever a string is expected:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A node set evaluates to the string-value of the first node in the node set, ie., the node in the node set that is first in document order."}),"\n",(0,r.jsx)(n.li,{children:"The number value NaN (\"not-a-number\") evaluates to the string 'NaN', and other number values convert to the string expression that expresses the number, with any leading zeros and (in decimal numbers) any trailing zeros stripped. Results include the string values:"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"'10'\n'10.5'\n'-10'\n'0'\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A boolean ",(0,r.jsx)(n.strong,{children:"true()"})," value converts to the string '",(0,r.jsx)(n.strong,{children:"true"}),"' (the 4 lowercase characters), and a boolean ",(0,r.jsx)(n.strong,{children:"false()"})," value converts to the string '",(0,r.jsx)(n.strong,{children:"false"}),"' (the 5 lowercase characters)."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Number is expected"})}),"\n",(0,r.jsx)(n.p,{children:"A number is expected when :"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"An XPath expression is passed as an argument to a function that returns a number, eg.,"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"round( expr )\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"An XPath expression is passed as a argument in a calculation, eg.:"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"*expr + 5*\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"An XPath expression is involved in a comparison, eg.,:"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"*expr = 10*\n"})}),"\n",(0,r.jsx)(n.p,{children:"Whenever a number is expected:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A node set is first converted to a string, ie., it is converted to the string-value of the node that is the first node in the node set in document order. Then, the resulting string is converted to a number."}),"\n",(0,r.jsx)(n.li,{children:"A string converts to a number following the IEEE 754 round-to-the-nearest rule. Any leading zeros and (in decimal numbers) any trailing zeros are first stripped."}),"\n",(0,r.jsxs)(n.li,{children:["Boolean ",(0,r.jsx)(n.strong,{children:"true()"})," converts to ",(0,r.jsx)(n.strong,{children:"1"})," and boolean ",(0,r.jsx)(n.strong,{children:"false()"})," converts to ",(0,r.jsx)(n.strong,{children:"0"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Boolean is expected"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:assign-string mysubdir="temp2">\n<pc:value-of select="path:Combine(\'c:\\temp\',$mysubdir)"/>\n'})}),"\n",(0,r.jsx)(n.p,{children:"Whenever a boolean is expected:"}),"\n",(0,r.jsxs)(n.p,{children:["1.If a ",(0,r.jsx)(n.em,{children:"value"})," of a different XPath data type is supplied:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A non-empty node set evaluates to boolean ",(0,r.jsx)(n.strong,{children:"true()"}),". The empty node set evaluates to boolean ",(0,r.jsx)(n.strong,{children:"false()"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["A non-empty string value evaluates to boolean ",(0,r.jsx)(n.strong,{children:"true()"}),". The empty string evaluates to boolean ",(0,r.jsx)(n.strong,{children:"false()"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:'As an alternative to this, USoft Blend offers "flag-based" string-to-boolean conversion discussed earlier in this article.'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The number values ",(0,r.jsx)(n.strong,{children:"0"})," (zero) and ",(0,r.jsx)(n.strong,{children:"NaN"})," (not-a-number) evaluate to boolean ",(0,r.jsx)(n.strong,{children:"false()"}),". Other number values evaluate to boolean ",(0,r.jsx)(n.strong,{children:"true()"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["2.If a ",(0,r.jsx)(n.em,{children:"comparison"})," is supplied,that is to say, an XPath expression that contains one of the comparison operators ",(0,r.jsx)(n.code,{children:"**="}),",\xa0 ",(0,r.jsx)(n.code,{children:"!="}),",\xa0 ",(0,r.jsx)(n.code,{children:"<="}),",\xa0 ",(0,r.jsx)(n.code,{children:"<"}),",\xa0 ",(0,r.jsx)(n.code,{children:">"}),",\xa0 ",(0,r.jsx)(n.code,{children:">="}),",\xa0 ",(0,r.jsx)(n.code,{children:"<>**"})," :"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If both operands are node sets, the comparison returns ",(0,r.jsx)(n.strong,{children:"true()"})," if there is any node in the first node set and any node in the second node set such that the result of comparing the string-value of the two nodes evaluates to ",(0,r.jsx)(n.strong,{children:"true()"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["If one operand is a node set and the other a boolean, the comparison returns ",(0,r.jsx)(n.strong,{children:"true()"})," if the result of converting the node-set to a boolean, when compared to the other boolean, evaluates to ",(0,r.jsx)(n.strong,{children:"true()"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["If one operand is a node set and the other a string or number, the comparison returns ",(0,r.jsx)(n.strong,{children:"true()"})," if the result of converting the node-set to a string value, when compared to the other value (string or number), evaluates to ",(0,r.jsx)(n.strong,{children:"true()"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Comparisons between values that are both not a node set (ie., that are both either string, number or boolean) are compared as booleans if at least one of them is boolean; otherwise, as numbers if at least one of them is a number; otherwise, as two strings."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"evaluated-expressions-vs-literal-expressions",children:"Evaluated expressions vs. literal expressions"}),"\n",(0,r.jsx)(n.p,{children:"There are times when you want XPath expressions to be evaluated (interpreted, resolved) and there are other times when you want expressions to be taken literally (literal expressions).\nTo accommodate these two needs, USoft Blend (and XSLT 1.0 generally) automatically evaluates expressions when it is likely that you want this, and in other cases does not. In those other cases, if you want evaluation, you must prompt the processor to evaluate the expression. You do that by embedding the expression in curly braces, turning it into what XSLT calls an Attribute Value Template."}),"\n",(0,r.jsx)(n.h3,{id:"automatic-evaluation",children:"Automatic evaluation"}),"\n",(0,r.jsx)(n.p,{children:"USoft Blend automatically evaluates XPath expressions in attribute values in the following contexts:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Values of ",(0,r.jsx)(n.strong,{children:"select"})," attributes."]}),"\n",(0,r.jsxs)(n.li,{children:["Values of ",(0,r.jsxs)(n.strong,{children:["pc",":return"]}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Values of attributes of the type ",(0,r.jsxs)(n.strong,{children:["assign",":variable"]}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Example"}),"\nThis example outputs the value ",(0,r.jsx)(n.code,{children:"c:\\\\temp\\\\temp 2"}),". Curly braces are NOT called for."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:assign-string mysubdir="temp2">\n<pc:value-of select="path:Combine(\'c:\\temp\',$mysubdir)"/>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"attribute-value-templates",children:"Attribute Value Templates"}),"\n",(0,r.jsxs)(n.p,{children:["If USoft Blend does not automatically evaluate but you want evaluation, you must surround the expression by curly braces (\xa0",(0,r.jsx)(n.code,{children:"{\xa0}"}),"), which turns it into an Attribute Value Template (AVT). A limitation, in comparison with XSLT, is that USoft Blend only supports AVT braces surrounding the entire expression of the attribute value.\nExample\nThis example deletes directory ",(0,r.jsx)(n.code,{children:"c:\\\\temp\\\\temp2"}),". Curly braces ARE called for."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:assign-string mysubdir="temp2">\n<pc:DeleteDirectories>\n     <Directory dirpath="{path:Combine(\'c:\\temp\',$mysubdir)}" />\n     ...\n</pc:DeleteDirectories>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Preventing automatic evaluation"}),"\nUSoft Blend automatically interprets a select attribute value, as well as a value of an attribute of the assign",":variable"," type, as an XPath location path representing a node set. For this reason, in these contexts, you must explicitly convert the expression if you mean to express not a node set but, for example, a string or a number.\nContrast the following 2 examples.\n",(0,r.jsx)(n.em,{children:"Example 1"}),"\nIn this example, xy is evaluated as an XPath expression: a relative location path. If the context node has one or more child elements named 'xy' then the string-value of the first 'xy' child element in document order is returned, following the XSLT specification."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<pc:value-of select="xy"> ... </pc:value-of>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Example 2"}),"\nThis example returns the character string 'xy'."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<pc:value-of select=\"'xy'\" />\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>a});var t=s(96540);const r={},i=t.createContext(r);function l(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);