"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[25280],{12980:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Repositories/Blend_directives/pcCompare","title":"pc:Compare","description":"This article is about the pc:Compare Blend directive.","source":"@site/docs/Repositories/Blend_directives/pcCompare.md","sourceDirName":"Repositories/Blend_directives","slug":"/Repositories/Blend_directives/pcCompare","permalink":"/udocs/Repositories/Blend_directives/pcCompare","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"pcCompare"},"sidebar":"sidebar","previous":{"title":"pc:comment-of","permalink":"/udocs/Repositories/Blend_directives/pccommentof"},"next":{"title":"pc:ConfigRulesService","permalink":"/udocs/Repositories/Blend_directives/pcConfigRulesService"}}');var a=n(74848),s=n(28453);const r={id:"pcCompare"},o="pc",c={},d=[{value:"<strong>pc</strong>",id:"pc-1",level:2},{value:"Input data format",id:"input-data-format",level:2},{value:"Key schema",id:"key-schema",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsxs)(t.h1,{id:"pc",children:["pc",":Compare"]})}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["This article is about the ",(0,a.jsxs)(t.strong,{children:["pc",":Compare"]}),(0,a.jsx)(t.a,{href:"/Repositories/Blend_directives",children:" Blend directive"}),"."]})}),"\n",(0,a.jsx)(t.h2,{id:"pc-1",children:(0,a.jsxs)(t.strong,{children:["pc",":Compare"]})}),"\n",(0,a.jsx)(t.p,{children:"Compares 2 XML data sets presented as files of the USoft data format."}),"\n",(0,a.jsx)(t.p,{children:"Returns an XML document that describes the differences between the data sets with the help of <Insert>, <Update> and <Delete> instruction tags. This return XML is not just a human-readable description. It may be executed in a USoft context to upgrade the source data set to the target data set automatically. This is done by calling the XML.IMPORT internal method or one of its variants, as described in detail in the USoft Definer Help."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"Syntax 1"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'<pc:Compare\n     alias="*name-literal*"\n     leftfile="*path*"\n     rightfile="*path*"\n     outputfile="*path*"\n />\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The required ",(0,a.jsx)(t.strong,{children:"alias"}),' identifies a connection to a Rules Service that you want to use to retrieve primary key information. The operation needs this information to understand on what basis data records must be compared, as explained in the "Key schema" section below. For more information on aliases, go to the pc',":RunRulesService",' help topic. If you are already in a USoft context where this information is available, pass the empty string: alias="". There is an alternative syntax for reading primary key information from a file instead of from a connection. See the "Key schema file" section below.']}),"\n",(0,a.jsxs)(t.p,{children:["The required ",(0,a.jsx)(t.strong,{children:"leftfile"})," and ",(0,a.jsx)(t.strong,{children:"rightfile"})," identify the files to be compared. The required ",(0,a.jsx)(t.strong,{children:"outputfile"})," identifies the name and location of the file where the outcome of the comparison must be written to."]}),"\n",(0,a.jsx)(t.admonition,{type:"danger",children:(0,a.jsxs)(t.p,{children:["Do not confuse ",(0,a.jsx)(t.strong,{children:"leftfile"})," and ",(0,a.jsx)(t.strong,{children:"rightfile"}),". The first is the target data set and the second is the source data set. The return document may be used to upgrade the source data set to the target data set but not the other way around."]})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"Example"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-xml",children:'<root xmlns:pc="Processing.Command" xmlns:assign="Processing.Command.Assign">\n  <pc:RunRulesService waittime="10000"\n        user="MYNAME" pwd="MYPWD" rdbmstype="oracle" connection="XE" application="USAUTH"\n        owner="MYNAME"\n        alias="x1" />   \n  <pc:Compare\n        alias="x1"      \n        leftfile="C:\\temp\\USAUTH.prev.xml"\n        rightfile="C:\\temp\\USAUTH.xml"\n        outputfile="C:\\temp\\USAUTH.diff.xml" />\n</root>\n'})}),"\n",(0,a.jsx)(t.h2,{id:"input-data-format",children:"Input data format"}),"\n",(0,a.jsxs)(t.p,{children:['The input files must have one of the USoft standard data formats described in detail in USoft Definer Help and output by the EXPORT method of USoft\'s "XML" internal component and its variants, including the pc',":XmlExport"," Blend directive."]}),"\n",(0,a.jsx)(t.h2,{id:"key-schema",children:"Key schema"}),"\n",(0,a.jsx)(t.p,{children:'In Syntax 1, the comparison is made on the basis of primary key information available at the required connection. This information is referred to as the "key schema". This information is essential when comparing different versions of a set of application data, since each database record is identified only by the primary key value(s) it holds.'}),"\n",(0,a.jsxs)(t.p,{children:["Key schemas are a USoft proprietary concept. A key schema is an internal or external XML document that describes, for each table definition in scope, what column or what set of columns constitutes that table's primary key. Each time you call <pc",":Compare","> with Syntax 1, a key schema file of a name similar to:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"tmpAF3D.tmp_keyschema.xsl\n"})}),"\n",(0,a.jsxs)(t.p,{children:["is output to the USoft Temporary Folder. You can also produce a key schema file yourself by calling the pc",":GenerateKeySchema"," directive. You can then make a comparison on the basis of an external key schema file that you identify explicitly. Use Syntax 2 instead of Syntax 1."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"Syntax 2"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'<pc:Compare\n     schemafile="*path*"\n     leftfile="*path*"\n     rightfile="*path*"\n     outputfile="*path*"\n />\n'})}),"\n",(0,a.jsxs)(t.p,{children:["In this syntax, the required ",(0,a.jsx)(t.strong,{children:"schemafile"})," attribute takes the place of the required alias attribute in Syntax 1. For the other attributes, see Syntax 1. ",(0,a.jsx)(t.strong,{children:"Schemafile"})," must point to a valid key schema file for the application."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(96540);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);