"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[42165],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var o=n(96540);const s={},r=o.createContext(s);function i(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:t},e.children)}},80467:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"Extensions/RDMI_Components/Query_protocol_component_table","title":"Query protocol, component table","description":"The query protocol","source":"@site/docs/Extensions/RDMI_Components/Query_protocol_component_table.md","sourceDirName":"Extensions/RDMI_Components","slug":"/Extensions/RDMI_Components/Query_protocol_component_table","permalink":"/udocs/Extensions/RDMI_Components/Query_protocol_component_table","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Query_protocol_component_table"},"sidebar":"sidebar","previous":{"title":"Components: Standard protocol","permalink":"/udocs/Extensions/RDMI_Components/Components_Standard_protocol"},"next":{"title":"Component querying multiple CSV files","permalink":"/udocs/Extensions/RDMI_Components/Component_querying_multiple_CSV_files"}}');var s=n(74848),r=n(28453);const i={id:"Query_protocol_component_table"},a="Query protocol, component table",l={},h=[{value:"The query protocol",id:"the-query-protocol",level:2},{value:"What is the query protocol?",id:"what-is-the-query-protocol",level:3},{value:"How does the query protocol work?",id:"how-does-the-query-protocol-work",level:3},{value:"Methods",id:"methods",level:3},{value:"Query protocol association",id:"query-protocol-association",level:3},{value:"Stateful component",id:"stateful-component",level:3},{value:"Component tables",id:"component-tables",level:2},{value:"Component tables, definition",id:"component-tables-definition",level:3},{value:"Component tables, extended query conditions",id:"component-tables-extended-query-conditions",level:3},{value:"Component tables, features and limitations",id:"component-tables-features-and-limitations",level:3},{value:"Component tables, error handling",id:"component-tables-error-handling",level:3}];function d(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"query-protocol-component-table",children:"Query protocol, component table"})}),"\n",(0,s.jsx)(t.h2,{id:"the-query-protocol",children:"The query protocol"}),"\n",(0,s.jsx)(t.h3,{id:"what-is-the-query-protocol",children:"What is the query protocol?"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.strong,{children:"query protocol"})," is a way of interacting with an RDMI component that involves passing a single row of data to the component and letting it return multiple columns and rows."]}),"\n",(0,s.jsx)(t.p,{children:"The query protocol lets you present data from external sources to the Rules Engine as if it were multi-row data in a relational table."}),"\n",(0,s.jsxs)(t.p,{children:["The typical way to achieve this is to build a ",(0,s.jsx)(t.strong,{children:"component table"}),". Your USoft application can use that component table (in constraint SQL, batch SQL, SQL in a GUI layer...) as if it were a normal database table. How the component table handles its data is programmed in the underlying component that uses the query protocol. The component table and the underlying component are linked on a 1:1 basis because they have the same name."]}),"\n",(0,s.jsx)(t.p,{children:"Examples of data that you may want to make available through the query protocol include:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Information about files in a folder on the file system."}),"\n",(0,s.jsx)(t.li,{children:"Data from a file storage, for example, an XML, JSON, CSV file, or an MS Excel spreadsheet."}),"\n",(0,s.jsx)(t.li,{children:"Data from a different database."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"If you want the end user to perform an external action (such as sending an e-mail) by pressing a push button or clicking a link, then use the standard protocol and not the query protocol."}),"\n",(0,s.jsx)(t.h3,{id:"how-does-the-query-protocol-work",children:"How does the query protocol work?"}),"\n",(0,s.jsx)(t.p,{children:"First you need to make sure your RDMI component has one or more associated query protocols. Each protocol designates one method as its EXE method, and another method as its FETCH method."}),"\n",(0,s.jsx)(t.p,{children:"Next, instead of calling a method of the component directly, you call a query protocol name. An INVOKE ... WITH SELECT ... statement is processed as follows if the INVOKE calls a query protocol name:"}),"\n",(0,s.jsx)(t.p,{children:"The query protocol works by calling one method of the component as the EXE method, and another method as a FETCH method. The operation breaks down into the following steps:"}),"\n",(0,s.jsx)(t.p,{children:"1.\xa0Execute the protocol's EXE method. This is the equivalent of executing a SELECT statement in an RDBMS."}),"\n",(0,s.jsx)(t.p,{children:"2.\xa0Execute the protocol's FETCH method and catch the Out parameter(s). Return the record to the caller. This is the equivalent of fetching the first record from an RDBMS query result."}),"\n",(0,s.jsx)(t.p,{children:"3.\xa0Repeat Step 2 until the component returns no further records, that is, until the FETCH method reports that there are no more records."}),"\n",(0,s.jsx)(t.p,{children:"This operation is executed each time a runtime user, or a program, calls a query protocol name you have defined, as opposed to calling a method directly. This principle is shown in this example."}),"\n",(0,s.jsx)(t.h3,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(t.p,{children:"To prepare a component for the query protocol, make sure you offer the following 2 methods in a way similar to the example."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{}),(0,s.jsx)(t.th,{})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"QueryExe()"}),(0,s.jsx)(t.td,{children:"This method contains input parameters for all columns of the table. The parameters indicate a column restriction. If the value for a column is NULL, there is no restriction. If there is a value, the records with these column values are retrieved."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"QueryFetch()"}),(0,s.jsx)(t.td,{children:"This method contains output parameters for all columns of the table. The method returns zero or one record when called. The records returned meet the same condition as stated for the QueryExe method."})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"If you want the component table to deal also with INSERT, UPDATE or DELETE, or all three, then you must also implement the following, as required:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{}),(0,s.jsx)(t.th,{})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"InsertRow()"}),(0,s.jsx)(t.td,{children:"Contains input parameters that correspond with the columns of the table. The method is called on the insert of a record, and inserts the data in the external data source."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"UpdateRow()"}),(0,s.jsx)(t.td,{children:"Contains input parameters that correspond with the columns of the table. The method is called on the update of a record. The method updates the data in the external data source. The primary key of the table is not updatable and therefore it is sufficient to pass only the new values to the method."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"DeleteRow()"}),(0,s.jsx)(t.td,{children:"Contains input parameters that correspond with the primary key columns of the table. The method is called on the delete of a record. The method deletes the data in the external data source."})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"When coding methods for the query protocol (as for the aggregate protocol), you must return the following standard integer values to express that a record is or is not found. See the example."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{}),(0,s.jsx)(t.th,{})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"-1\xa0"}),(0,s.jsx)(t.td,{children:"Error."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"0"}),(0,s.jsx)(t.td,{children:"No record returned."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"1"}),(0,s.jsx)(t.td,{children:"Record returned."})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"query-protocol-association",children:"Query protocol association"}),"\n",(0,s.jsx)(t.p,{children:"The following assumes that your component has a QueryExe and a QueryFetch method."}),"\n",(0,s.jsx)(t.p,{children:"To associate, for your component, a query protocol name to an EXE and a FETCH method:"}),"\n",(0,s.jsx)(t.p,{children:"1.\xa0In the info window where you coded the component, click the Query Protocol Associations tab page."}),"\n",(0,s.jsx)(t.p,{children:"2.\xa0Enter the name 'QUERY' for the protocol. This is the name that the component table will be looking for when queried."}),"\n",(0,s.jsx)(t.p,{children:"3.\xa0Enter the name 'QUERYEXE' in the Execute Method field."}),"\n",(0,s.jsx)(t.p,{children:"4.\xa0Enter the name 'QUERYFETCH' in the Fetch Method field."}),"\n",(0,s.jsx)(t.p,{children:"5.\xa0Save/commit."}),"\n",(0,s.jsx)(t.h3,{id:"stateful-component",children:"Stateful component"}),"\n",(0,s.jsx)(t.p,{children:"When you call a query protocol name, the USoft implementation is stateful by default, but if you want to combine the component with a component table then you are required to declare the component as being Stateful. Do this in the State tab in the info window where you coded the component."}),"\n",(0,s.jsx)(t.p,{children:"As is clear from the example, on this tab, you can declare further details about state, such as the component's lifetime, whether the component must be able to participate in a transaction and (if so) whether it must support Commit, Rollback, and Pre-Commit constraint handling, whether it supports a component table, and whether the component table implements INSERT, UPDATE, DELETE operations."}),"\n",(0,s.jsx)(t.h2,{id:"component-tables",children:"Component tables"}),"\n",(0,s.jsx)(t.h3,{id:"component-tables-definition",children:"Component tables, definition"}),"\n",(0,s.jsxs)(t.p,{children:["The technology of choice with a component supporting a query protocol is to build a ",(0,s.jsx)(t.strong,{children:"component table"}),'* "*on top of it" so that you can query an possibly manipulate the data handled by the component ',(0,s.jsx)(t.em,{children:"as if"})," it were an RDBMS table. The component in this construct is a ",(0,s.jsx)(t.strong,{children:"user-defined table component."})," Do not confuse with internal table components."]}),"\n",(0,s.jsx)(t.p,{children:"Create a table component by choosing Define, Tables, Component Tables from the Definer menu. Make sure you give the component table the same name as the user-defined table component that supports it. See the example for details."}),"\n",(0,s.jsx)(t.h3,{id:"component-tables-extended-query-conditions",children:"Component tables, extended query conditions"}),"\n",(0,s.jsxs)(t.p,{children:["You can enhance the performance of query conditions against a component table by using ",(0,s.jsx)(t.em,{children:"extended query conditions."})]}),"\n",(0,s.jsx)(t.p,{children:"How does this work?"}),"\n",(0,s.jsx)(t.p,{children:"By default, when the Rules Engine passes a query to a table component, only simple query conditions with an equality operator are passed to the component:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"*column* = *value*\n"})}),"\n",(0,s.jsxs)(t.p,{children:["More involved query conditions, such as the following, are NOT passed to the component. The component first returns ",(0,s.jsx)(t.em,{children:"all"})," ",(0,s.jsx)(t.em,{children:"rows."})," Then, the Rules Engine processes the query conditions. With large data volumes, this can easily result in bad performance."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"birth_date > '01-JAN-1959'\n\nlast_name != 'Hayes'\n\nlast_name LIKE 'A%'\n\n\n"})}),"\n",(0,s.jsx)(t.p,{children:"To solve this problem, you can pass the query conditions in XML format as the CONDITIONS parameter of the QUERYEXE method of the component. This way, the component can evaluate some or all of the extended query conditions itself. This reduces the number of records returned to the Rules Engine."}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"The Rules Engine always checks the returned records a second time. Valid records are never rejected.\nOnly those conditions that the component can safely use to reduce the number of records are added to the XML document.\nConditions that contain a reference to a column of another table are not added.\nIf a condition is nested with a condition on another table, the Rules Engine examines if the condition can safely be passed to the component or not."})}),"\n",(0,s.jsx)(t.p,{children:"To apply this technique:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"In Definer, open the appropriate table component."}),"\n",(0,s.jsx)(t.li,{children:"Click the State tab."}),"\n",(0,s.jsx)(t.li,{children:"Select the Extended query conditions check box."}),"\n",(0,s.jsx)(t.li,{children:"Convert the contents of your SQL WHERE clause to an XML document. Follow the instruction below."}),"\n",(0,s.jsx)(t.li,{children:"(Re-)write the QueryExe() method in the component code, so that the XML document is passed as the CONDITIONS parameter of the QUERYEXE method."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"To convert your WHERE clause to an XML document, pass your SQL statement to XML.SQL2XML:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"INVOKE XML.SQL2XML WITH\nSELECT\n    '*sql-statement*' SQLStatement\n\n"})}),"\n",(0,s.jsx)(t.p,{children:"For example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"INVOKE XML.SQL2XML WITH\nSELECT\n    'SELECT * FROM TOUR_PROGRAMME WHERE DESTINATION LIKE ''A%''' SQLStatement\n\n"})}),"\n",(0,s.jsx)(t.p,{children:"This reveals, for example, that the XML equivalent of query condition:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"WHERE DESTINATION LIKE 'A%'\n"})}),"\n",(0,s.jsx)(t.p,{children:"is:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-xml",children:'<Where>\n  <Operator name="LIKE" position="1">\n    <Column name="DESTINATION" position="1" table_name="TOUR_PROGRAMME"\n      table_info_window_name="Tour Programmes"\n      type="Column" prompt="Destination" datatype="String" dbtype="VARCHAR2"/>\n    <Value datatype="String" position="2">A%</Value>\n  </Operator>\n</Where>\n'})}),"\n",(0,s.jsx)(t.p,{children:"Passing query conditions as XML opens the way to customisation through XSL transformations. For example, you could decide to pass only a specific subset of the query conditions to the component, perhaps only those conditions which do not use functions."}),"\n",(0,s.jsx)(t.p,{children:"USoft ships a set of pre-defined XSL transformations and XML schemas to get you started in this direction."}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["You can find this material in ",(0,s.jsx)(t.strong,{children:"<USoft-installation-folder>\\xsl\\ExtendedConditions"}),"."]})}),"\n",(0,s.jsx)(t.p,{children:"Here is an explanation of each of these utility files."}),"\n",(0,s.jsx)(t.p,{children:'For all transformations, if the transformation fails, "0@0" is returned.'}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"File"})}),(0,s.jsx)(t.th,{children:(0,s.jsx)(t.strong,{children:"Explanation"})})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Evaluate.xsl"}),(0,s.jsxs)(t.td,{children:[(0,s.jsx)("p",{children:"This transformation sheet can be used to evaluate records returned by the external data source before returning them to the Rules Engine."}),(0,s.jsx)("p",{children:"'true' is returned if the record complies with the conditions, and 'false' if it does not."}),(0,s.jsx)("p",{children:"This will check whether the record complies with all the conditions in the CONDITIONS XML document."}),(0,s.jsx)("p",{children:"This can be useful in situations where the external data source cannot handle some of the conditions, and the connection between the Rules Engine and the component is slow (for example Internet). In this case, trying to reduce the number of records returned may result in a better performance."})]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"ExtractHardConditions.xsl"}),(0,s.jsx)(t.td,{children:"Extracts only the conditions that are an equation. The output is an XML document."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"SQL2XML.xsd"}),(0,s.jsxs)(t.td,{children:[(0,s.jsx)("p",{children:"This XML schema can be used to validate that you pass query parameters in the correct XML format."}),(0,s.jsx)("p",{children:"See SchemaPath in :"}),(0,s.jsx)("p",{children:"\xa0for details."})]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"TranslateToOdbc.xsl"}),(0,s.jsx)(t.td,{children:"Converts date values into ODBC format."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"WithoutFunctions.xsl"}),(0,s.jsx)(t.td,{children:"Removes conditions in which a function is used. The output is an XML document."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"WithoutSets.xsl"}),(0,s.jsx)(t.td,{children:"Removes conditions in which sets are used (for example: col1 in (1,2)). The output is an XML document."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)("p",{children:"XmlToSql.xsl"})}),(0,s.jsx)(t.td,{children:"Transforms the CONDITIONS XML document into a SQL WHERE clause. The output is a string."})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"component-tables-features-and-limitations",children:"Component tables, features and limitations"}),"\n",(0,s.jsx)(t.p,{children:"Component tables can be accessed as if they were normal database tables. In all USoft contexts where you can specify a SQL statement, you can refer to a component table. Component tables are allowed in all subqueries (i.e. NOT EXISTS, NOT IN etc)."}),"\n",(0,s.jsx)(t.p,{children:"In addition to querying a component table (SELECT), if the underlying component supports it, you can use INSERT, UPDATE, DELETE statements."}),"\n",(0,s.jsx)(t.p,{children:"Component tables have the following limitations:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"There is no outer-join support."}),"\n",(0,s.jsx)(t.li,{children:"CONNECT BY and START WITH are not allowed."}),"\n",(0,s.jsx)(t.li,{children:"Component tables cannot be subtypes or supertype tables."}),"\n",(0,s.jsx)(t.li,{children:"Primary key columns of Component Tables are non-updatable. This limitation makes the definition of the UpdateRow method easier: it gets parameters for every column. Without the restriction, the old values for the primary key would also have to be passed to the method."}),"\n",(0,s.jsx)(t.li,{children:"Binary data is not supported."}),"\n",(0,s.jsx)(t.li,{children:"The STDDEV and VARIANCE functions are not supported for queries on component tables."}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"component-tables-error-handling",children:"Component tables, error handling"}),"\n",(0,s.jsx)(t.p,{children:"It is possible to let the InsertRow, UpdateRow, and DeleteRow method fail by raising an exception."}),"\n",(0,s.jsx)(t.p,{children:"As part of this exception, you can provide a message. This message will then be displayed within a USoft environment. NO rollback will be performed. You can translate these messages by using Application Strings."}),"\n",(0,s.jsx)(t.p,{children:"This is the same transaction behavior as for regular tables in a USoft environment: If the record cannot be stored, no rollback is performed. If the PreCommit method fails, depending on the situation, a rollback is performed or not."})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);