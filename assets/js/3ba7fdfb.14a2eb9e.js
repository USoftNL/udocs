"use strict";(self.webpackChunkudocs=self.webpackChunkudocs||[]).push([[17562],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(96540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}},96946:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"Modeller_and_Rules_Engine/Supertypes_and_subtypes/Transitional_constraints_on_supertypes_and_subtypes","title":"Transitional constraints on supertypes and subtypes","description":"When you use a subtype table in a transitional constraint, the conditions under which the constraint are evaluated require special attention.","source":"@site/docs/Modeller_and_Rules_Engine/Supertypes_and_subtypes/Transitional_constraints_on_supertypes_and_subtypes.md","sourceDirName":"Modeller_and_Rules_Engine/Supertypes_and_subtypes","slug":"/Modeller_and_Rules_Engine/Supertypes_and_subtypes/Transitional_constraints_on_supertypes_and_subtypes","permalink":"/udocs/Modeller_and_Rules_Engine/Supertypes_and_subtypes/Transitional_constraints_on_supertypes_and_subtypes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"Transitional_constraints_on_supertypes_and_subtypes"},"sidebar":"sidebar","previous":{"title":"Constraints on supertypes and subtypes","permalink":"/udocs/Modeller_and_Rules_Engine/Supertypes_and_subtypes/Constraints_on_supertypes_and_subtypes"},"next":{"title":"GUI implementation of subtypes","permalink":"/udocs/Modeller_and_Rules_Engine/Supertypes_and_subtypes/GUI_implementation_of_subtypes"}}');var a=n(74848),i=n(28453);const o={id:"Transitional_constraints_on_supertypes_and_subtypes"},r="Transitional constraints on supertypes and subtypes",l={},u=[{value:"Notes",id:"notes",level:2}];function p(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"transitional-constraints-on-supertypes-and-subtypes",children:"Transitional constraints on supertypes and subtypes"})}),"\n",(0,a.jsx)(t.p,{children:"When you use a subtype table in a transitional constraint, the conditions under which the constraint are evaluated require special attention."}),"\n",(0,a.jsx)(t.p,{children:"The Fire On ... flags react to what happens to the supertype-subtype constellation as a whole, not to what happens to the subtype data alone."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"Example"})}),"\n",(0,a.jsx)(t.p,{children:"Each time new subtype data is entered, information about this event (such as a timestamp) must be logged in a special log table."}),"\n",(0,a.jsx)(t.p,{children:"You want to log these events when the entire constellation including the supertype data is new (INSERT of the record constellation), but also when the supertype already exists (UPDATE of the record constellation)."}),"\n",(0,a.jsx)(t.p,{children:"The constraint SQL statement has the following form:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"INSERT INTO \xa0 \xa0log_table\nSELECT \xa0 \xa0 \xa0 \xa0 log_information\nFROM \xa0 \xa0 \xa0 \xa0 \xa0 subtype_table\nWHERE \xa0 \xa0 \xa0 \xa0 \xa0subtype_indicator = 'Y'\nAND\n( \xa0 \xa0 \xa0 \xa0 \xa0old( subtype-indicator ) = 'N' \xa0 \xa0\n     OR \xa0 \xa0old( subtype-indicator ) IS NULL\n)\n"})}),"\n",(0,a.jsx)(t.p,{children:"The correct transition properties for this constraint are:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"Fire On Insert: \xa0 \xa0Always\nFire On Delete: \xa0 \xa0Never\nFire On Update: \xa0 \xa0Used Columns\n"})}),"\n",(0,a.jsx)(t.p,{children:"Fire On Update must be set to ensure that the constraint is also evaluated when supertype data already existed but subtype data is new."}),"\n",(0,a.jsx)(t.p,{children:"The WHERE clause is needed to ensure that the constraint is not evaluated when a column value in existing subtype data is modified. Without this clause, the constraint would also be evaluated if the subtype data were removed, because this would be an Update manipulation involving the subtype_indicator used column."}),"\n",(0,a.jsx)(t.h2,{id:"notes",children:"Notes"}),"\n",(0,a.jsx)(t.p,{children:"In the example, the transition table is the subtype table. It could equally well be the supertype table (appearing both in the FROM clause and in the Transition Table field). The subtype indicator is available to both the supertype table and the subtype table."}),"\n",(0,a.jsx)(t.p,{children:"If the constraint had additional clauses referring to subtype attributes, you would HAVE to use the subtype table, which would then also be the transition table."}),"\n",(0,a.jsx)(t.p,{children:"Transitional constraint evaluation for subtypes also depends on:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"The Update Supertype on Insert deployment configuration parameter setting in the Authorizer."}),"\n",(0,a.jsx)(t.li,{children:"The Delete Super on Delete subtype table attribute."}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}}}]);